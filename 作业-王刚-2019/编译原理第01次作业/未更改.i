#line 1 "C:\\Users\\a1547\\source\\repos\\编译原理\\编译原理\\源.cpp"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iostream"
// iostream standard header
#pragma once


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
// yvals_core.h internal header (core)
#pragma once



// All STL headers avoid exposing their contents when included by various
// non-C++-compiler tools to avoid breaking builds when we use newer language
// features in the headers than such tools understand.


#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"


// _HAS_CXX20 directly controls:
// P0020R6 atomic<float>, atomic<double>, atomic<long double>
// P0318R1 unwrap_reference, unwrap_ref_decay
// P0457R2 starts_with()/ends_with() For basic_string/basic_string_view
// P0458R2 contains() For Ordered And Unordered Associative Containers
// P0463R1 endian
// P0482R6 Library Support For char8_t
//     (mbrtoc8 and c8rtomb not yet implemented)
// P0487R1 Fixing operator>>(basic_istream&, CharT*)
// P0550R2 remove_cvref
// P0616R0 Using move() In <numeric>
// P0646R1 list/forward_list remove()/remove_if()/unique() Return size_type
// P0653R2 to_address()
// P0758R1 is_nothrow_convertible
// P0768R1 Library Support For The Spaceship Comparison Operator <=>
//     (partially implemented)
// P0769R2 shift_left(), shift_right()
// P0811R3 midpoint(), lerp()
//     (partially implemented, lerp() not yet constexpr)
// P0887R1 type_identity
// P0898R3 Standard Library Concepts
//     * common_reference
//     * common_type adjustment
//     * identity
// P0919R3 Heterogeneous Lookup For Unordered Containers
// P????R? directory_entry::clear_cache()

// _HAS_CXX20 indirectly controls:
// P0898R3 Standard Library Concepts
//     * <concepts>
//     * UniformRandomBitGenerator
// P1754R1 Rename Concepts To standard_case

// _HAS_CXX17 directly controls:
// P0005R4 not_fn()
// P0024R2 Parallel Algorithms
// P0025R1 clamp()
// P0030R1 hypot(x, y, z)
// P0031R0 constexpr For <array> (Again) And <iterator>
// P0032R3 Homogeneous Interface For variant/any/optional
// P0040R3 Extending Memory Management Tools
// P0067R5 Elementary String Conversions
//     (partially implemented)
// P0083R3 Splicing Maps And Sets
// P0084R2 Emplace Return Type
// P0088R3 <variant>
// P0137R1 launder()
// P0152R1 atomic::is_always_lock_free
// P0154R1 hardware_destructive_interference_size, etc.
// P0156R2 scoped_lock
// P0163R0 shared_ptr::weak_type
// P0185R1 is_swappable, is_nothrow_swappable
// P0209R2 make_from_tuple()
// P0218R1 <filesystem>
// P0220R1 <any>, <memory_resource>, <optional>, <string_view>, apply(), sample(), Boyer-Moore search()
// P0253R1 Fixing Searcher Return Types
// P0254R2 Integrating string_view And std::string
// P0258R2 has_unique_object_representations
// P0272R1 Non-const basic_string::data()
// P0295R0 gcd(), lcm()
// P0307R2 Making Optional Greater Equal Again
// P0336R1 Renaming Parallel Execution Policies
// P0337R0 Deleting polymorphic_allocator Assignment
// P0358R1 Fixes For not_fn()
// P0393R3 Making Variant Greater Equal
// P0394R4 Parallel Algorithms Should terminate() For Exceptions
// P0403R1 UDLs For <string_view> ("meow"sv, etc.)
// P0426R1 constexpr For char_traits
// P0433R2 Deduction Guides For The STL
// P0452R1 Unifying <numeric> Parallel Algorithms
// P0504R0 Revisiting in_place_t/in_place_type_t<T>/in_place_index_t<I>
// P0505R0 constexpr For <chrono> (Again)
// P0508R0 Clarifying insert_return_type
// P0510R0 Rejecting variants Of Nothing, Arrays, References, And Incomplete Types
// P0602R4 Propagating Copy/Move Triviality In variant/optional
// P0604R0 invoke_result, is_invocable, is_nothrow_invocable
// P0607R0 Inline Variables For The STL
// P0682R1 Repairing Elementary String Conversions
// P0739R0 Improving Class Template Argument Deduction For The STL
// P0858R0 Constexpr Iterator Requirements

// _HAS_CXX17 indirectly controls:
// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff
// P0003R5 Removing Dynamic Exception Specifications
// P0004R1 Removing Deprecated Iostreams Aliases
// P0226R1 Mathematical Special Functions
// P0298R3 std::byte
// P0302R1 Removing Allocator Support In std::function
// LWG 2385 function::assign allocator argument doesn't make sense
// LWG 2921 packaged_task and type-erased allocators
// LWG 2976 Dangling uses_allocator specialization for packaged_task
// The non-Standard std::tr1 namespace and TR1-only machinery
// Enforcement of matching allocator value_types
// [[nodiscard]] attributes on STL functions

// _HAS_CXX17 and _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS control:
// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// P0618R0 Deprecating <codecvt>
// Other C++17 deprecation warnings

// _HAS_CXX20 and _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS control:
// Other C++20 deprecation warnings

// Implemented unconditionally:
// N3911 void_t
// N4089 Safe Conversions In unique_ptr<T[]>
// N4169 invoke()
// N4258 noexcept Cleanups
// N4259 uncaught_exceptions()
// N4277 Trivially Copyable reference_wrapper
// N4279 insert_or_assign()/try_emplace() For map/unordered_map
// N4280 size(), empty(), data()
// N4366 Precisely Constraining unique_ptr Assignment
// N4387 Improving pair And tuple
// N4389 bool_constant
// N4508 shared_mutex (Untimed)
// N4510 Supporting Incomplete Types In vector/list/forward_list
// P0006R0 Variable Templates For Type Traits (is_same_v, etc.)
// P0007R1 as_const()
// P0013R1 Logical Operator Type Traits (conjunction, etc.)
// P0033R1 Rewording enable_shared_from_this
// P0063R3 C11 Standard Library
// P0074R0 owner_less<>
// P0092R1 <chrono> floor(), ceil(), round(), abs()
// P0414R2 shared_ptr<T[]>, shared_ptr<T[N]>
// P0418R2 atomic compare_exchange memory_order Requirements
// P0435R1 Overhauling common_type
// P0497R0 Fixing shared_ptr For Arrays
// P0513R0 Poisoning hash
// P0516R0 Marking shared_future Copying As noexcept
// P0517R0 Constructing future_error From future_errc
// P0548R1 Tweaking common_type And duration
// P0558R1 Resolving atomic<T> Named Base Class Inconsistencies
// P0599R1 noexcept hash
// P0771R1 noexcept For std::function's Move Constructor
// P0777R1 Avoiding Unnecessary decay
// P0809R0 Comparing Unordered Containers
// P0941R2 Feature-Test Macros
// P0972R0 noexcept For <chrono> zero(), min(), max()
// P1164R1 Making create_directory() Intuitive

// Parallel Algorithms Notes
// C++ allows an implementation to implement parallel algorithms as calls to the
// serial algorithms. This implementation parallelizes several common algorithm
// calls, but not all.
//
// The following algorithms are parallelized.
// * adjacent_difference
// * adjacent_find
// * all_of
// * any_of
// * count
// * count_if
// * equal
// * exclusive_scan
// * find
// * find_end
// * find_first_of
// * find_if
// * find_if_not
// * for_each
// * for_each_n
// * inclusive_scan
// * is_heap
// * is_heap_until
// * is_partitioned
// * is_sorted
// * is_sorted_until
// * mismatch
// * none_of
// * partition
// * reduce
// * remove
// * remove_if
// * replace
// * replace_if
// * search
// * search_n
// * set_difference
// * set_intersection
// * sort
// * stable_sort
// * transform
// * transform_exclusive_scan
// * transform_inclusive_scan
// * transform_reduce
//
// The following are not presently parallelized:
//
// No apparent parallelism performance improvement on target hardware; all
// algorithms which merely copy or permute elements with no branches are
// typically memory bandwidth limited.
// * copy
// * copy_n
// * fill
// * fill_n
// * move
// * reverse
// * reverse_copy
// * rotate
// * rotate_copy
// * shift_left
// * shift_right
// * swap_ranges
//
// Confusion over user parallelism requirements exists; likely in the above
// category anyway.
// * generate
// * generate_n
//
// Effective parallelism suspected to be infeasible.
// * partial_sort
// * partial_sort_copy
//
// Not yet evaluated; parallelism may be implemented in a future release and is
// suspected to be beneficial.
// * copy_if
// * includes
// * inplace_merge
// * lexicographical_compare
// * max_element
// * merge
// * min_element
// * minmax_element
// * nth_element
// * partition_copy
// * remove_copy
// * remove_copy_if
// * replace_copy
// * replace_copy_if
// * set_symmetric_difference
// * set_union
// * stable_partition
// * unique
// * unique_copy

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
//
// crtdefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used across the Visual C++ Libraries.  The lack of #pragma once
// is deliberate.
//
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
#pragma once
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//




// Many VCRuntime headers avoid exposing their contents to non-compilers like
// the Windows resource compiler and Qt's meta-object compiler (moc).


#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.

    
    

#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
        
            
        

#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
    #line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
#pragma once

/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indiates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*/





#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"



#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

























// Disable expansion of SAL macros in non-Prefast mode to
// improve compiler throughput.


#line 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"


#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

// safeguard for MIDL and RC builds



#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"



#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"











#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






// Some annotations aren't officially SAL2 yet.

#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"


//============================================================================
//   Structural SAL:
//     These annotations modify the use of other annotations.  They may
//     express the annotation target (i.e. what parameter/field the annotation
//     applies to) or the condition under which the annotation is applicable.
//============================================================================

// _At_(target, annos) specifies that the annotations listed in 'annos' is to
// be applied to 'target' rather than to the identifier which is the current
// lexical target.


// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that
// target names a buffer, and each annotation in annos is applied to each
// element of target up to bound, with the variable named in iter usable
// by the annotations to refer to relevant offsets within target.


// _When_(expr, annos) specifies that the annotations listed in 'annos' only
// apply when 'expr' evaluates to non-zero.




// <expr> indicates whether normal post conditions apply to a function


// <expr> indicates whether post conditions apply to a function returning
// the type that this annotation is applied to


// Establish postconditions that apply only if the function does not succeed


// Establish postconditions that apply in both success and failure cases.
// Only applicable with functions that have  _Success_ or _Return_type_succss_.


// Usable on a function defintion. Asserts that a function declaration is
// in scope, and its annotations are to be used. There are no other annotations
// allowed on the function definition.


// _Notref_ may precede a _Deref_ or "real" annotation, and removes one
// level of dereference if the parameter is a C++ reference (&).  If the
// net deref on a "real" annotation is negative, it is simply discarded.


// Annotations for defensive programming styles.







//============================================================================
//   _In_/_Out_ Layer:
//============================================================================

// Reserved pointer parameters, must always be NULL.


// _Const_ allows specification that any namable memory location is considered
// readonly for a given call.



// Input parameters --------------------------

//   _In_ - Annotations for parameters where data is passed into the function, but not modified.
//          _In_ by itself can be used with non-pointer types (although it is redundant).

// e.g. void SetPoint( _In_ const POINT* pPT );



// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );




// 'input' buffers with given size











// 'input' buffers valid to the given end pointer








// Output parameters --------------------------

//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.
//           These are mostly used where the pointer/reference is to a non-pointer type.
//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.

// e.g. void GetPoint( _Out_ POINT* pPT );


























// Inout parameters ----------------------------

//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and
//        potentially modified.
//          void ModifyPoint( _Inout_ POINT* pPT );
//          void ModifyPointByRef( _Inout_ POINT& pPT );




// For modifying string buffers
//   void toupper( _Inout_z_ char* sz );



// For modifying buffers with explicit element size











// For modifying buffers with explicit byte size










// Pointer to pointer parameters -------------------------

//   _Outptr_ - Annotations for output params returning pointers
//      These describe parameters where the called function provides the buffer:
//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);
//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates
//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.
//
//    _Outptr_opt_ - describes parameters that are allowed to be NULL.
//    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.
//
//    Example:
//       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);
//    Callers:
//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL
//       MyFunc(&pData1, &pData2);     // ok: both non-NULL
//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call






// Annotations for _Outptr_ parameters returning pointers to null terminated strings.






// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.




// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,
// following the COM convention of setting the output to NULL on failure.
// The current implementation is identical to _Outptr_result_nullonfailure_.
// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.






// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes

































// Annotations for output reference to pointer parameters.


















// Annotations for output reference to pointer parameters that guarantee
// that the pointer is set to NULL on failure.


// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.




// return values -------------------------------

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const noexcept;



// used with allocated but not yet initialized objects




// used with allocated and initialized objects
//    returns single valid object


//    returns pointer to initialized buffer of specified size







//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'






// Annotations for strict type checking




// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();



// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );









// annotations to express value of integral or pointer parameter









// annotation to express that a value (usually a field of a mutable class)
// is not changed by a function call


// Annotations to allow expressing generalized pre and post conditions.
// 'cond' may be any valid SAL expression that is considered to be true as a precondition
// or postcondition (respsectively).



// Annotations to express struct, class and field invariants




















//============================================================================
//   _Pre_/_Post_ Layer:
//============================================================================

//
// Raw Pre/Post for declaring custom pre/post conditions
//




//
// Validity property
//





//
// Buffer size properties
//

// Expressing buffer sizes without specifying pre or post condition








// Expressing buffer size as pre or post condition










//
// Pointer null-ness properties
//




//
// _Pre_ annotations ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string


// valid size unknown or indicated by type (e.g.:LPSTR)





// Overrides recursive valid when some field is not yet initialized when using _Inout_


// used with allocated but not yet initialized objects




//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call


// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );



// e.g. void free( _Post_ptr_invalid_ void* pv );


// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );


// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);







#pragma region Input Buffer SAL 1 compatibility macros

/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter





// valid buffer extent described by a constant extression





// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter





// nullterminated valid buffer extent described by a constant extression





// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );






// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by another parameter multiplied by a constant expression





// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );





// only use with dereferenced arguments e.g. '*pcch'










// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );






// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );










// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );


















// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );















// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
















// returning pointers to valid objects



// annotations to express 'boundedness' of integral value parameter








// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );





// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );





//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );



// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex condition





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter





// valid buffer extent is described by a constant expression





// valid buffer extent is described by a complex expression





// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );








// restrict access rights



//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );



// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );







//
// _Deref_ret_ ---
//




//
// special _Deref_ ---
//


//
// _Ret_ ---
//

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );



// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter





// Buffer capacity is described by a constant expression





// Buffer capacity is described by a complex condition





// return value is nullterminated and capacity is given by another parameter





// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter





// Valid Buffer extent is described by a constant expression





// Valid Buffer extent is described by a complex expression





// return value is nullterminated and length is given by another parameter






// _Pre_ annotations ---


// restrict access rights



// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter





// buffer capacity described by a constant expression







// buffer capacity is described by another parameter multiplied by a constant expression



// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);



// buffer capacity described by a complex condition





// buffer capacity described by the difference to another pointer parameter



// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );















// known capacity and valid but unknown readable extent















// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter





// Valid buffer extent described by a constant expression





// Valid buffer extent described by a complex expression





// Valid buffer extent described by the difference to another pointer parameter




// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call


// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );



// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );







// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );







//
// _Prepost_ ---
//
// describing conditions that hold before and after the function call



















//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call










































//
// _Deref_<miscellaneous>
//
// used with references to arrays







#pragma endregion Input Buffer SAL 1 compatibility macros


//============================================================================
//   Implementation Layer:
//============================================================================


// Naming conventions:
// A symbol the begins with _SA_ is for the machinery of creating any
// annotations; many of those come from sourceannotations.h in the case
// of attributes.

// A symbol that ends with _impl is the very lowest level macro.  It is
// not required to be a legal standalone annotation, and in the case
// of attribute annotations, usually is not.  (In the case of some declspec
// annotations, it might be, but it should not be assumed so.)  Those
// symols will be used in the _PreN..., _PostN... and _RetN... annotations
// to build up more complete annotations.

// A symbol ending in _impl_ is reserved to the implementation as well,
// but it does form a complete annotation; usually they are used to build
// up even higher level annotations.



























































#line 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






























#line 1586 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
























#line 1611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

// Using "nothing" for sal










#line 1624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






































#line 1663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"















































































































#line 1775 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






































































































#line 1878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"








































































































































































#line 2047 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

































































































// Obsolete -- may be needed for transition to attributes.



#line 2149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/






#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*/



















































































































































































































#line 2595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/
































































































































































































/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/






















#line 2868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"









#line 2878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"


    
    
#line 2883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






#line 2890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
#line 2891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"






#line 2898 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"
#line 2899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"











#line 2911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

//
// Set the analysis mode (global flags to analysis).
// They take effect at the point of declaration; use at global scope
// as a declaration.
//

// Synthesize a unique symbol.








//
// Floating point warnings are only meaningful in kernel-mode on x86
// so avoid reporting them on other platforms.
//













#line 2945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

// The following are predefined:
//  _Analysis_operator_new_throw_   (operator new throws)
//  _Analysis_operator_new_null_        (operator new returns null)
//  _Analysis_operator_new_never_fails_ (operator new never fails)
//

// Function class annotations.














}
#line 2969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"
/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/




#pragma once


extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"











































































































































































































































































#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"



#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"
















































#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"






/*
 * Old spelling: will be deprecated
 */


































#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"


}
#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"

#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\concurrencysal.h"
#line 2971 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\sal.h"

#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"
//
// vadefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header
// in the CRT header lattice, and is always the first CRT header to be included,
// explicitly or implicitly.  Therefore, this header also has several definitions
// that are used throughout the CRT.
//
#pragma once



#pragma pack(push, 8)


extern "C" {
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"



#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"


    
    


        typedef unsigned int uintptr_t;
    #line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"


    


#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"





#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"



#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"
    
    
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"











#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"

    

    
    
    










































#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"


} // extern "C"
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } // extern "C++"

    





#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vadefs.h"

#pragma pack(pop)
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.


    



    





















#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
















    

#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
        
    #line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    

#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
        
    #line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// Definitions of calling conventions used code sometimes compiled as managed



#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
    
    
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"




    
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



// Definitions of common __declspecs




    


#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
    
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"




    
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    
        
        
    

#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// For backwards compatibility


// Definitions of common types





    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// Indicate that these common types are defined

    
#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    
#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// Provide a typedef for wchar_t for use under /Zc:wchar_t-






    
        
    

#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
    
#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



#line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    
        
    

#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

    


#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
        
        
    #line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

    
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// [[nodiscard]] attributes on STL functions

    

#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
        
    #line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



#line 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
    
#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

// See note on use of "deprecate" at the top of this file




#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    


        




    #line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"



#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    
        
    


#line 328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    
        void __fastcall __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    


#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 341 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 349 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"

} __pragma(pack(pop))

#line 353 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
//
// corecrt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the CoreCRT library.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Annotation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    

#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
        
    

#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

// If you need the ability to remove __declspec(import) from an API, to support static replacement,
// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.

    
#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    

#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
        
    

#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    


#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"





#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators

    


#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

// The CLR requires code calling other SecurityCritical code or using SecurityCritical types
// to be marked as SecurityCritical.
// _CRT_SECURITYCRITICAL_ATTRIBUTE covers this for internal function definitions.
// _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE is for inline pure functions defined in the header.
// This is clr:pure-only because for mixed mode we compile inline functions as native.



    
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"













    


        
    #line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Miscellaneous Stuff
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"










    
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"









// CRT headers are included into some kinds of source files where only data type
// definitions and macro definitions are required but function declarations and
// inline function definitions are not.  These files include assembly files, IDL
// files, and resource files.  The tools that process these files often have a
// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro
// is defined to 1 when we are compiling a file that actually needs functions to
// be declared (and defined, where applicable), and to 0 when we are compiling a
// file that does not.  This allows us to suppress declarations and definitions
// that are not compilable with the aforementioned tools.

    

#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
        
    #line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


 
  

#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
   
  #line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
 





#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Windows API Partitioning and ARM Desktop Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    











        
    #line 240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    
#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    
        
    

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

// Verify that the ARM Desktop SDK is available when building an ARM Desktop app








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Invalid Parameter Handler
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    __declspec(dllimport) void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    
        

    













#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Deprecation and Warnings
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+











#line 329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    


        


    #line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Managed CRT Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    






        
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    


        
    #line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// SecureCRT Configuration
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"















#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"





    
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    

#line 416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    


        


            
        #line 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"





#line 439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    


        



    #line 449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    
        
    



#line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

    
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0
        
    



#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

    
        
              
        

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    



#line 481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

    
        
    



#line 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

    
        
    



#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    
#line 502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Basic Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ // state of a multibyte translation
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 542 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



#line 546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

// Indicate that these common types are defined

    
#line 559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Secure Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"






































































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Standard Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2005 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 2007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// CRT DLL Export/Import Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// used to annotate symbols exported from msvcp140

    

#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
        
    #line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"

// used to annotate symbols exported from msvcp140_1

    

#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
        
    #line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"

// used to annotate symbols exported from msvcp140_2

    

#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
        
    #line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"

// Symbols exported from msvcp140_codecvt_ids are annotated with _CRT_SATELLITE_CODECVT_IDS, except for symbols which
// are data members of classes exported from msvcp140 that must themselves be exported from msvcp140_codecvt_ids, which
// are annotated with _CRT_SATELLITE_CODECVT_IDS_NOIMPORT.

    


#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
        
        
    


#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"


    

#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
        
            
        

#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
    #line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"


    

#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"

#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
        
    #line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\crtdefs.h"
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"
// xkeycheck.h internal header
#pragma once







// clang-format off
// #if defined($KEYWORD)
// #define $KEYWORD EMIT WARNING C4005
// #error The C++ Standard Library forbids macroizing the keyword "$KEYWORD". \
// Enable warning C4005 to find the forbidden define.
// #endif // $KEYWORD
// clang-format on

// *don't* check the "alternative token representations"

// keywords:




#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 146 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 218 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"






#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 333 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 339 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 375 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 387 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 399 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 411 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 447 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 489 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 501 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"

// contextual keywords (a.k.a. "identifiers with special meaning"):




#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 538 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"

// attribute-tokens:




#line 545 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 551 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 557 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"

// not checking "likely" because it is commonly defined as a function-like macro





#line 577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 583 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 589 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"





#line 595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"

// not checking "unlikely" because it is commonly defined as a function-like macro

#line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"

#line 601 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"
#line 602 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xkeycheck.h"

// Copyright (c) by P.J. Plauger. All rights reserved.
// Consult your license regarding permissions and restrictions.
// V6.50:0009
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"




#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"



#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"



#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// Controls whether the STL uses "if constexpr" internally





#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// warning C4577: 'noexcept' used with no exception handling mode specified;
// termination on exception is not guaranteed. Specify /EHsc (/Wall)




#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// error C4984: 'if constexpr' is a C++17 language extension




#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"



#line 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// warning C4412: function signature contains type 'meow'; C++ objects are unsafe to pass between pure code
//                and mixed or native. (/Wall)
// warning C4455: literal suffix identifiers that do not start with an underscore are reserved
// warning C4472: 'meow' is a native enum: add an access specifier (private/public)
//                to declare a managed enum (/Wall)
// warning C4494: Ignoring __declspec(allocator) because the function return type is not a pointer or reference
// warning C4514: unreferenced inline function has been removed (/Wall)
// warning C4571: Informational: catch(...) semantics changed since Visual C++ 7.1;
//                structured exceptions (SEH) are no longer caught (/Wall)
// warning C4574: 'MACRO' is defined to be '0': did you mean to use '#if MACRO'? (/Wall)
// warning C4582: 'union': constructor is not implicitly called (/Wall)
// warning C4583: 'union': destructor is not implicitly called (/Wall)
// warning C4587: behavior change: constructor is no longer implicitly called (/Wall)
// warning C4588: behavior change: destructor is no longer implicitly called (/Wall)
// warning C4619: #pragma warning: there is no warning number 'number' (/Wall)
// warning C4623: default constructor was implicitly defined as deleted (/Wall)
// warning C4625: copy constructor was implicitly defined as deleted (/Wall)
// warning C4626: assignment operator was implicitly defined as deleted (/Wall)
// warning C4643: Forward declaring 'meow' in namespace std is not permitted by the C++ Standard. (/Wall)
// warning C4702: unreachable code
// warning C4793: function compiled as native
// warning C4820: 'N' bytes padding added after data member 'meow' (/Wall)
// warning C4988: variable declared outside class/function scope (/Wall /d1WarnOnGlobals)
// warning C5026: move constructor was implicitly defined as deleted (/Wall)
// warning C5027: move assignment operator was implicitly defined as deleted (/Wall)
// warning C5045: Compiler will insert Spectre mitigation for memory load if /Qspectre switch specified (/Wall)


// clang-format off







// clang-format on
#line 339 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// warning: constexpr if is a C++17 extension [-Wc++17-extensions]
// warning: user-defined literal suffixes not starting with '_' are reserved [-Wuser-defined-literals]
// warning: unknown pragma ignored [-Wunknown-pragmas]











#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"






#line 363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"












#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"


#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"


#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"







#line 392 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"



#line 396 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"



#line 400 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// C++17 constexpr additions


#line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0607R0 Inline Variables For The STL


#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff


#line 419 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0003R5 Removing Dynamic Exception Specifications


#line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0004R1 Removing Deprecated Iostreams Aliases


#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0067R5 Elementary String Conversions


#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0226R1 Mathematical Special Functions


#line 439 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0298R3 std::byte


#line 444 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0302R1 Removing Allocator Support In std::function
// LWG 2385 function::assign allocator argument doesn't make sense
// LWG 2921 packaged_task and type-erased allocators
// LWG 2976 Dangling uses_allocator specialization for packaged_task


#line 452 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// The non-Standard std::tr1 namespace and TR1-only machinery


#line 457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// STL4000 is "_STATIC_CPPLIB is deprecated", currently in yvals.h
// STL4001 is "/clr:pure is deprecated", currently in yvals.h










#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 472 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// STL4003 was "The non-Standard std::identity struct is deprecated and will be REMOVED."

// Enforcement of matching allocator value_types


#line 479 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"







// Enforcement of Standard facet specializations


#line 490 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"










#line 501 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// Controls whether the STL will force /fp:fast to enable vectorization of algorithms defined
// in the standard as special cases; such as reduce, transform_reduce, inclusive_scan, exclusive_scan





#line 510 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 511 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// Controls whether the STL supports char8_t as a character type.
// MSVC accepts /Zc:char8_t in all language modes, so the STL provides minimal
// support sub-C++20.

// Clang can't mangle char8_t on Windows, but the feature-test macro is defined.
// This issue has been fixed for the 8.0.1 release.


#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 525 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// Other C++17 deprecation warnings

// N4659 D.4 [depr.cpp.headers]






#line 539 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 541 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.6 [depr.str.strstreams]





#line 550 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.7 [depr.uncaught]







#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 565 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.8.1 [depr.weak.result_type]
// N4659 D.8.2 [depr.func.adaptor.typedefs]







#line 577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 579 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.8.3 [depr.negators]







#line 590 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// STL4009 was "std::allocator<void> is deprecated in C++17"

// N4659 D.9 [depr.default.allocator]







#line 605 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 607 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.10 [depr.storage.iterator]







#line 618 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 620 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.11 [depr.temporary.buffer]






#line 630 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 632 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.12 [depr.meta.types]






#line 642 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 644 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.12 [depr.meta.types]







#line 655 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 657 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.13 [depr.iterator.primitives]











#line 672 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 674 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.14 [depr.util.smartptr.shared.obs]






#line 684 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 686 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4659 D.15 [depr.locale.stdcvt]
// N4659 D.16 [depr.conversions]











#line 702 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 704 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// STL4018 was "The non-Standard std::tr2::sys namespace is deprecated and will be REMOVED."














#line 721 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// P0482R6 Library Support For char8_t
// Other C++20 deprecation warnings

// N4810 D.16 [depr.locale.category]








#line 736 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// N4810 D.17 [depr.fs.path.factory]








#line 750 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 752 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"











#line 764 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"












#line 777 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// next warning number: STL4024


// LIBRARY FEATURE-TEST MACROS

// C++14
















#line 801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"





// C++17












#line 820 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"


















































#line 871 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// C++20

























#line 901 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

// EXPERIMENTAL
















#line 920 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 921 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"





// NAMESPACE




// We use the stdext (standard extension) namespace to contain extensions that are not part of the current standard














#line 947 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"









#line 957 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

#line 959 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"
#line 960 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals_core.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iostream"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"
// istream standard header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"
// ostream standard header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"
// ios standard header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"
// xlocnum internal header (from <locale>)
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\climits"
// climits standard header (core)
#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"
//
// limits.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <limits.h> header.
//
#pragma once




__pragma(pack(push, 8)) extern "C" {









    
    



#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"



























// minimum signed 64 bit value

// maximum signed 64 bit value

// maximum unsigned 64 bit value









#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"


    


        
    #line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"
#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"


    
        
    #line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits.h"



} __pragma(pack(pop))
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\climits"

#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\climits"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\climits"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"
// cmath standard header
#pragma once


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
// yvals.h internal header
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
//
// crtdbg.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Public debugging facilities for the CRT
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new_debug.h"
//
// vcruntime_new_debug.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of the debug operators new and delete.
//
#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"
//
// vcruntime_new.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of memory management functions in the VCRuntime.
//
#pragma once




extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 













    namespace std
    {
        struct nothrow_t {

            explicit nothrow_t() = default;
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"
        };

        


            extern nothrow_t const nothrow;
        #line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"
    }
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"

     __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

       __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;

     __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

       __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
































































#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
          
    inline void* __cdecl operator new(size_t _Size,   void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"


    
          
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma warning(pop)
#pragma pack(pop)

} // extern "C++"
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new_debug.h"


extern "C++" {

#pragma pack(push, 8)






          
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

          
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} // extern "C++"
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_new_debug.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; // file handle pointer



















//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Client-defined reporting and allocation hooks
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);











//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Memory Management and State Tracking
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

// Bit values for _crtDbgFlag flag. These bitflags control debug heap behavior.







// Some bit values for _crtDbgFlag which correspond to frequencies for checking
// the heap.




// We do not check the heap by default at this point because the cost was too
// high for some applications. You can still turn this feature on manually.







// Memory block identification







// _UNKNOWN_BLOCK is a sentinel value that may be passed to some functions that
// expect a block type as an argument.  If this value is passed, those functions
// will use the block type specified in the block header instead.  This is used
// in cases where the heap lock cannot be acquired to compute the block type
// before calling the function (e.g. when the caller is outside of the CoreCRT).


typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

        __declspec(dllimport) int*  __cdecl __p__crtDbgFlag(void);
        __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);

        
        

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    #line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);

    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

    __declspec(dllimport) int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
          void const* _Block
        );

    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Heap Routines
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+








































    












































    __declspec(dllimport) void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

    __declspec(dllimport) void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
          char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
          wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    







#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Reporting
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+













    __declspec(dllimport) int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

    __declspec(dllimport) int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);

    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

    __declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        // _CrtSetReportHook[[W]2]:
        // For IJW, we need two versions:  one for clrcall and one for cdecl.
        // For pure and native, we just need clrcall and cdecl, respectively.
        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    #line 684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Assertions and Error Reporting Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






























    

    // !! is used to ensure that any overloaded operators used to evaluate expr
    // do not end up at &&.
    
        





    #line 737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

    
        
    #line 741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

    
        
    #line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

    



    



    
    

    
    

    
    

    
    

#line 767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"

// Asserts in debug.  Invokes Watson in both debug and release









// _ASSERT_BASE is provided only for backwards compatibility.

    
#line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )












#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

// CURRENT DLL NAMES









// Visual Studio




#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"










































// B1. Inspect _HAS_ITERATOR_DEBUGGING.











#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

// B2. Inspect _SECURE_SCL.









#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

// B3. Derive _ITERATOR_DEBUG_LEVEL.






#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"



#pragma detect_mismatch("_MSC_VER", "1900")
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"










#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"



#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"





















#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"





#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"
/***
 *use_ansi.h - pragmas for ANSI Standard C++ libraries
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *Purpose:
 *       This header is intended to force the use of the appropriate ANSI
 *       Standard C++ libraries whenever it is included.
 *
 *       [Public]
 *
 ****/

#pragma once








#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"
















#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"









#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"




#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "d" "")






#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"

#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"

#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\use_ansi.h"
#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"



















#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

// Define _MRTIMP2_NPURE







#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"



#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"












#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"



#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"






#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"




#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"






#line 319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

// INTEGER PROPERTIES





// MULTITHREAD PROPERTIES
// LOCK MACROS







namespace std {
enum _Uninitialized { // tag for suppressing initialization
    _Noinit
};

// CLASS _Lockit
class __declspec(dllimport) _Lockit { // lock while object in existence -- MUST NEST
public:













#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
    __thiscall _Lockit();
    explicit __thiscall _Lockit(int); // set the lock
    __thiscall ~_Lockit() noexcept; // clear the lock
#line 362 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit*);
    static  void __cdecl _Lockit_ctor(_Lockit*, int);
    static  void __cdecl _Lockit_dtor(_Lockit*);

public:
     _Lockit(const _Lockit&) = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};








































































#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

class __declspec(dllimport) _Init_locks { // initialize mutexes
public:









#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
    __thiscall _Init_locks();
    __thiscall ~_Init_locks() noexcept;
#line 467 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks*);
    static  void __cdecl _Init_locks_dtor(_Init_locks*);
};

// EXCEPTION MACROS



















#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

#line 496 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"























#line 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
}
#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"







#pragma warning(pop)
#pragma pack(pop)
#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\yvals.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdlib"
// cstdlib standard header (core)
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\math.h"
//
// math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <math.h> header.  This header consists of two parts:
// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains
// the nonstandard but useful constant definitions.  The headers are divided in
// this way for modularity (to support the C++ modules feature).
//
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
//
// corecrt_math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The majority of the C Standard Library <math.h> functionality.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {

#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 




    // Definition of the _exception struct, which is passed to the matherr function
    // when a floating point exception is detected:
    struct _exception
    {
        int    type;   // exception type - see below
        char*  name;   // name of function where error occurred
        double arg1;   // first argument to function
        double arg2;   // second argument (if any) to function
        double retval; // value to be returned by function
    };

    // Definition of the _complex struct to be used by those who use the complex
    // functions and want type checking.
    
        

        struct _complex
        {
            double x, y; // real and imaginary parts
        };

        


#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
    #line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"



// On x86, when not using /arch:SSE2 or greater, floating point operations
// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.
// (When /fp:fast is used, floating point operations may be consistent, so
// we use the default types.)



#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"



// Constant definitions for the exception type passed in the _exception struct







// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines.

    
        extern double const _HUGE;
    

#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"


    
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"


























// Values for use as arguments to the _fperrraise function





























// IEEE 754 double properties





// IEEE 754 float properties





// IEEE 754 long double properties













void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);

// double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    double _Val;
} _double_val;

// float declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[2];
    float _Val;
} _float_val;

// long double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   // pun float types as integer array
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   // determine combined type
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   // determine combined type
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   // determine combined type
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   // determine widened real type
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   // determine widened real type
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   // determine equivalent real type
        typedef double _Type;   // default is double
    };

    template <> struct _Real_type<float>
    {   // determine equivalent real type
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   // determine equivalent real type
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   // compare _Left and _Right
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  // extern "C++"
#line 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    

          __declspec(dllimport) int  __cdecl _set_SSE2_enable(  int _Flag);

    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

    










#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"




#line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"



    










#line 621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl acosf(  float _X)
        {
            return (float)acos(_X);
        }

          __inline float __cdecl asinf(  float _X)
        {
            return (float)asin(_X);
        }

          __inline float __cdecl atan2f(  float _Y,   float _X)
        {
            return (float)atan2(_Y, _X);
        }

          __inline float __cdecl atanf(  float _X)
        {
            return (float)atan(_X);
        }

          __inline float __cdecl ceilf(  float _X)
        {
            return (float)ceil(_X);
        }

          __inline float __cdecl cosf(  float _X)
        {
            return (float)cos(_X);
        }

          __inline float __cdecl coshf(  float _X)
        {
            return (float)cosh(_X);
        }

          __inline float __cdecl expf(  float _X)
        {
            return (float)exp(_X);
        }

    #line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

    



#line 669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

    




#line 683 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl floorf(  float _X)
        {
            return (float)floor(_X);
        }

          __inline float __cdecl fmodf(  float _X,   float _Y)
        {
            return (float)fmod(_X, _Y);
        }

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    











#line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl log10f(  float _X)
        {
            return (float)log10(_X);
        }

          __inline float __cdecl logf(  float _X)
        {
            return (float)log(_X);
        }

          __inline float __cdecl modff(  float _X,   float* _Y)
        {
            double _F, _I;
            _F = modf(_X, &_I);
            *_Y = (float)_I;
            return (float)_F;
        }

          __inline float __cdecl powf(  float _X,   float _Y)
        {
            return (float)pow(_X, _Y);
        }

          __inline float __cdecl sinf(  float _X)
        {
            return (float)sin(_X);
        }

          __inline float __cdecl sinhf(  float _X)
        {
            return (float)sinh(_X);
        }

          __inline float __cdecl sqrtf(  float _X)
        {
            return (float)sqrt(_X);
        }

          __inline float __cdecl tanf(  float _X)
        {
            return (float)tan(_X);
        }

          __inline float __cdecl tanhf(  float _X)
        {
            return (float)tanh(_X);
        }

    #line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    



#line 962 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"

#line 990 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"


#pragma warning(pop)

} __pragma(pack(pop))
#line 996 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\math.h"




#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdlib"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
//
// stdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdlib.h> header.
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
//
// corecrt_malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.  These pieces of the allocation library are
// shared by both <stdlib.h> and <malloc.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    );

 
__declspec(dllimport) 
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );


















#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
//
// corecrt_search.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations of functions for sorting and searching.  These declarations are
// split out so that they may be included by both <stdlib.h> and <search.h>.
// <stdlib.h> does not include <search.h> to avoid introducing conflicts with
// other user headers named <search.h>.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
//
// stddef.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C <stddef.h> Standard Library header.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"









#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
    
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );



// Managed search routines
















































































#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
//
// corecrt_wstdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) C Standard Library functions
// that are declared by both <stdlib.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



// Maximum number of elements, including null terminator (and negative sign
// where appropriate), needed for integer-to-string conversions for several
// bases and integer types.




























     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"


__pragma(pack(push, 8)) extern "C" {




    
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



// Minimum and maximum macros





__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Exit and Abort
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Argument values for exit()




    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

// Argument values for _set_abort_behavior().



__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"


    // Non-ANSI name for compatibility
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Global State (errno, global handlers, etc.)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    // a purecall handler procedure. Never returns normally
    typedef void (__cdecl* _purecall_handler)(void);

    // Invalid parameter handler function pointer type
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    // Establishes a purecall handler
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    // Establishes an invalid parameter handler
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"












#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



// Argument values for _set_error_mode().





 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    // This is non-const for backwards compatibility; do not modify it.
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



// These point to the executable module name.
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Math
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

// These functions have declspecs in their declarations in the Windows headers,
// which cause PREfast to fire 6540.
#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)



// Maximum value that can be returned by the rand function:


__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"




// Structs used to fool the compiler into not generating floating point
// instructions when copying and pushing [long] double values




    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;

// push and pop long, which is #defined as __int64 by a spec2k test



typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow String to Number Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Number to Narrow String Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );



// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It
// should be at least as long as the number of digits in the largest double
// precision value (?.?e308 in IEEE arithmetic).  We will use the same size
// buffer as is used in the printf support routines.
//
// (This value actually allows 40 additional decimal places; even though there
// are only 16 digits of accuracy in a double precision IEEE number, the user may
// ask for more to effect zero padding.)


 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 762 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Multibyte String Operations and Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Maximum number of bytes in multi-byte character in the current locale
// (also defined in ctype.h).

    

#line 836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
        
    #line 838 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

    


        
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 934 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 953 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 962 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1041 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Path Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Sizes for buffers used by the _makepath() and _splitpath() functions.
// note that the sizes include space for 0-terminator










 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
__declspec(dllimport) errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );

#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"







    
    
#line 1181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



// Sizes for buffers used by the getenv/putenv family of functions.





      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

    


#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
          char const* _Command
        );

    // The functions below have declspecs in their declarations in the Windows
    // headers, causing PREfast to fire 6540 here
    #pragma warning (push)
    #pragma warning (disable:6540)

     
    __declspec(dllimport) int __cdecl _putenv(
          char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning (pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"

    // The Win32 API SetErrorMode, Beep and Sleep should be used instead.
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))
#line 1368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdlib"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




// <stdlib.h> has abs(long) and abs(long long)
   inline double abs(  double _Xx) noexcept {
    return :: fabs(_Xx);
}

   inline float abs(  float _Xx) noexcept {
    return :: fabsf(_Xx);
}

   inline long double abs(  long double _Xx) noexcept {
    return :: fabsl(_Xx);
}

namespace std {
using :: size_t;
using :: div_t;
using :: ldiv_t;
using :: abort;
using :: abs;
using :: atexit;
using :: atof;
using :: atoi;
using :: atol;
using :: bsearch;
using :: calloc;
using :: div;
using :: exit;
using :: free;
using :: labs;
using :: ldiv;
using :: malloc;
using :: mblen;
using :: mbstowcs;
using :: mbtowc;
using :: qsort;
using :: rand;
using :: realloc;
using :: srand;
using :: strtod;
using :: strtol;
using :: strtoul;
using :: wcstombs;
using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdlib"

using :: atoll;
using :: llabs;
using :: lldiv;
using :: strtof;
using :: strtold;
using :: strtoll;
using :: strtoull;

using :: _Exit;
using :: at_quick_exit;
using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdlib"
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdlib"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




   inline double pow(  double _Xx,   int _Yx) noexcept {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }

    return :: pow(_Xx, static_cast<double>(_Yx));
}

   inline float acos(  float _Xx) noexcept {
    return :: acosf(_Xx);
}

   inline float acosh(  float _Xx) noexcept {
    return :: acoshf(_Xx);
}

   inline float asin(  float _Xx) noexcept {
    return :: asinf(_Xx);
}

   inline float asinh(  float _Xx) noexcept {
    return :: asinhf(_Xx);
}

   inline float atan(  float _Xx) noexcept {
    return :: atanf(_Xx);
}

   inline float atanh(  float _Xx) noexcept {
    return :: atanhf(_Xx);
}

   inline float atan2(  float _Yx,   float _Xx) noexcept {
    return :: atan2f(_Yx, _Xx);
}

   inline float cbrt(  float _Xx) noexcept {
    return :: cbrtf(_Xx);
}

   inline float ceil(  float _Xx) noexcept {
    return :: ceilf(_Xx);
}

   inline float copysign(  float _Number,   float _Sign) noexcept {
    return :: copysignf(_Number, _Sign);
}

   inline float cos(  float _Xx) noexcept {
    return :: cosf(_Xx);
}

   inline float cosh(  float _Xx) noexcept {
    return :: coshf(_Xx);
}

   inline float erf(  float _Xx) noexcept {
    return :: erff(_Xx);
}

   inline float erfc(  float _Xx) noexcept {
    return :: erfcf(_Xx);
}

   inline float exp(  float _Xx) noexcept {
    return :: expf(_Xx);
}

   inline float exp2(  float _Xx) noexcept {
    return :: exp2f(_Xx);
}

   inline float expm1(  float _Xx) noexcept {
    return :: expm1f(_Xx);
}

   inline float fabs(  float _Xx) noexcept {
    return :: fabsf(_Xx);
}

   inline float fdim(  float _Xx,   float _Yx) noexcept {
    return :: fdimf(_Xx, _Yx);
}

   inline float floor(  float _Xx) noexcept {
    return :: floorf(_Xx);
}

   inline float fma(  float _Xx,   float _Yx,   float _Zx) noexcept {
    return :: fmaf(_Xx, _Yx, _Zx);
}

   inline float fmax(  float _Xx,   float _Yx) noexcept {
    return :: fmaxf(_Xx, _Yx);
}

   inline float fmin(  float _Xx,   float _Yx) noexcept {
    return :: fminf(_Xx, _Yx);
}

   inline float fmod(  float _Xx,   float _Yx) noexcept {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp(  float _Xx,   int* _Yx) noexcept {
    return :: frexpf(_Xx, _Yx);
}

   inline float hypot(  float _Xx,   float _Yx) noexcept {
    return :: hypotf(_Xx, _Yx);
}

   inline int ilogb(  float _Xx) noexcept {
    return :: ilogbf(_Xx);
}

   inline float ldexp(  float _Xx,   int _Yx) noexcept {
    return :: ldexpf(_Xx, _Yx);
}

   inline float lgamma(  float _Xx) noexcept {
    return :: lgammaf(_Xx);
}

   inline long long llrint(  float _Xx) noexcept {
    return :: llrintf(_Xx);
}

   inline long long llround(  float _Xx) noexcept {
    return :: llroundf(_Xx);
}

   inline float log(  float _Xx) noexcept {
    return :: logf(_Xx);
}

   inline float log10(  float _Xx) noexcept {
    return :: log10f(_Xx);
}

   inline float log1p(  float _Xx) noexcept {
    return :: log1pf(_Xx);
}

   inline float log2(  float _Xx) noexcept {
    return :: log2f(_Xx);
}

   inline float logb(  float _Xx) noexcept {
    return :: logbf(_Xx);
}

   inline long lrint(  float _Xx) noexcept {
    return :: lrintf(_Xx);
}

   inline long lround(  float _Xx) noexcept {
    return :: lroundf(_Xx);
}

inline float modf(  float _Xx,   float* _Yx) noexcept {
    return :: modff(_Xx, _Yx);
}

   inline float nearbyint(  float _Xx) noexcept {
    return :: nearbyintf(_Xx);
}

   inline float nextafter(  float _Xx,   float _Yx) noexcept {
    return :: nextafterf(_Xx, _Yx);
}

   inline float nexttoward(  float _Xx,   long double _Yx) noexcept {
    return :: nexttowardf(_Xx, _Yx);
}

   inline float pow(  float _Xx,   float _Yx) noexcept {
    return :: powf(_Xx, _Yx);
}

   inline float pow(  float _Xx,   int _Yx) noexcept {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }

    return :: powf(_Xx, static_cast<float>(_Yx));
}

   inline float remainder(  float _Xx,   float _Yx) noexcept {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo(  float _Xx,   float _Yx,   int* _Zx) noexcept {
    return :: remquof(_Xx, _Yx, _Zx);
}

   inline float rint(  float _Xx) noexcept {
    return :: rintf(_Xx);
}

   inline float round(  float _Xx) noexcept {
    return :: roundf(_Xx);
}

   inline float scalbln(  float _Xx,   long _Yx) noexcept {
    return :: scalblnf(_Xx, _Yx);
}

   inline float scalbn(  float _Xx,   int _Yx) noexcept {
    return :: scalbnf(_Xx, _Yx);
}

   inline float sin(  float _Xx) noexcept {
    return :: sinf(_Xx);
}

   inline float sinh(  float _Xx) noexcept {
    return :: sinhf(_Xx);
}

   inline float sqrt(  float _Xx) noexcept {
    return :: sqrtf(_Xx);
}

   inline float tan(  float _Xx) noexcept {
    return :: tanf(_Xx);
}

   inline float tanh(  float _Xx) noexcept {
    return :: tanhf(_Xx);
}

   inline float tgamma(  float _Xx) noexcept {
    return :: tgammaf(_Xx);
}

   inline float trunc(  float _Xx) noexcept {
    return :: truncf(_Xx);
}

   inline long double acos(  long double _Xx) noexcept {
    return :: acosl(_Xx);
}

   inline long double acosh(  long double _Xx) noexcept {
    return :: acoshl(_Xx);
}

   inline long double asin(  long double _Xx) noexcept {
    return :: asinl(_Xx);
}

   inline long double asinh(  long double _Xx) noexcept {
    return :: asinhl(_Xx);
}

   inline long double atan(  long double _Xx) noexcept {
    return :: atanl(_Xx);
}

   inline long double atanh(  long double _Xx) noexcept {
    return :: atanhl(_Xx);
}

   inline long double atan2(  long double _Yx,   long double _Xx) noexcept {
    return :: atan2l(_Yx, _Xx);
}

   inline long double cbrt(  long double _Xx) noexcept {
    return :: cbrtl(_Xx);
}

   inline long double ceil(  long double _Xx) noexcept {
    return :: ceill(_Xx);
}

   inline long double copysign(  long double _Number,   long double _Sign) noexcept {
    return :: copysignl(_Number, _Sign);
}

   inline long double cos(  long double _Xx) noexcept {
    return :: cosl(_Xx);
}

   inline long double cosh(  long double _Xx) noexcept {
    return :: coshl(_Xx);
}

   inline long double erf(  long double _Xx) noexcept {
    return :: erfl(_Xx);
}

   inline long double erfc(  long double _Xx) noexcept {
    return :: erfcl(_Xx);
}

   inline long double exp(  long double _Xx) noexcept {
    return :: expl(_Xx);
}

   inline long double exp2(  long double _Xx) noexcept {
    return :: exp2l(_Xx);
}

   inline long double expm1(  long double _Xx) noexcept {
    return :: expm1l(_Xx);
}

   inline long double fabs(  long double _Xx) noexcept {
    return :: fabsl(_Xx);
}

   inline long double fdim(  long double _Xx,   long double _Yx) noexcept {
    return :: fdiml(_Xx, _Yx);
}

   inline long double floor(  long double _Xx) noexcept {
    return :: floorl(_Xx);
}

   inline long double fma(
      long double _Xx,   long double _Yx,   long double _Zx) noexcept {
    return :: fmal(_Xx, _Yx, _Zx);
}

   inline long double fmax(  long double _Xx,   long double _Yx) noexcept {
    return :: fmaxl(_Xx, _Yx);
}

   inline long double fmin(  long double _Xx,   long double _Yx) noexcept {
    return :: fminl(_Xx, _Yx);
}

   inline long double fmod(  long double _Xx,   long double _Yx) noexcept {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp(  long double _Xx,   int* _Yx) noexcept {
    return :: frexpl(_Xx, _Yx);
}

   inline long double hypot(  long double _Xx,   long double _Yx) noexcept {
    return :: hypotl(_Xx, _Yx);
}

   inline int ilogb(  long double _Xx) noexcept {
    return :: ilogbl(_Xx);
}

   inline long double ldexp(  long double _Xx,   int _Yx) noexcept {
    return :: ldexpl(_Xx, _Yx);
}

   inline long double lgamma(  long double _Xx) noexcept {
    return :: lgammal(_Xx);
}

   inline long long llrint(  long double _Xx) noexcept {
    return :: llrintl(_Xx);
}

   inline long long llround(  long double _Xx) noexcept {
    return :: llroundl(_Xx);
}

   inline long double log(  long double _Xx) noexcept {
    return :: logl(_Xx);
}

   inline long double log10(  long double _Xx) noexcept {
    return :: log10l(_Xx);
}

   inline long double log1p(  long double _Xx) noexcept {
    return :: log1pl(_Xx);
}

   inline long double log2(  long double _Xx) noexcept {
    return :: log2l(_Xx);
}

   inline long double logb(  long double _Xx) noexcept {
    return :: logbl(_Xx);
}

   inline long lrint(  long double _Xx) noexcept {
    return :: lrintl(_Xx);
}

   inline long lround(  long double _Xx) noexcept {
    return :: lroundl(_Xx);
}

inline long double modf(  long double _Xx,   long double* _Yx) noexcept {
    return :: modfl(_Xx, _Yx);
}

   inline long double nearbyint(  long double _Xx) noexcept {
    return :: nearbyintl(_Xx);
}

   inline long double nextafter(  long double _Xx,   long double _Yx) noexcept {
    return :: nextafterl(_Xx, _Yx);
}

   inline long double nexttoward(  long double _Xx,   long double _Yx) noexcept {
    return :: nexttowardl(_Xx, _Yx);
}

   inline long double pow(  long double _Xx,   long double _Yx) noexcept {
    return :: powl(_Xx, _Yx);
}

   inline long double pow(  long double _Xx,   int _Yx) noexcept {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }

    return :: powl(_Xx, static_cast<long double>(_Yx));
}

   inline long double remainder(  long double _Xx,   long double _Yx) noexcept {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo(  long double _Xx,   long double _Yx,   int* _Zx) noexcept {
    return :: remquol(_Xx, _Yx, _Zx);
}

   inline long double rint(  long double _Xx) noexcept {
    return :: rintl(_Xx);
}

   inline long double round(  long double _Xx) noexcept {
    return :: roundl(_Xx);
}

   inline long double scalbln(  long double _Xx,   long _Yx) noexcept {
    return :: scalblnl(_Xx, _Yx);
}

   inline long double scalbn(  long double _Xx,   int _Yx) noexcept {
    return :: scalbnl(_Xx, _Yx);
}

   inline long double sin(  long double _Xx) noexcept {
    return :: sinl(_Xx);
}

   inline long double sinh(  long double _Xx) noexcept {
    return :: sinhl(_Xx);
}

   inline long double sqrt(  long double _Xx) noexcept {
    return :: sqrtl(_Xx);
}

   inline long double tan(  long double _Xx) noexcept {
    return :: tanl(_Xx);
}

   inline long double tanh(  long double _Xx) noexcept {
    return :: tanhl(_Xx);
}

   inline long double tgamma(  long double _Xx) noexcept {
    return :: tgammal(_Xx);
}

   inline long double trunc(  long double _Xx) noexcept {
    return :: truncl(_Xx);
}

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"
// xtgmath.h internal header


#pragma once






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtr1common"
// xtr1common internal header (core)
#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// STRUCT TEMPLATE integral_constant
template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

     constexpr value_type operator()() const noexcept {
        return value;
    }
};

// ALIAS TEMPLATE bool_constant
template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;

// STRUCT TEMPLATE enable_if
template <bool _Test, class _Ty = void>
struct enable_if {}; // no member "type" when !_Test

template <class _Ty>
struct enable_if<true, _Ty> { // type is _Ty for _Test
    using type = _Ty;
};

template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

// STRUCT TEMPLATE conditional
template <bool _Test, class _Ty1, class _Ty2>
struct conditional { // Choose _Ty1 if _Test is true, and _Ty2 otherwise
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

// STRUCT TEMPLATE is_same







template <class, class>
 constexpr bool is_same_v = false; // determine whether arguments are the same type
template <class _Ty>
 constexpr bool is_same_v<_Ty, _Ty> = true;

template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtr1common"

// STRUCT TEMPLATE remove_const
template <class _Ty>
struct remove_const { // remove top-level const qualifier
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

// STRUCT TEMPLATE remove_volatile
template <class _Ty>
struct remove_volatile { // remove top-level volatile qualifier
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

// STRUCT TEMPLATE remove_cv
template <class _Ty>
struct remove_cv { // remove top-level const and volatile qualifiers
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; // apply cv-qualifiers from the class template argument to _Fn<_Ty>
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

// STRUCT TEMPLATE disjunction
template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { // handle true trait or last trait
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { // first trait is false, try the next trait
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct disjunction : false_type {}; // If _Traits is empty, false_type

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    // the first true trait in _Traits, or the last trait if none are true
};

template <class... _Traits>
 constexpr bool disjunction_v = disjunction<_Traits...>::value;

// VARIABLE TEMPLATE _Is_any_of_v
template <class _Ty, class... _Types>
 constexpr bool _Is_any_of_v = // true if and only if _Ty is in _Types
    disjunction_v<is_same<_Ty, _Types>...>;

// STRUCT TEMPLATE is_integral
template <class _Ty>
 constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,


#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtr1common"
    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

// STRUCT TEMPLATE is_floating_point
template <class _Ty>
 constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

// STRUCT TEMPLATE is_arithmetic
template <class _Ty>
 constexpr bool is_arithmetic_v = // determine whether _Ty is an arithmetic type
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

// STRUCT TEMPLATE remove_reference
template <class _Ty>
struct remove_reference {
    using type = _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type = _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type = _Ty;
};

template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;









#line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtr1common"

}


#pragma warning(pop)
#pragma pack(pop)
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtr1common"
#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtr1common"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; // find type for two-argument math function
}
























template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>
 ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right) noexcept { // strengthened
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    return :: pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}

// _GENERIC_MATH1(abs) // has integer overloads
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double ceil(_Ty _Left) noexcept { return :: ceil(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double floor(_Ty _Left) noexcept { return :: floor(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }

template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>
double frexp(_Ty _Value,   int* const _Exp) noexcept { // strengthened
    return :: frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double ldexp(_Ty _Left,   int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
// _GENERIC_MATH1_DISCARD(modf) // types must match
// _GENERIC_MATH2(pow) // hand crafted
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }

// C99 MATH FUNCTIONS

// FUNCTION TEMPLATE fma












#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"

template <class _Ty1, class _Ty2, class _Ty3,
    class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>>>
 ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept { // strengthened
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;

    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }


#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"
}

// FUNCTION TEMPLATE remquo












#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"

template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept { // strengthened
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;

    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }


#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"
}

template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
// _GENERIC_MATH3(fma) // hand crafted
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double nexttoward(_Ty _Left,   long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
// _GENERIC_MATH2X_DISCARD(remquo) // hand crafted
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double round(_Ty _Left) noexcept { return :: round(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double scalbln(_Ty _Left,   long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double scalbn(_Ty _Left,   int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  double trunc(_Ty _Left) noexcept { return :: trunc(static_cast<double>(_Left)); }








#pragma warning(pop)
#pragma pack(pop)
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"
#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xtgmath.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 491 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"

namespace std {
using :: abs;
using :: acos;
using :: asin;
using :: atan;
using :: atan2;
using :: ceil;
using :: cos;
using :: cosh;
using :: exp;
using :: fabs;
using :: floor;
using :: fmod;
using :: frexp;
using :: ldexp;
using :: log;
using :: log10;
using :: modf;
using :: pow;
using :: sin;
using :: sinh;
using :: sqrt;
using :: tan;
using :: tanh;

using :: acosf;
using :: asinf;
using :: atanf;
using :: atan2f;
using :: ceilf;
using :: cosf;
using :: coshf;
using :: expf;
using :: fabsf;
using :: floorf;
using :: fmodf;
using :: frexpf;
using :: ldexpf;
using :: logf;
using :: log10f;
using :: modff;
using :: powf;
using :: sinf;
using :: sinhf;
using :: sqrtf;
using :: tanf;
using :: tanhf;

using :: acosl;
using :: asinl;
using :: atanl;
using :: atan2l;
using :: ceill;
using :: cosl;
using :: coshl;
using :: expl;
using :: fabsl;
using :: floorl;
using :: fmodl;
using :: frexpl;
using :: ldexpl;
using :: logl;
using :: log10l;
using :: modfl;
using :: powl;
using :: sinl;
using :: sinhl;
using :: sqrtl;
using :: tanl;
using :: tanhl;

using :: float_t;
using :: double_t;

using :: acosh;
using :: asinh;
using :: atanh;
using :: cbrt;
using :: erf;
using :: erfc;
using :: expm1;
using :: exp2;
using :: hypot;
using :: ilogb;
using :: lgamma;
using :: log1p;
using :: log2;
using :: logb;
using :: llrint;
using :: lrint;
using :: nearbyint;
using :: rint;
using :: llround;
using :: lround;
using :: fdim;
using :: fma;
using :: fmax;
using :: fmin;
using :: round;
using :: trunc;
using :: remainder;
using :: remquo;
using :: copysign;
using :: nan;
using :: nextafter;
using :: scalbn;
using :: scalbln;
using :: nexttoward;
using :: tgamma;

using :: acoshf;
using :: asinhf;
using :: atanhf;
using :: cbrtf;
using :: erff;
using :: erfcf;
using :: expm1f;
using :: exp2f;
using :: hypotf;
using :: ilogbf;
using :: lgammaf;
using :: log1pf;
using :: log2f;
using :: logbf;
using :: llrintf;
using :: lrintf;
using :: nearbyintf;
using :: rintf;
using :: llroundf;
using :: lroundf;
using :: fdimf;
using :: fmaf;
using :: fmaxf;
using :: fminf;
using :: roundf;
using :: truncf;
using :: remainderf;
using :: remquof;
using :: copysignf;
using :: nanf;
using :: nextafterf;
using :: scalbnf;
using :: scalblnf;
using :: nexttowardf;
using :: tgammaf;

using :: acoshl;
using :: asinhl;
using :: atanhl;
using :: cbrtl;
using :: erfl;
using :: erfcl;
using :: expm1l;
using :: exp2l;
using :: hypotl;
using :: ilogbl;
using :: lgammal;
using :: log1pl;
using :: log2l;
using :: logbl;
using :: llrintl;
using :: lrintl;
using :: nearbyintl;
using :: rintl;
using :: llroundl;
using :: lroundl;
using :: fdiml;
using :: fmal;
using :: fmaxl;
using :: fminl;
using :: roundl;
using :: truncl;
using :: remainderl;
using :: remquol;
using :: copysignl;
using :: nanl;
using :: nextafterl;
using :: scalbnl;
using :: scalblnl;
using :: nexttowardl;
using :: tgammal;

using :: fpclassify;
using :: signbit;
using :: isfinite;
using :: isinf;
using :: isnan;
using :: isnormal;
using :: isgreater;
using :: isgreaterequal;
using :: isless;
using :: islessequal;
using :: islessgreater;
using :: isunordered;
}
















































































































































































































































































































































































































































































































































#line 1216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1223 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"
#line 1224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cmath"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdio"
// cstdio standard header (core)
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
//
// stdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdio.h> header.
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
//
// corecrt_wstdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are
// also shared by those two headers.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
//
// corecrt_stdio_config.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Per-module <stdio.h> configuration.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"




#line 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
    
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"


    
        
    



#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"



// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does
// not use these format specifiers without a length modifier and thus can be
// used with either the legacy (default) or the conforming mode.  (This option
// is intended for use by static libraries).

    








#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"




#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
    #line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"

// If we're compiling mixed managed code, make sure these inline functions are
// compiled as native to ensure that there is only one instance of each of the
// function-local static variables.


#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"


    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"



#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"



















} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

__pragma(pack(push, 8)) extern "C" {


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Stream I/O Declarations Required by this Header
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"



    // Variadic functions are not supported in managed code under /clr
    





    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
        



    

#line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4793)

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    // Warning 4793: The compiler cannot compile function into managed code, even though the /clr compiler option is specified.
    // Warning 4996: 'function': was declared deprecated
    #pragma warning(disable:4793 4996)

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1504 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 1549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1557 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    




#line 1884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 2016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2036 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"

    


#line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

__pragma(pack(push, 8)) extern "C" {

/* Buffered I/O macros */





/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */




/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */












    
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"



/* Seek method constants */











    
    
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    #line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(pop)

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    














#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"



    // Variadic functions are not supported in managed code under /clr
    

#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 763 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1062 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1099 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    








#line 1427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1619 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1666 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #pragma warning(pop)

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 1852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1900 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    








#line 1937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 2020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2029 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #line 2325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable:6530)

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Non-ANSI Names for Compatibility
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        

        


#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2455 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 2468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"



} __pragma(pack(pop))
#line 2473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdio"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




// undef common macro overrides








// TRANSITION: Boost nonconformingly uses this macro


namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: FILE;
using :: _Mbstatet;

using :: size_t;
using :: fpos_t;
using :: FILE;
using :: clearerr;
using :: fclose;
using :: feof;
using :: ferror;
using :: fflush;
using :: fgetc;
using :: fgetpos;
using :: fgets;
using :: fopen;
using :: fprintf;
using :: fputc;
using :: fputs;
using :: fread;
using :: freopen;
using :: fscanf;
using :: fseek;
using :: fsetpos;
using :: ftell;
using :: fwrite;
using :: getc;
using :: getchar;
using :: perror;
using :: putc;
using :: putchar;
using :: printf;
using :: puts;
using :: remove;
using :: rename;
using :: rewind;
using :: scanf;
using :: setbuf;
using :: setvbuf;
using :: sprintf;
using :: sscanf;
using :: tmpfile;
using :: tmpnam;
using :: ungetc;
using :: vfprintf;
using :: vprintf;
using :: vsprintf;

using :: snprintf;
using :: vsnprintf;
using :: vfscanf;
using :: vscanf;
using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdio"
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdio"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"
// streambuf standard header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"
// xiosbase internal header (from <ios>)
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\share.h"
//
// share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.
//
#pragma once



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_share.h"
//
// corecrt_share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.  These
// declarations are split out to support the Windows build.
//
#pragma once












    
    
    
    
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_share.h"
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\share.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\share.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"
// system_error standard header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cerrno"
// cerrno standard header
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
//
// errno.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// System error numbers for use with errno and errno_t.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"



// Error codes




































// Error codes used in the Secure CRT functions

    
    
    
    
    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"

// Support EDEADLOCK for compatibility with older Microsoft C versions


// POSIX Supplement

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cerrno"

#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cerrno"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cerrno"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
// stdexcept standard header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"
// exception standard header
#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
// type_traits standard header (core)
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"
// xstddef internal header (core)
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstddef"
// cstddef standard header (core)
#pragma once








#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
using :: ptrdiff_t;
using :: size_t;
using max_align_t = double; // most aligned type

































































#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstddef"

}

using ::std:: max_align_t; // intentional, for historical reasons



#pragma warning(pop)
#pragma pack(pop)

#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstddef"
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstddef"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\initializer_list"
// initializer_list standard header (core)
#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// CLASS TEMPLATE initializer_list
template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

     constexpr const _Elem* begin() const noexcept {
        return _First;
    }

     constexpr const _Elem* end() const noexcept {
        return _Last;
    }

     constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

// FUNCTION TEMPLATE begin
template <class _Elem>
 constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

// FUNCTION TEMPLATE end
template <class _Elem>
 constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\initializer_list"
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\initializer_list"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// TYPE DEFINITIONS
template <class>
// false value attached to a dependent name (for static_assert)
 constexpr bool _Always_false = false;

// FUNCTIONAL STUFF (from <functional>)

// STRUCT TEMPLATE unary_function
template <class _Arg, class _Result>
struct unary_function { // base class for unary functions
    using argument_type = _Arg;
    using result_type   = _Result;
};

// STRUCT TEMPLATE binary_function
template <class _Arg1, class _Arg2, class _Result>
struct binary_function { // base class for binary functions
    using first_argument_type  = _Arg1;
    using second_argument_type = _Arg2;
    using result_type          = _Result;
};
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"

// STRUCT TEMPLATE plus
template <class _Ty = void>
struct plus { // functor for operator+
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator+ to operands
        return _Left + _Right;
    }
};

// STRUCT TEMPLATE minus
template <class _Ty = void>
struct minus { // functor for operator-
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator- to operands
        return _Left - _Right;
    }
};

// STRUCT TEMPLATE multiplies
template <class _Ty = void>
struct multiplies { // functor for operator*
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator* to operands
        return _Left * _Right;
    }
};

// STRUCT TEMPLATE equal_to
template <class _Ty = void>
struct equal_to { // functor for operator==
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator== to operands
        return _Left == _Right;
    }
};

// STRUCT TEMPLATE not_equal_to
template <class _Ty = void>
struct not_equal_to { // functor for operator!=
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator!= to operands
        return _Left != _Right;
    }
};

// STRUCT TEMPLATE greater
template <class _Ty = void>
struct greater { // functor for operator>
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator> to operands
        return _Left > _Right;
    }
};

// STRUCT TEMPLATE less
template <class _Ty = void>
struct less { // functor for operator<
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator< to operands
        return _Left < _Right;
    }
};

// STRUCT TEMPLATE greater_equal
template <class _Ty = void>
struct greater_equal { // functor for operator>=
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator>= to operands
        return _Left >= _Right;
    }
};

// STRUCT TEMPLATE less_equal
template <class _Ty = void>
struct less_equal { // functor for operator<=
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { // apply operator<= to operands
        return _Left <= _Right;
    }
};

// STRUCT TEMPLATE SPECIALIZATION plus
template <>
struct plus<void> { // transparent functor for operator+
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) { // transparently apply operator+ to operands
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION minus
template <>
struct minus<void> { // transparent functor for operator-
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) { // transparently apply operator- to operands
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION multiplies
template <>
struct multiplies<void> { // transparent functor for operator*
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) { // transparently apply operator* to operands
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION equal_to
template <>
struct equal_to<void> { // transparent functor for operator==
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) { // transparently apply operator== to operands
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION not_equal_to
template <>
struct not_equal_to<void> { // transparent functor for operator!=
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) { // transparently apply operator!= to operands
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION greater
template <>
struct greater<void> { // transparent functor for operator>
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) { // transparently apply operator> to operands
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION less
template <>
struct less<void> { // transparent functor for operator<
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) { // transparently apply operator< to operands
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION greater_equal
template <>
struct greater_equal<void> { // transparent functor for operator>=
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) { // transparently apply operator>= to operands
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION less_equal
template <>
struct less_equal<void> { // transparent functor for operator<=
    using is_transparent = int;

    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(
            static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) { // transparently apply operator<= to operands
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }
};

// FUNCTION TEMPLATE addressof
template <class _Ty>
 constexpr _Ty* addressof(_Ty& _Val) noexcept { // return address of _Val
    return __builtin_addressof(_Val);
}

template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

// FUNCTION TEMPLATE _Unfancy
template <class _Ptrty>
auto _Unfancy(_Ptrty _Ptr) { // converts from a fancy pointer to a plain pointer
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
_Ty* _Unfancy(_Ty* _Ptr) { // do nothing for plain pointers
    return _Ptr;
}
}








#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"






#line 313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"








#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"






#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"

























#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"


























#line 382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"













































#line 428 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"



#pragma warning(pop)
#pragma pack(pop)
#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"
#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstddef"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




#pragma warning(disable : 4180) 

namespace std {
// STRUCT TEMPLATE integer_sequence
template <class _Ty, _Ty... _Vals>
struct integer_sequence { // sequence of integer parameters
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

     static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

// ALIAS TEMPLATE make_integer_sequence
template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

// STRUCT TEMPLATE conjunction
template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { // handle false trait or last trait
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { // the first trait is true, try the next one
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct conjunction : true_type {}; // If _Traits is empty, true_type

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    // the first false trait in _Traits, or the last trait if none are false
};

template <class... _Traits>
 constexpr bool conjunction_v = conjunction<_Traits...>::value;

// STRUCT TEMPLATE negation
template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; // The negated result of _Trait

template <class _Trait>
 constexpr bool negation_v = negation<_Trait>::value;




#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE _Arg_types
template <class... _Types>
struct _Arg_types {}; // provide argument_type, etc. (sometimes)

template <class _Ty1>
struct _Arg_types<_Ty1> {
     typedef _Ty1 argument_type;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
     typedef _Ty1 first_argument_type;
     typedef _Ty2 second_argument_type;
};

// STRUCT TEMPLATE is_function
template <class _Ty>
struct _Is_function { // determine whether _Ty is a function
    using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
};








template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };  template <class _Ret, class... _Types> struct _Is_function<_Ret __fastcall(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __stdcall(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };









template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; };


template <class _Ty>
struct is_function : bool_constant<_Is_function<_Ty>::_Bool_type::value> {}; // determine whether _Ty is a function

template <class _Ty>
 constexpr bool is_function_v = _Is_function<_Ty>::_Bool_type::value;


template <class _Ty>
struct _Is_memfunptr { // base class for member function pointer predicates
    using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };  template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };


// STRUCT TEMPLATE is_void
template <class _Ty>
 constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

// ALIAS TEMPLATE void_t
template <class... _Types>
using void_t = void;

// Type modifiers
// STRUCT TEMPLATE add_const
template <class _Ty>
struct add_const { // add top-level const qualifier
    using type = const _Ty;
};

template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

// STRUCT TEMPLATE add_volatile
template <class _Ty>
struct add_volatile { // add top-level volatile qualifier
    using type = volatile _Ty;
};

template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

// STRUCT TEMPLATE add_cv
template <class _Ty>
struct add_cv { // add top-level const and volatile qualifiers
    using type = const volatile _Ty;
};

template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

// STRUCT TEMPLATE _Add_reference
template <class _Ty, class = void>
struct _Add_reference { // add reference (non-referenceable type)
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { // (referenceable type)
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

// STRUCT TEMPLATE add_lvalue_reference
template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

// STRUCT TEMPLATE add_rvalue_reference
template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

// FUNCTION TEMPLATE declval
template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept;

// STRUCT TEMPLATE remove_extent
template <class _Ty>
struct remove_extent { // remove array extent
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

// STRUCT TEMPLATE remove_all_extents
template <class _Ty>
struct remove_all_extents { // remove all array extents
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

// STRUCT TEMPLATE remove_pointer
template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};


template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

// STRUCT TEMPLATE add_pointer
template <class _Ty, class = void>
struct _Add_pointer { // add pointer (pointer type cannot be formed)
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { // (pointer type can be formed)
    using type = remove_reference_t<_Ty>*;
};

template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

// TYPE PREDICATES
// STRUCT TEMPLATE is_array
template <class>
 constexpr bool is_array_v = false; // determine whether type argument is an array

template <class _Ty, size_t _Nx>
 constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
 constexpr bool is_array_v<_Ty[]> = true;

template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};

// STRUCT TEMPLATE is_lvalue_reference
template <class>
 constexpr bool is_lvalue_reference_v = false; // determine whether type argument is an lvalue reference

template <class _Ty>
 constexpr bool is_lvalue_reference_v<_Ty&> = true;

template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

// STRUCT TEMPLATE is_rvalue_reference
template <class>
 constexpr bool is_rvalue_reference_v = false; // determine whether type argument is an rvalue reference

template <class _Ty>
 constexpr bool is_rvalue_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

// STRUCT TEMPLATE is_reference
template <class>
 constexpr bool is_reference_v = false; // determine whether type argument is a reference

template <class _Ty>
 constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
 constexpr bool is_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

// STRUCT TEMPLATE is_member_object_pointer
template <class _Ty, bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
struct _Is_member_object_pointer { // determine whether _Ty is a pointer to member object
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*, false> {
    static constexpr bool value = true;
    using _Class_type           = _Ty2;
};

template <class _Ty>
 constexpr bool is_member_object_pointer_v = // determine whether _Ty is a pointer to member object
    _Is_member_object_pointer<remove_cv_t<_Ty>>::value;

template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};

// STRUCT TEMPLATE is_member_function_pointer
template <class _Ty>
 constexpr bool is_member_function_pointer_v = // determine whether _Ty is a pointer to member function
    _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;

template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

// STRUCT TEMPLATE is_pointer
template <class>
 constexpr bool is_pointer_v = false; // determine whether _Ty is a pointer

template <class _Ty>
 constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const volatile> = true;

template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

// STRUCT TEMPLATE is_null_pointer
template <class _Ty>
 constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; // determine whether _Ty is cv-qualified nullptr_t

template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

// STRUCT TEMPLATE is_union
template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; // determine whether _Ty is a union

template <class _Ty>
 constexpr bool is_union_v = __is_union(_Ty);

// STRUCT TEMPLATE is_class
template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; // determine whether _Ty is a class

template <class _Ty>
 constexpr bool is_class_v = __is_class(_Ty);

// STRUCT TEMPLATE is_fundamental
template <class _Ty>
 constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; // determine whether _Ty is a fundamental type

// STRUCT TEMPLATE is_object
template <class _Ty>
 constexpr bool is_object_v = !is_function_v<_Ty> && !is_reference_v<_Ty> && !is_void_v<_Ty>;

template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {}; // determine whether _Ty is an object type

// STRUCT TEMPLATE is_convertible
template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    // determine whether _From is convertible to _To
};

template <class _From, class _To>
 constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

// STRUCT TEMPLATE is_enum
template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; // determine whether _Ty is an enumerated type

template <class _Ty>
 constexpr bool is_enum_v = __is_enum(_Ty);

// STRUCT TEMPLATE is_compound
template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; // determine whether _Ty is a compound type

template <class _Ty>
 constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

// STRUCT TEMPLATE is_member_pointer
template <class _Ty>
 constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;

template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; // determine whether _Ty is a pointer to member

// STRUCT TEMPLATE is_scalar
template <class _Ty>
 constexpr bool is_scalar_v = // determine whether _Ty is a scalar type
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

// STRUCT TEMPLATE is_const
template <class>
 constexpr bool is_const_v = false; // determine whether type argument is const qualified

template <class _Ty>
 constexpr bool is_const_v<const _Ty> = true;

template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

// STRUCT TEMPLATE is_volatile
template <class>
 constexpr bool is_volatile_v = false; // determine whether type argument is volatile qualified

template <class _Ty>
 constexpr bool is_volatile_v<volatile _Ty> = true;

template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

// STRUCT TEMPLATE is_pod
template <class _Ty>
struct is_pod : bool_constant<__is_pod(_Ty)> {}; // determine whether _Ty is a POD type

template <class _Ty>
 constexpr bool is_pod_v = __is_pod(_Ty);

// STRUCT TEMPLATE is_empty
template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; // determine whether _Ty is an empty class

template <class _Ty>
 constexpr bool is_empty_v = __is_empty(_Ty);

// STRUCT TEMPLATE is_polymorphic
template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; // determine whether _Ty is a polymorphic type

template <class _Ty>
 constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

// STRUCT TEMPLATE is_abstract
template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; // determine whether _Ty is an abstract class

template <class _Ty>
 constexpr bool is_abstract_v = __is_abstract(_Ty);

// STRUCT TEMPLATE is_final
template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; // determine whether _Ty is a final class

template <class _Ty>
 constexpr bool is_final_v = __is_final(_Ty);

// STRUCT TEMPLATE is_standard_layout
template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; // determine whether _Ty is standard layout

template <class _Ty>
 constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);

// STRUCT TEMPLATE is_literal_type
template <class _Ty>
struct  is_literal_type : bool_constant<__is_literal_type(_Ty)> {
    // determine whether _Ty is a literal type
};

template <class _Ty>
  constexpr bool is_literal_type_v = __is_literal_type(_Ty);

// STRUCT TEMPLATE is_trivial

template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    // determine whether _Ty is a trivial type
};

template <class _Ty>
 constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 572 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE is_trivially_copyable
template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    // determine whether _Ty is a trivially copyable type
};

template <class _Ty>
 constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

// STRUCT TEMPLATE has_virtual_destructor
template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    // determine whether _Ty has a virtual destructor
};

template <class _Ty>
 constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);

















#line 608 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// CONSTRUCTIBLE/ASSIGNABLE TRAITS
// STRUCT TEMPLATE is_constructible
template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    // determine whether _Ty can be direct-initialized with _Args...
};

template <class _Ty, class... _Args>
 constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_copy_constructible
template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    // determine whether _Ty can be direct-initialized with an lvalue const _Ty
};

template <class _Ty>
 constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

// STRUCT TEMPLATE is_default_constructible
template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    // determine whether _Ty can be value-initialized
};

template <class _Ty>
 constexpr bool is_default_constructible_v = __is_constructible(_Ty);

// STRUCT TEMPLATE _Is_implicitly_default_constructible
template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    // determine whether _Ty can be copy-initialized with {}
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

// STRUCT TEMPLATE is_move_constructible
template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    // determine whether _Ty can be direct-initialized from an rvalue _Ty
};

template <class _Ty>
 constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_assignable
template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; // determine whether _From can be assigned to _To

template <class _To, class _From>
 constexpr bool is_assignable_v = __is_assignable(_To, _From);

// STRUCT TEMPLATE is_copy_assignable
template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    // determine whether an lvalue const _Ty can be assigned to an lvalue _Ty
};

template <class _Ty>
 constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
 constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE is_move_assignable
template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    // determine whether an rvalue _Ty can be assigned to an lvalue _Ty
};

template <class _Ty>
 constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
 constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, _Ty);






#line 718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE is_destructible
template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    // true iff remove_all_extents_t<_Ty> is a reference type, or can be explicitly destroyed
};

template <class _Ty>
 constexpr bool is_destructible_v = __is_destructible(_Ty);

// TRIVIAL TRAITS
// STRUCT TEMPLATE is_trivially_constructible
template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    // determine whether direct-initialization of _Ty with _Args... is trivial
};

template <class _Ty, class... _Args>
 constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_trivially_copy_constructible
template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    // determine whether direct-initialization of _Ty with an lvalue const _Ty is trivial
};

template <class _Ty>
 constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);

// STRUCT TEMPLATE is_trivially_default_constructible
template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    // determine whether value-initialization of _Ty is trivial
};

template <class _Ty>
 constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

// STRUCT TEMPLATE is_trivially_move_constructible
template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    // determine whether direct-initialization of _Ty with an rvalue _Ty is trivial
};

template <class _Ty>
 constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_trivially_assignable
template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    // determine whether _From can be trivially assigned to _To
};

template <class _To, class _From>
 constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

// STRUCT TEMPLATE is_trivially_copy_assignable
template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    // determine whether an lvalue const _Ty can be trivially assigned to an lvalue _Ty
};

template <class _Ty>
 constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

// STRUCT TEMPLATE is_trivially_move_assignable
template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    // determine whether an rvalue _Ty can be trivially assigned to an lvalue _Ty
};

template <class _Ty>
 constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

// STRUCT TEMPLATE is_trivially_destructible
template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    // determine whether remove_all_extents_t<_Ty> is a reference type or can trivially be explicitly destroyed
};

template <class _Ty>
 constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

// NOTHROW TRAITS
// STRUCT TEMPLATE is_nothrow_constructible
template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    // determine whether direct-initialization of _Ty from _Args... is both valid and not potentially-throwing
};

template <class _Ty, class... _Args>
 constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_nothrow_copy_constructible
template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    // determine whether direct-initialization of _Ty from an lvalue const _Ty is both valid
    // and not potentially-throwing
};

template <class _Ty>
 constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);

// STRUCT TEMPLATE is_nothrow_default_constructible
template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    // determine whether value-initialization of _Ty is both valid and not potentially-throwing
};

template <class _Ty>
 constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

// STRUCT TEMPLATE is_nothrow_move_constructible
template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    // determine whether direct-initialization of _Ty from an rvalue _Ty is both valid and not potentially-throwing
};

template <class _Ty>
 constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_nothrow_assignable
template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    // determine whether assignment of _From to _To is both valid and not potentially-throwing
};

template <class _To, class _From>
 constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

// STRUCT TEMPLATE is_nothrow_copy_assignable
template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    // determine whether assignment of an lvalue const _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

template <class _Ty>
 constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

// STRUCT TEMPLATE is_nothrow_move_assignable
template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    // determine whether assignment of an rvalue _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

template <class _Ty>
 constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

// STRUCT TEMPLATE is_nothrow_destructible
template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    // determine whether remove_all_extents_t<_Ty> is a reference type or has
    // non-potentially-throwing explicit destruction
};

template <class _Ty>
 constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

// STRUCT TEMPLATE is_signed
template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { // determine whether integral type _Ty is signed or unsigned
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = _Uty(-1) < _Uty(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { // floating-point _Ty is signed
                                // non-arithmetic _Ty is neither signed nor unsigned
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; // determine whether _Ty is a signed type

template <class _Ty>
 constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

// STRUCT TEMPLATE is_unsigned
template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; // determine whether _Ty is an unsigned type

template <class _Ty>
 constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

// VARIABLE TEMPLATE _Is_nonbool_integral
template <class _Ty>
 constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

// STRUCT TEMPLATE make_signed
template <bool>
struct _Select { // Select between aliases that extract either their first or second parameter
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; // Choose make_signed strategy by type size

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = // assumes LLP64
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = // signed partner to cv-unqualified _Ty
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_signed { // signed partner to _Ty
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

// STRUCT TEMPLATE make_unsigned
template <size_t>
struct _Make_unsigned2; // Choose make_unsigned strategy by type size

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = // assumes LLP64
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = // unsigned partner to cv-unqualified _Ty
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_unsigned { // unsigned partner to _Ty
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

// FUNCTION TEMPLATE _Unsigned_value
template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { // makes _Val unsigned
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

// STRUCT TEMPLATE alignment_of
template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; // determine alignment of _Ty

template <class _Ty>
 constexpr size_t alignment_of_v = alignof(_Ty);

// STRUCT TEMPLATE aligned_storage



template <class _Ty, size_t _Len>
union _Align_type { // union with size _Len bytes and alignment of _Ty
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; // define type with size _Len and alignment _Ty

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
        "behavior.");
#line 1071 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1073 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using type = typename _Aligned<_Len, _Align, double, _Align <= alignof(double)>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using type = typename _Aligned<_Len, _Align, int, _Align <= alignof(int)>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using type = typename _Aligned<_Len, _Align, short, _Align <= alignof(short)>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct aligned_storage { // define type with size _Len and alignment _Align
    using type = typename _Aligned<_Len, _Align, char, _Align <= alignof(char)>::type;
};




template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

// STRUCT TEMPLATE aligned_union
template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; // maximum of nothing is 0

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; // maximum of _Val is _Val

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    // find maximum value in _First, _Second, _Rest...
};

template <size_t _Len, class... _Types>
struct aligned_union { // define type with size at least _Len, for storing anything in _Types
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; // NOT sizeof...(_Types)
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = aligned_storage_t<_Max_len, alignment_value>;
};

template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

// STRUCT TEMPLATE underlying_type
template <class _Ty>
struct underlying_type { // determine underlying type for enum
    using type = __underlying_type(_Ty);
};

template <class _Ty>
using underlying_type_t = typename underlying_type<_Ty>::type;

// STRUCT TEMPLATE rank
template <class _Ty>
 constexpr size_t rank_v = 0; // determine number of dimensions of array _Ty

template <class _Ty, size_t _Nx>
 constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
 constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

// STRUCT TEMPLATE extent
template <class _Ty, unsigned int _Ix = 0>
 constexpr size_t extent_v = 0; // determine extent of dimension _Ix of array _Ty

template <class _Ty, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
 constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

// STRUCT TEMPLATE is_base_of
template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    // determine whether _Base is a base of or the same as _Derived
};

template <class _Base, class _Derived>
 constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

// STRUCT TEMPLATE decay
template <class _Ty>
struct decay { // determines decayed version of _Ty
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

template <class _Ty>
using decay_t = typename decay<_Ty>::type;

// ALIAS TEMPLATE _Conditional_type
template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());

// STRUCT TEMPLATE common_type












#line 1203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};
#line 1206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

template <class... _Ty>
struct common_type;

template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};


















































































































































#line 1389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE _Identity
template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t = typename _Identity<_Ty>::type;









#line 1407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE _Is_specialization
template <class _Type, template <class...> class _Template>
 constexpr bool _Is_specialization_v = false; // true if and only if _Type is a specialization of _Template
template <template <class...> class _Template, class... _Types>
 constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

// FUNCTION TEMPLATE forward
template <class _Ty>
 constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<_Ty&&>(_Arg);
}

template <class _Ty>
 constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept { // forward an rvalue as an rvalue
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

// FUNCTION TEMPLATE move
template <class _Ty>
 constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

// FUNCTION TEMPLATE move_if_noexcept
template <class _Ty>
 constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&,
    _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept { // forward _Arg as movable, sometimes
    return ::std:: move(_Arg);
}

template <class _Ty>
class reference_wrapper;





























































































































struct _Invoker_pmf_object { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmf_refwrap { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>( _Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmf_pointer { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>( _Args2)...)) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmd_object { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).*_Pmd; } }; struct _Invoker_pmd_refwrap { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype( ::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).get().*_Pmd; } }; struct _Invoker_pmd_pointer { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype( (*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return (*::std:: forward<_Ty1>(_Arg1)).*_Pmd; } }; struct _Invoker_functor { template <class _Callable, class... _Types> static inline auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype( ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...); } }; template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _Invoker1; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmf_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap, _Invoker_pmf_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t< is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmd_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap, _Invoker_pmd_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor { }; template <class _Callable, class... _Types> struct _Invoker; template <class _Callable> struct _Invoker<_Callable> : _Invoker_functor { }; template <class _Callable, class _Ty1, class... _Types2> struct _Invoker<_Callable, _Ty1, _Types2...> : _Invoker1<_Callable, _Ty1> { }; template <class _Callable, class... _Types> inline auto invoke(_Callable && _Obj, _Types && ... _Args) noexcept(noexcept(_Invoker < _Callable, _Types... > ::_Call(::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))) ->decltype(_Invoker < _Callable, _Types... > ::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return _Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...); }




#line 1577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"



template <class _Rx, bool = is_void_v<_Rx>>
struct _Invoker_ret {}; // helper to give INVOKE an explicit return type; avoids undesirable Expression SFINAE

struct _Unforced {}; // tag to distinguish bind() from bind<R>()

template <class _Cv_void>
struct _Invoker_ret<_Cv_void, true> { // selected for _Rx being cv void
    template <class... _Valtys>
    static void _Call(_Valtys&&... _Vals) { // INVOKE, "implicitly" converted to void
        ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};

template <class _Rx>
struct _Invoker_ret<_Rx, false> { // selected for all _Rx other than cv void and _Unforced
    template <class... _Valtys>
    static _Rx _Call(_Valtys&&... _Vals) { // INVOKE, implicitly converted to _Rx
        return ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};

template <>
struct _Invoker_ret<_Unforced, false> { // selected for _Rx being _Unforced
    template <class... _Valtys>
    static auto _Call(_Valtys&&... _Vals)
        -> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...)) { // INVOKE, unchanged
        return ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};


// TYPE TRAITS FOR invoke()
template <class _To>
void _Implicitly_convert_to(_To) noexcept; // not defined

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 
template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
 constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to<_To>(::std:: declval<_From>()));
#line 1623 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
#pragma warning(pop)
template <class _From, class _To, bool _IsVoid>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    // determine whether _From is nothrow-convertible to _To
};







#line 1641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

template <class _Void, class... _Types>
struct _Invoke_traits { // selected when _Callable isn't callable with _Args
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class... _Types>
struct _Invoke_traits<void_t<decltype(::std:: invoke(::std:: declval<_Types>()...))>,
    _Types...> { // selected when _Callable is callable with _Args
    using type                  = decltype(::std:: invoke(::std:: declval<_Types>()...));
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<noexcept(::std:: invoke(::std:: declval<_Types>()...))>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, is_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<
        conjunction_v<_Is_nothrow_invocable, disjunction<is_void<_Rx>, _Is_nothrow_convertible<type, _Rx>>>>;
};

// STRUCT TEMPLATE result_of
template <class _Fty>
struct  result_of { // explain usage
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};







template <class _Callable, class... _Args> struct  result_of<_Callable __cdecl(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };  template <class _Callable, class... _Args> struct  result_of<_Callable __fastcall(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { }; template <class _Callable, class... _Args> struct  result_of<_Callable __stdcall(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { }; template <class _Callable, class... _Args> struct  result_of<_Callable __vectorcall(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };


#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
using result_of_t  = typename result_of<_Ty>::type;
#pragma warning(pop)

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    // determines whether _Callable is callable with _Args and return type _Rx
};















































#line 1745 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"


// STRUCT TEMPLATE _Weak_types
template <class _Ty, class = void>
struct _Weak_result_type {}; // default definition

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { // defined if _Ty::result_type exists
     typedef typename _Ty::result_type result_type;
};
#pragma warning(pop)

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; // default definition

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>>
    : _Weak_result_type<_Ty> { // defined if _Ty::argument_type exists
     typedef typename _Ty::argument_type argument_type;
};
#pragma warning(pop)

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; // default definition

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { // defined if both types exist
     typedef typename _Ty::first_argument_type first_argument_type;
     typedef typename _Ty::second_argument_type second_argument_type;
};
#pragma warning(pop)

template <class _Ty>
struct _Weak_types { // provide nested types (sometimes)
    using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty>>;
    using _Is_pmf     = _Is_memfunptr<remove_cv_t<_Ty>>;
    using type        = conditional_t<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
        conditional_t<_Is_pmf::_Bool_type::value, _Is_pmf, _Weak_binary_args<_Ty>>>;
};

// CLASS TEMPLATE reference_wrapper
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>> : true_type {};

template <class _Ty>
class reference_wrapper : public _Weak_types<_Ty>::type { // stand-in for an assignable reference
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) {
        _Ty& _Ref = ::std:: forward<_Uty>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    operator _Ty&() const noexcept {
        return *_Ptr;
    }

     _Ty& get() const noexcept {
        return *_Ptr;
    }

    template <class... _Types>
    auto operator()(_Types&&... _Args) const -> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...)) {
        return ::std:: invoke(get(), ::std:: forward<_Types>(_Args)...);
    }

private:
    _Ty* _Ptr;
};




#line 1842 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// FUNCTION TEMPLATES ref AND cref
template <class _Ty>
 reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

template <class _Ty>
void ref(const _Ty&&) = delete;

template <class _Ty>
 reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: ref(_Val.get());
}

template <class _Ty>
 reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

template <class _Ty>
void cref(const _Ty&&) = delete;

template <class _Ty>
 reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: cref(_Val.get());
}





















#line 1891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// STRUCT TEMPLATE _Is_swappable
template <class _Ty>
struct _Is_swappable;

// STRUCT TEMPLATE _Is_nothrow_swappable
template <class _Ty>
struct _Is_nothrow_swappable;

// FUNCTION TEMPLATE swap


#line 1904 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
template <class _Ty, class = void>
#line 1906 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

template <class _Ty, size_t _Size, class = enable_if_t<_Is_swappable<_Ty>::value>>
void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

// STRUCT TEMPLATE _Swappable_with_helper
template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; // swap(declval<_Ty1>(), declval<_Ty2>()) is not valid

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; // swap(declval<_Ty1>(), declval<_Ty2>()) is valid

// STRUCT TEMPLATE _Is_swappable_with
template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    // Determine if expressions with type and value category _Ty1 and _Ty2 can be swapped (and vice versa)
};

// STRUCT TEMPLATE _Is_swappable
template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    // Determine if _Ty lvalues satisfy is_swappable_with
};

// STRUCT TEMPLATE _Swap_cannot_throw
template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                                          && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // (presumed to satisfy is_swappable_with) can be swapped without emitting exceptions
};

// STRUCT TEMPLATE _Is_nothrow_swappable_with
template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

// STRUCT TEMPLATE _Is_nothrow_swappable
template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};






































#line 1993 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

// TYPE TRAIT _Is_trivially_swappable
namespace _Has_ADL_swap_detail {
    void swap(); // undefined (deliberate shadowing)

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} // namespace _Has_ADL_swap_detail
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
 constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;

template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    // true_type if and only if it is valid to swap two _Ty lvalues by exchanging object representations.
};

// BITMASK OPERATIONS











































// FNV-1a UTILITIES
// These functions are extremely performance sensitive, check examples like
// that in VSO#653642 before making changes.



#line 2065 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
 constexpr size_t _FNV_offset_basis = 2166136261U;
 constexpr size_t _FNV_prime        = 16777619U;
#line 2068 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

 inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
 size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { // accumulate range [_First, _Last) into partial FNV-1a hash _Val
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
 size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

// FUNCTION TEMPLATE _Hash_representation
template <class _Kty>
 size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

// FUNCTION TEMPLATE _Hash_array_representation
template <class _Kty>
 size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { // bitwise hashes the representation of an array
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

// STRUCT TEMPLATE _Conditionally_enabled_hash
template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { // conditionally enabled hash base
     typedef _Kty argument_type;
     typedef size_t result_type;

     size_t operator()(const _Kty& _Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) { // hash _Keyval to size_t value by pseudorandomizing transform
#line 2122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { // conditionally disabled hash base
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)      = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};

// STRUCT TEMPLATE hash
template <class _Kty>
struct hash
    : _Conditionally_enabled_hash<_Kty,
          !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    // hash functor primary template (handles enums, integrals, and pointers)
    static size_t _Do_hash(
        const _Kty& _Keyval) noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
     typedef float argument_type;
     typedef size_t result_type;
     size_t operator()(const float _Keyval) const
        noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); // map -0 to 0
    }
};

template <>
struct hash<double> {
     typedef double argument_type;
     typedef size_t result_type;
     size_t operator()(const double _Keyval) const
        noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); // map -0 to 0
    }
};

template <>
struct hash<long double> {
     typedef long double argument_type;
     typedef size_t result_type;
     size_t operator()(const long double _Keyval) const
        noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); // map -0 to 0
    }
};

template <>
struct hash<nullptr_t> {
     typedef nullptr_t argument_type;
     typedef size_t result_type;
     size_t operator()(nullptr_t) const
        noexcept { // hash nullptr_t to size_t value by pseudorandomizing transform
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

// STRUCT TEMPLATE _Is_nothrow_hashable
template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; // tests if std::hash can hash _Kty with noexcept

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};


#pragma warning(push)
#pragma warning(disable : 4996) 
namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: add_const;
    using ::std:: add_cv;
    using ::std:: add_pointer;
    using ::std:: add_volatile;
    using ::std:: aligned_storage;
    using ::std:: alignment_of;
    using ::std:: conditional;
    using ::std:: decay;
    using ::std:: enable_if;
    using ::std:: extent;
    using ::std:: false_type;
    using ::std:: has_virtual_destructor;
    using ::std:: integral_constant;
    using ::std:: is_abstract;
    using ::std:: is_arithmetic;
    using ::std:: is_array;
    using ::std:: is_base_of;
    using ::std:: is_class;
    using ::std:: is_compound;
    using ::std:: is_const;
    using ::std:: is_convertible;
    using ::std:: is_empty;
    using ::std:: is_enum;
    using ::std:: is_floating_point;
    using ::std:: is_function;
    using ::std:: is_fundamental;
    using ::std:: is_integral;
    using ::std:: is_member_function_pointer;
    using ::std:: is_member_object_pointer;
    using ::std:: is_member_pointer;
    using ::std:: is_object;
    using ::std:: is_pod;
    using ::std:: is_pointer;
    using ::std:: is_polymorphic;
    using ::std:: is_reference;
    using ::std:: is_same;
    using ::std:: is_scalar;
    using ::std:: is_signed;
    using ::std:: is_union;
    using ::std:: is_unsigned;
    using ::std:: is_void;
    using ::std:: is_volatile;
    using ::std:: make_signed;
    using ::std:: make_unsigned;
    using ::std:: rank;
    using ::std:: remove_all_extents;
    using ::std:: remove_const;
    using ::std:: remove_cv;
    using ::std:: remove_extent;
    using ::std:: remove_pointer;
    using ::std:: remove_reference;
    using ::std:: remove_volatile;
    using ::std:: true_type;
    using ::std:: cref;
    using ::std:: ref;
    using ::std:: reference_wrapper;
    using ::std:: result_of;
    using ::std:: hash;
} // namespace tr1
#pragma warning(pop)
#line 2260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

}



#pragma warning(pop)
#pragma pack(pop)
#line 2268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"
#line 2269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\type_traits"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {

  bool __cdecl uncaught_exception() noexcept;
 int __cdecl uncaught_exceptions() noexcept;

}



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
//
// malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {



// Maximum heap request the heap manager will attempt



    
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"



// Constants for _heapchk and _heapwalk routines











typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;








   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    


        
    #line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"

    typedef char __static_assert_t[(sizeof(unsigned int) <= 8) != 0];


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 8;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 8;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"





    
        
        




    #line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"












#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"




#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 8;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                (void)( (!!((("Corrupted pointer passed to _freea" && 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h", 162, 0, L"%ls", L"(\"Corrupted pointer passed to _freea\" && 0)")) || (__debugbreak(), 0) );
            }
            #line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"




    
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"



} __pragma(pack(pop))
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_exception.h"
//
// vcruntime_exception.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <exception> functionality that is implemented in the VCRuntime.
//
#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\eh.h"
//
// eh.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// User-includable header for exception handling.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
//
// corecrt_terminate.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The terminate handler
//
#pragma once





__pragma(pack(push, 8)) extern "C" {

// terminate_handler is the standard name; terminate_function is defined for
// source compatibility.
typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\eh.h"



__pragma(pack(push, 8)) extern "C" {

// unexpected_handler is the standard name; unexpected_function is defined for
// source compatibility.
typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;



     __declspec(noreturn) void __cdecl unexpected() noexcept(false);

    

         unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) noexcept;

         unexpected_handler __cdecl _get_unexpected() noexcept;

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\eh.h"

    class type_info;

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();

#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\eh.h"

} __pragma(pack(pop))

#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\eh.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_exception.h"







#pragma pack(push, 8)

__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

     virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

#pragma warning(pop)

} // namespace std

#pragma pack(pop)

#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_exception.h"

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
  V6.00:0009 */
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"

namespace std {

using ::terminate;


using ::set_terminate;
using ::terminate_handler;

 inline terminate_handler __cdecl get_terminate() noexcept { // get current terminate handler
    return _get_terminate();
}
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"


using ::unexpected;


using ::set_unexpected;
using ::unexpected_handler;

 inline unexpected_handler __cdecl get_unexpected() noexcept { // get current unexpected handler
    return _get_unexpected();
}
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"

}

















































































































































#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"

 void __cdecl __ExceptionPtrCreate(  void*) noexcept;
 void __cdecl __ExceptionPtrDestroy(  void*) noexcept;
 void __cdecl __ExceptionPtrCopy(  void*,   const void*) noexcept;
 void __cdecl __ExceptionPtrAssign(  void*,   const void*) noexcept;
 bool __cdecl __ExceptionPtrCompare(  const void*,   const void*) noexcept;
 bool __cdecl __ExceptionPtrToBool(  const void*) noexcept;
 void __cdecl __ExceptionPtrSwap(  void*,   void*) noexcept;
 void __cdecl __ExceptionPtrCurrentException(  void*) noexcept;
[[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
 void __cdecl __ExceptionPtrCopyException(
      void*,   const void*,   const void*) noexcept;

namespace std {

class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Current_exception() noexcept {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }

    static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            // unsupported exceptions
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

private:




    void* _Data1;
    void* _Data2;



};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
    __ExceptionPtrSwap(&_Lhs, &_Rhs);
}

 inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
    return __ExceptionPtrCompare(&_Lhs, &_Rhs);
}

 inline bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept {
    return !_Rhs;
}

 inline bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
    return !_Lhs;
}

 inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
    return !(_Lhs == _Rhs);
}

 inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept {
    return !(_Lhs == _Rhs);
}

 inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept {
    return !(_Lhs == _Rhs);
}

 inline exception_ptr current_exception() noexcept {
    return exception_ptr::_Current_exception();
}

[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

template <class _Ex>
 exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}

// FUNCTION _Throw_bad_array_new_length
[[noreturn]] inline void _Throw_bad_array_new_length() {
    throw bad_array_new_length{};
}

// CLASS nested_exception
class nested_exception { // wrap an exception_ptr
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) {}

    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { // throw wrapped exception_ptr
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate();
        }
    }

     exception_ptr nested_ptr() const noexcept { // return wrapped exception_ptr
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

// FUNCTION TEMPLATE throw_with_nested
template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception { // glue user exception to nested_exception
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() { // store user exception and current_exception()
    }
};


template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) { // throw user exception, glued to nested_exception if possible
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        // throw user exception glued to nested_exception
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std:: forward<_Ty>(_Arg));
    } else {
        // throw user exception by itself
        throw ::std:: forward<_Ty>(_Arg);
    }
}






















#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"


// FUNCTION TEMPLATE rethrow_if_nested
template <class _Ty>
void _Rethrow_if_nested(const _Ty* _Ptr, true_type) { // use dynamic_cast
    const auto _Nested = dynamic_cast<const nested_exception*>(_Ptr);

    if (_Nested) {
        _Nested->rethrow_nested();
    }
}

template <class _Ty>
void _Rethrow_if_nested(const _Ty*, false_type) { // can't use dynamic_cast
}

template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) { // detect nested_exception inheritance
    bool_constant<
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>)>
        _Tag;

    _Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
}



#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"

}



#pragma warning(pop)
#pragma pack(pop)

#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"
#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\exception"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
// xstring internal header (<string_view> without emitting non-C++17 warnings)
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"
// iosfwd standard header
#pragma once






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstring"
// cstring standard header
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
//
// string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <string.h> header.
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
//
// corecrt_memory.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The buffer (memory) manipulation library.  These declarations are split out
// so that they may be included by both <string.h> and <memory.h>.  <string.h>
// does not include <memory.h> to avoid introducing conflicts with other user
// headers named <memory.h>.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
//
// corecrt_memcpy_s.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Inline definitions of memcpy_s and memmove_s
//
#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_string.h"
//
// vcruntime_string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <string.h> functionality that is implemented in the VCRuntime.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {



  
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

  
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

  
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

    
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

  

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

  
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

    

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_string.h"
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            // Unreachable, but required to suppress /analyze warnings:
            return 22;
        }
#pragma warning(suppress:4996) 
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

#pragma warning(suppress:4996) 
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"




__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"

    












#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"

#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
//
// corecrt_wstring.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) string functionality, shared
// by <string.h> and <wchar.h>.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Secure Alternatives
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide-Character <string.h> Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
    
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
        



    #line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 
    #pragma warning(disable: 28719 28726 28727) 
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline C++ Overloads
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-Standard Names
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    


#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"

    // Declarations of functions defined in oldnames.lib:
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"




__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(pop)

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 

#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

#line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
    
#line 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"





    
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );
    

    // Declarations of functions defined in oldnames.lib:
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"



} __pragma(pack(pop))

#line 595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: size_t;
using :: memchr;
using :: memcmp;
using :: memcpy;
using :: memmove;
using :: memset;
using :: strcat;
using :: strchr;
using :: strcmp;
using :: strcoll;
using :: strcpy;
using :: strcspn;
using :: strerror;
using :: strlen;
using :: strncat;
using :: strncmp;
using :: strncpy;
using :: strpbrk;
using :: strrchr;
using :: strspn;
using :: strstr;
using :: strtok;
using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstring"
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstring"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cwchar"
// cwchar standard header (core)
#pragma once






#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
//
// wchar.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// All of the types, macros, and function declarations for all wide-character
// related functionality.  Most of the functionality is in the #included
// <corecrt_wxxxx.h> headers, which are also #included by other public headers.
//
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
//
// corecrt_wconio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) console I/O functionality,
// shared by both <conio.h> and <wchar.h>
//
#pragma once




__pragma(pack(push, 8)) extern "C" {









    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"

#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"



} __pragma(pack(pop))
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
//
// corecrt_wctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) classification functionality,
// shared by <ctype.h>, <wchar.h>, and <wctype.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {







// This declaration allows the user access to the ctype look-up
// array _ctype defined in ctype.obj by simply including ctype.h


    

#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"

// Bit masks for the possible character types














//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Classification and Conversion Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macro and Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










































































#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wdirect.h"
//
// corecrt_wdirect.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) directory functionality, shared
// by <direct.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
//
// corecrt_wio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <io.h> and <wchar.h>.
//
#pragma once




__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable:4820) 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




    
    
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






    
    
    
    
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    // These functions do not validate pmode; use _wsopen_s instead.
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        // Last parameter passed as 0 because we don't want to validate pmode from _open
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        // Last parameter passed as 0 because we don't want to validate pmode from _sopen
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
//
// corecrt_wprocess.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) process functionality, shared
// by <process.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
//
// corecrt_wtime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) time functionality, shared
// by <time.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide String Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"

    #pragma warning(pop)
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"



} __pragma(pack(pop))
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"
//
// sys/stat.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The _stat() and _fstat() families of functions.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"
//
// sys/types.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Types used for returning file status and time information.
//
#pragma once




    

    typedef unsigned short _ino_t; // inode number (unused on Windows)

    
        typedef _ino_t ino_t;
    #line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; // device code

    
        typedef _dev_t dev_t;
    #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; // file offset value

    
        typedef _off_t off_t;
    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\types.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820) 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










    
    
    
    
    
    
    
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+








    
    
    
    
    
    
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys\\stat.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"



} __pragma(pack(pop))
#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cwchar"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

using :: mbstate_t;
using :: size_t;
using :: tm;
using :: wint_t;

using :: btowc;
using :: fgetwc;
using :: fgetws;
using :: fputwc;
using :: fputws;
using :: fwide;
using :: fwprintf;
using :: fwscanf;
using :: getwc;
using :: getwchar;
using :: mbrlen;
using :: mbrtowc;
using :: mbsrtowcs;
using :: mbsinit;
using :: putwc;
using :: putwchar;
using :: swprintf;
using :: swscanf;
using :: ungetwc;
using :: vfwprintf;
using :: vswprintf;
using :: vwprintf;
using :: wcrtomb;
using :: wprintf;
using :: wscanf;
using :: wcsrtombs;
using :: wcstol;
using :: wcscat;
using :: wcschr;
using :: wcscmp;
using :: wcscoll;
using :: wcscpy;
using :: wcscspn;
using :: wcslen;
using :: wcsncat;
using :: wcsncmp;
using :: wcsncpy;
using :: wcspbrk;
using :: wcsrchr;
using :: wcsspn;
using :: wcstod;
using :: wcstoul;
using :: wcsstr;
using :: wcstok;
using :: wcsxfrm;
using :: wctob;
using :: wmemchr;
using :: wmemcmp;
using :: wmemcpy;
using :: wmemmove;
using :: wmemset;
using :: wcsftime;

using :: vfwscanf;
using :: vswscanf;
using :: vwscanf;
using :: wcstof;
using :: wcstold;
using :: wcstoll;
using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cwchar"
#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cwchar"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// I/O EXCEPTION MACROS



















#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"

// STREAM POSITIONING TYPES (from <streambuf>)
using streamoff  = long long;
using streamsize = long long;

// CLASS TEMPLATE fpos (from <streambuf>)
template <class _Statetype>
class fpos { // store arbitrary file position
public:
    /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() { // construct with stream offset
    }

    fpos(_Statetype _State, fpos_t _Fileposition)
        : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) { // construct with conversion state and C file position
    }

     _Statetype state() const { // return conversion state
        return _Mystate;
    }

    void state(_Statetype _State) { // set conversion state
        _Mystate = _State;
    }

    operator streamoff() const { // return offset
                                 // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
                                 // basic_filebuf would set _Fpos.
        return _Myoff + _Fpos;
    }


    [[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept {
        return {};
    }
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"

     streamoff operator-(const fpos& _Right) const { // return difference of file positions as an offset
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }

    fpos& operator+=(streamoff _Off) { // add offset
        _Myoff += _Off;
        return *this;
    }

    fpos& operator-=(streamoff _Off) { // subtract offset
        _Myoff -= _Off;
        return *this;
    }

     fpos operator+(streamoff _Off) const { // return this + offset
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

     fpos operator-(streamoff _Off) const { // return this - offset
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

     bool operator==(const fpos& _Right) const {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
     friend bool operator==(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) == _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
     friend bool operator==(const _Int _Left, const fpos& _Right) {
        return _Left == static_cast<streamoff>(_Right);
    }

     bool operator!=(const fpos& _Right) const {
        return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
     friend bool operator!=(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) != _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
     friend bool operator!=(const _Int _Left, const fpos& _Right) {
        return _Left != static_cast<streamoff>(_Right);
    }

private:
    streamoff _Myoff; // stream offset
    fpos_t _Fpos; // TRANSITION, ABI. C file position, not currently used
    _Statetype _Mystate; // current conversion state
};

using streampos  = fpos<_Mbstatet>;
using wstreampos = streampos;

// FORWARD REFERENCES
class locale;
template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);

template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;



#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;

template <>
struct char_traits<unsigned short>;
#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"

template <class _Ty>
class allocator;
class ios_base;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;

#pragma vtordisp(push, 2) 
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) 

template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;


template <class _Elem, class _InIt>
class num_get;
template <class _Elem, class _OutIt>
class num_put;
template <class _Elem>
class collate;
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"

// char TYPEDEFS
using ios           = basic_ios<char, char_traits<char>>;
using streambuf     = basic_streambuf<char, char_traits<char>>;
using istream       = basic_istream<char, char_traits<char>>;
using ostream       = basic_ostream<char, char_traits<char>>;
using iostream      = basic_iostream<char, char_traits<char>>;
using stringbuf     = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream  = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf       = basic_filebuf<char, char_traits<char>>;
using ifstream      = basic_ifstream<char, char_traits<char>>;
using ofstream      = basic_ofstream<char, char_traits<char>>;
using fstream       = basic_fstream<char, char_traits<char>>;

// wchar_t TYPEDEFS
using wios           = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf     = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream       = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream       = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream      = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf     = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream  = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf       = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream      = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream      = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream       = basic_fstream<wchar_t, char_traits<wchar_t>>;






#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"
}



#pragma warning(pop)
#pragma pack(pop)
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iosfwd"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
// xmemory internal header
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdint"
// cstdint standard header
#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdint.h"
//
// stdint.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdint.h> header.
//
#pragma once





typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.












































    
    
    
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdint.h"


































#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdint.h"

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdint"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
using :: int8_t;
using :: int16_t;
using :: int32_t;
using :: int64_t;
using :: uint8_t;
using :: uint16_t;
using :: uint32_t;
using :: uint64_t;

using :: int_least8_t;
using :: int_least16_t;
using :: int_least32_t;
using :: int_least64_t;
using :: uint_least8_t;
using :: uint_least16_t;
using :: uint_least32_t;
using :: uint_least64_t;

using :: int_fast8_t;
using :: int_fast16_t;
using :: int_fast32_t;
using :: int_fast64_t;
using :: uint_fast8_t;
using :: uint_fast16_t;
using :: uint_fast32_t;
using :: uint_fast64_t;

using :: intmax_t;
using :: intptr_t;
using :: uintmax_t;
using :: uintptr_t;


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using :: int8_t;
    using :: int16_t;
    using :: int32_t;
    using :: int64_t;
    using :: uint8_t;
    using :: uint16_t;
    using :: uint32_t;
    using :: uint64_t;

    using :: int_least8_t;
    using :: int_least16_t;
    using :: int_least32_t;
    using :: int_least64_t;
    using :: uint_least8_t;
    using :: uint_least16_t;
    using :: uint_least32_t;
    using :: uint_least64_t;

    using :: int_fast8_t;
    using :: int_fast16_t;
    using :: int_fast32_t;
    using :: int_fast64_t;
    using :: uint_fast8_t;
    using :: uint_fast16_t;
    using :: uint_fast32_t;
    using :: uint_fast64_t;

    using :: intmax_t;
    using :: intptr_t;
    using :: uintmax_t;
    using :: uintptr_t;
} // namespace tr1
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdint"
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cstdint"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits"
// limits standard header (core)
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cfloat"
// cfloat standard header (core)
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
//
// float.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Implementation-defined values commonly used by sophisticated numerical
// (floating point) programs.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
    #line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"


// Define the floating point precision used.
//
// For x86, results are in double precision (unless /arch:sse2 is used, in which
// case results are in source precision.
//
// For x64 and ARM, results are in source precision.
//
// If the compiler is invoked with /fp:fast, the compiler is allowed to use the
// fastest precision and even mix within a single function, so precision is
// indeterminable.
//
// Note that manipulating the floating point behavior using the float_control/
// fenv_access/fp_contract #pragmas may alter the actual floating point evaluation
// method, which may in turn invalidate the value of FLT_EVAL_METHOD.



    
        
            
        

#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
    

#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Constants
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+















































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+







// New Control Bit that specifies the ambiguity in control word.



// Abstract User Control Word Mask and bit definitions














// i386 specific definitions









// RISC specific definitions








// Invalid subconditions (_SW_INVALID also set)







// Floating point error signals and return codes














// On x86 with arch:SSE2, the OS returns these exceptions


















// Initial Control Word value


    





#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// State Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Note that reading or writing the floating point control or status words is
// not supported in managed code.

__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);



    
    __declspec(dllimport) void __cdecl _statusfp2(
          unsigned int* _X86Status,
          unsigned int* _SSE2Status
        );

#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"





__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );


    
    __declspec(dllimport) int __cdecl __control87_2(
               unsigned int  _NewValue,
               unsigned int  _Mask,
          unsigned int* _X86ControlWord,
          unsigned int* _Sse2ControlWord
        );
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"

// Global variable holding floating point error code
 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);







//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// IEEE Recommended Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);







//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Nonstandard Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    // For backwards compatibility with the old spelling
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"



} __pragma(pack(pop))
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cfloat"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\cfloat"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits"




#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// ENUM float_denorm_style
enum float_denorm_style { // constants for different IEEE float denormalization styles
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

// ENUM float_round_style
enum float_round_style { // constants for different IEEE rounding styles
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

// STRUCT _Num_base
struct _Num_base { // base for all types, with common defaults
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

// CLASS TEMPLATE numeric_limits
template <class _Ty>
class numeric_limits : public _Num_base { // numeric limits for arbitrary type _Ty (say little or nothing)
public:
     static constexpr _Ty(min)() noexcept { // return minimum value
        return _Ty();
    }

     static constexpr _Ty(max)() noexcept { // return maximum value
        return _Ty();
    }

     static constexpr _Ty lowest() noexcept { // return most negative value
        return _Ty();
    }

     static constexpr _Ty epsilon() noexcept { // return smallest effective increment from 1.0
        return _Ty();
    }

     static constexpr _Ty round_error() noexcept { // return largest rounding error
        return _Ty();
    }

     static constexpr _Ty denorm_min() noexcept { // return minimum denormalized value
        return _Ty();
    }

     static constexpr _Ty infinity() noexcept { // return positive infinity
        return _Ty();
    }

     static constexpr _Ty quiet_NaN() noexcept { // return non-signaling NaN
        return _Ty();
    }

     static constexpr _Ty signaling_NaN() noexcept { // return signaling NaN
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> { // numeric limits for const types
};

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> { // numeric limits for volatile types
};

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> { // numeric limits for const volatile types
};

// STRUCT _Num_int_base
struct _Num_int_base : _Num_base { // base for integer types
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

// STRUCT _Num_float_base
struct _Num_float_base : _Num_base { // base for floating-point types
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};

// CLASS numeric_limits<bool>
template <>
class numeric_limits<bool> : public _Num_int_base { // limits for type bool
public:
     static constexpr bool(min)() noexcept { // return minimum value
        return false;
    }

     static constexpr bool(max)() noexcept { // return maximum value
        return true;
    }

     static constexpr bool lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr bool epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr bool round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr bool denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr bool infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr bool quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr bool signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr int digits = 1;
};

// CLASS numeric_limits<char>
template <>
class numeric_limits<char> : public _Num_int_base { // limits for type char
public:
     static constexpr char(min)() noexcept { // return minimum value
        return (-128);
    }

     static constexpr char(max)() noexcept { // return maximum value
        return 127;
    }

     static constexpr char lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr char epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr char round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr char denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr char infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr char quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr char signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

// CLASS numeric_limits<signed char>
template <>
class numeric_limits<signed char> : public _Num_int_base { // limits for type signed char
public:
     static constexpr signed char(min)() noexcept { // return minimum value
        return (-128);
    }

     static constexpr signed char(max)() noexcept { // return maximum value
        return 127;
    }

     static constexpr signed char lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr signed char epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr signed char round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr signed char denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr signed char infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr signed char quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr signed char signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

// CLASS numeric_limits<unsigned char>
template <>
class numeric_limits<unsigned char> : public _Num_int_base { // limits for type unsigned char
public:
     static constexpr unsigned char(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr unsigned char(max)() noexcept { // return maximum value
        return 0xff;
    }

     static constexpr unsigned char lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr unsigned char epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr unsigned char round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr unsigned char denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr unsigned char infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr unsigned char quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr unsigned char signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};














































#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits"

// CLASS numeric_limits<char16_t>
template <>
class numeric_limits<char16_t> : public _Num_int_base { // limits for type char16_t
public:
     static constexpr char16_t(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr char16_t(max)() noexcept { // return maximum value
        return 0xffff;
    }

     static constexpr char16_t lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr char16_t epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr char16_t round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr char16_t denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr char16_t infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr char16_t quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr char16_t signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

// CLASS numeric_limits<char32_t>
template <>
class numeric_limits<char32_t> : public _Num_int_base { // limits for type char32_t
public:
     static constexpr char32_t(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr char32_t(max)() noexcept { // return maximum value
        return 0xffffffff;
    }

     static constexpr char32_t lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr char32_t epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr char32_t round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr char32_t denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr char32_t infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr char32_t quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr char32_t signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

// CLASS numeric_limits<wchar_t>
template <>
class numeric_limits<wchar_t> : public _Num_int_base { // limits for type wchar_t
public:
     static constexpr wchar_t(min)() noexcept { // return minimum value
        return 0x0000;
    }

     static constexpr wchar_t(max)() noexcept { // return maximum value
        return 0xffff;
    }

     static constexpr wchar_t lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr wchar_t epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr wchar_t round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr wchar_t denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr wchar_t infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr wchar_t quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr wchar_t signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

// CLASS numeric_limits<short>
template <>
class numeric_limits<short> : public _Num_int_base { // limits for type short
public:
     static constexpr short(min)() noexcept { // return minimum value
        return (-32768);
    }

     static constexpr short(max)() noexcept { // return maximum value
        return 32767;
    }

     static constexpr short lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr short epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr short round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr short denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr short infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr short quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr short signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

// CLASS numeric_limits<int>
template <>
class numeric_limits<int> : public _Num_int_base { // limits for type int
public:
     static constexpr int(min)() noexcept { // return minimum value
        return (-2147483647 - 1);
    }

     static constexpr int(max)() noexcept { // return maximum value
        return 2147483647;
    }

     static constexpr int lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr int epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr int round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr int denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr int infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr int quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr int signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

// CLASS numeric_limits<long>
template <>
class numeric_limits<long> : public _Num_int_base { // limits for type long
public:
     static constexpr long(min)() noexcept { // return minimum value
        return (-2147483647L - 1);
    }

     static constexpr long(max)() noexcept { // return maximum value
        return 2147483647L;
    }

     static constexpr long lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr long epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr long round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr long denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr long infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr long quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr long signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

// CLASS numeric_limits<long long>
template <>
class numeric_limits<long long> : public _Num_int_base { // limits for type long long
public:
     static constexpr long long(min)() noexcept { // return minimum value
        return (-9223372036854775807i64 - 1);
    }

     static constexpr long long(max)() noexcept { // return maximum value
        return 9223372036854775807i64;
    }

     static constexpr long long lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr long long epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr long long round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr long long denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr long long infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr long long quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr long long signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


// CLASS numeric_limits<unsigned short>
template <>
class numeric_limits<unsigned short> : public _Num_int_base { // limits for type unsigned short
public:
     static constexpr unsigned short(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr unsigned short(max)() noexcept { // return maximum value
        return 0xffff;
    }

     static constexpr unsigned short lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr unsigned short epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr unsigned short round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr unsigned short denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr unsigned short infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr unsigned short quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr unsigned short signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 727 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits"

// CLASS numeric_limits<unsigned int>
template <>
class numeric_limits<unsigned int> : public _Num_int_base { // limits for type unsigned int
public:
     static constexpr unsigned int(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr unsigned int(max)() noexcept { // return maximum value
        return 0xffffffff;
    }

     static constexpr unsigned int lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr unsigned int epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr unsigned int round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr unsigned int denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr unsigned int infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr unsigned int quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr unsigned int signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

// CLASS numeric_limits<unsigned long>
template <>
class numeric_limits<unsigned long> : public _Num_int_base { // limits for type unsigned long
public:
     static constexpr unsigned long(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr unsigned long(max)() noexcept { // return maximum value
        return 0xffffffffUL;
    }

     static constexpr unsigned long lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr unsigned long epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr unsigned long round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr unsigned long denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr unsigned long infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr unsigned long quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr unsigned long signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

// CLASS numeric_limits<unsigned long long>
template <>
class numeric_limits<unsigned long long> : public _Num_int_base { // limits for type unsigned long long
public:
     static constexpr unsigned long long(min)() noexcept { // return minimum value
        return 0;
    }

     static constexpr unsigned long long(max)() noexcept { // return maximum value
        return 0xffffffffffffffffui64;
    }

     static constexpr unsigned long long lowest() noexcept { // return most negative value
        return (min)();
    }

     static constexpr unsigned long long epsilon() noexcept { // return smallest effective increment from 1.0
        return 0;
    }

     static constexpr unsigned long long round_error() noexcept { // return largest rounding error
        return 0;
    }

     static constexpr unsigned long long denorm_min() noexcept { // return minimum denormalized value
        return 0;
    }

     static constexpr unsigned long long infinity() noexcept { // return positive infinity
        return 0;
    }

     static constexpr unsigned long long quiet_NaN() noexcept { // return non-signaling NaN
        return 0;
    }

     static constexpr unsigned long long signaling_NaN() noexcept { // return signaling NaN
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

// CLASS numeric_limits<float>
template <>
class numeric_limits<float> : public _Num_float_base { // limits for type float
public:
     static constexpr float(min)() noexcept { // return minimum value
        return 1.175494351e-38F;
    }

     static constexpr float(max)() noexcept { // return maximum value
        return 3.402823466e+38F;
    }

     static constexpr float lowest() noexcept { // return most negative value
        return -(max)();
    }

     static constexpr float epsilon() noexcept { // return smallest effective increment from 1.0
        return 1.192092896e-07F;
    }

     static constexpr float round_error() noexcept { // return largest rounding error
        return 0.5F;
    }

     static constexpr float denorm_min() noexcept { // return minimum denormalized value
        return 1.401298464e-45F;
    }

     static constexpr float infinity() noexcept { // return positive infinity
        return __builtin_huge_valf();
    }

     static constexpr float quiet_NaN() noexcept { // return non-signaling NaN
        return __builtin_nanf("0");
    }

     static constexpr float signaling_NaN() noexcept { // return signaling NaN
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};

// CLASS numeric_limits<double>
template <>
class numeric_limits<double> : public _Num_float_base { // limits for type double
public:
     static constexpr double(min)() noexcept { // return minimum value
        return 2.2250738585072014e-308;
    }

     static constexpr double(max)() noexcept { // return maximum value
        return 1.7976931348623158e+308;
    }

     static constexpr double lowest() noexcept { // return most negative value
        return -(max)();
    }

     static constexpr double epsilon() noexcept { // return smallest effective increment from 1.0
        return 2.2204460492503131e-016;
    }

     static constexpr double round_error() noexcept { // return largest rounding error
        return 0.5;
    }

     static constexpr double denorm_min() noexcept { // return minimum denormalized value
        return 4.9406564584124654e-324;
    }

     static constexpr double infinity() noexcept { // return positive infinity
        return __builtin_huge_val();
    }

     static constexpr double quiet_NaN() noexcept { // return non-signaling NaN
        return __builtin_nan("0");
    }

     static constexpr double signaling_NaN() noexcept { // return signaling NaN
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

// CLASS numeric_limits<long double>
template <>
class numeric_limits<long double> : public _Num_float_base { // limits for type long double
public:
     static constexpr long double(min)() noexcept { // return minimum value
        return 2.2250738585072014e-308;
    }

     static constexpr long double(max)() noexcept { // return maximum value
        return 1.7976931348623158e+308;
    }

     static constexpr long double lowest() noexcept { // return most negative value
        return -(max)();
    }

     static constexpr long double epsilon() noexcept { // return smallest effective increment from 1.0
        return 2.2204460492503131e-016;
    }

     static constexpr long double round_error() noexcept { // return largest rounding error
        return 0.5L;
    }

     static constexpr long double denorm_min() noexcept { // return minimum denormalized value
        return 4.9406564584124654e-324;
    }

     static constexpr long double infinity() noexcept { // return positive infinity
        return __builtin_huge_val();
    }

     static constexpr long double quiet_NaN() noexcept { // return non-signaling NaN
        return __builtin_nan("0");
    }

     static constexpr long double signaling_NaN() noexcept { // return signaling NaN
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 1016 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits"
#line 1017 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\limits"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\new"
// new standard header
#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
















#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\new"

// SUPPORT TYPES

// handler for operator new failures
using new_handler = void(__cdecl*)();
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\new"

// FUNCTION AND OBJECT DECLARATIONS
 new_handler __cdecl set_new_handler(  new_handler) noexcept;
  new_handler __cdecl get_new_handler() noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\new"
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\new"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xatomic.h"
// xatomic.h internal header
#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"
/***
*   intrin0.h - declarations of compiler intrinsics used by the C++ Standard Library.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This header file declares compiler intrinsics that are used by the
*   C++ Standard Library, especially <atomic>. Compiler throughput is
*   the only reason that intrin0.h is separate from intrin.h.
*
****/

#pragma once





extern "C" {
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"

/*
** __MACHINE              : everything
** __MACHINEX86           : x86 only
** __MACHINEX64           : x64 only
** __MACHINEX86_X64       : x86 and x64 only
** __MACHINEARM           : ARM only
** __MACHINEARM64         : ARM64 only
** __MACHINEARM_ARM64     : ARM and ARM64 only
** __MACHINEARM_ARM64_X64 : ARM and 64-bit Arch only
** __MACHINEARM64_X64     : ARM64 and x64 only
** __MACHINECHPEX86ARM64  : CHPE x86 on arm64 only
** __MACHINEWVMPURE       : /clr:pure only
** __MACHINEZ             : nothing
*/











/* Most intrinsics not available to pure managed code */



#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"


#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"






#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"

/* For compatibility with <winnt.h>, some intrinsics are __cdecl except on x64 */


#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"

#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"




#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"

/*******************************************************************
* Note: New intrinsics should be added here IF AND ONLY IF they're *
* being used by the C++ Standard Library.                          *
* OTHERWISE, new intrinsics should be added to intrin.h.           *
*******************************************************************/



unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);


unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);


unsigned char _bittest(long const *, long);
long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);







char _InterlockedAnd8(char volatile * _Value, char _Mask);






long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);

long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);


long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);







char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);







char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


unsigned char _interlockedbittestandset(long volatile *, long);







constexpr void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;


#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"

/*******************************************************************
* Note: New intrinsics should be added here IF AND ONLY IF they're *
* being used by the C++ Standard Library.                          *
* OTHERWISE, new intrinsics should be added to intrin.h.           *
*******************************************************************/


}
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"
#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\intrin0.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xatomic.h"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




// Interlocked intrinsic mapping for _nf/_acq/_rel


















#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xatomic.h"












#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xatomic.h"

namespace std {

// ENUM memory_order
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};

using _Atomic_counter_t = unsigned long;

// FUNCTION TEMPLATE _Atomic_address_as
template <class _Integral, class _Ty>
 volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    // gets a pointer to the argument as an integral type (to pass to intrinsics)
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xatomic.h"
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xatomic.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
// xutility internal header
#pragma once








#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
// utility standard header (core)
#pragma once











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// FUNCTION TEMPLATE _Min_value
template <class _Ty>
  constexpr const _Ty& _Min_value(const _Ty& _Left, const _Ty& _Right)
    noexcept(noexcept(_Right < _Left)) { // return smaller of _Left and _Right
    return _Right < _Left ? _Right : _Left;
}

// FUNCTION TEMPLATE _Max_value
template <class _Ty>
  constexpr const _Ty& _Max_value(const _Ty& _Left, const _Ty& _Right)
    noexcept(noexcept(_Left < _Right)) { // return larger of _Left and _Right
    return _Left < _Right ? _Right : _Left;
}

// FUNCTION TEMPLATE iter_swap (from <algorithm>)
template <class _FwdIt1, class _FwdIt2>
void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right
    swap(*_Left, *_Right);
}

// FUNCTION TEMPLATE swap
template <class _Ty, size_t _Size, class>
void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
    noexcept(_Is_nothrow_swappable<_Ty>::value) { // exchange arrays stored at _Left and _Right
    if (&_Left != &_Right) { // worth swapping, swap ranges
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std:: iter_swap(_First1, _First2);
        }
    }
}

template <class _Ty, class>
void swap(_Ty& _Left, _Ty& _Right) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) { // exchange values stored at _Left and _Right
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

// FUNCTION TEMPLATE _Swap_adl
template <class _Ty>
void _Swap_adl(_Ty& _Left, _Ty& _Right)
    noexcept(_Is_nothrow_swappable<_Ty>::value) { // exchange values stored at _Left and _Right, using ADL
    swap(_Left, _Right);
}

// STRUCT piecewise_construct_t
struct piecewise_construct_t { // tag type for pair tuple arguments
    explicit piecewise_construct_t() = default;
};

 constexpr piecewise_construct_t piecewise_construct{};

// STRUCT TEMPLATE pair
template <class...>
class tuple;

template <class _Ty1, class _Ty2>
struct pair { // store a pair of values
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>,
                        _Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>,
            int> = 0>
    constexpr pair() noexcept(is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) // strengthened
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>,
                        negation<conjunction<_Is_implicitly_default_constructible<_Uty1>,
                            _Is_implicitly_default_constructible<_Uty2>>>>,
            int> = 0>
    constexpr explicit pair() noexcept(is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) // strengthened
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>,
                        is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>,
            int> = 0>
    constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
        noexcept(is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) // strengthened
        : first(_Val1), second(_Val2) {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<
            conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>,
                negation<conjunction<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>>>,
            int> = 0>
    constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
        noexcept(is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) // strengthened
        : first(_Val1), second(_Val2) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>,
            int> = 0>
    constexpr pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) // strengthened
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) // strengthened
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {}

    pair(const pair&) = default;
    pair(pair&&)      = default;

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>,
                        is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>,
            int> = 0>
    constexpr pair(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&& is_nothrow_constructible_v<_Ty2, const _Other2&>) // strengthened
#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<
            conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>,
                negation<conjunction<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&& is_nothrow_constructible_v<_Ty2, const _Other2&>) // strengthened
#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>,
            int> = 0>
    constexpr pair(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) // strengthened
#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) // strengthened
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}

    template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
    pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>);

    template <class... _Types1, class... _Types2>
    pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2);

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>) { // strengthened
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>) { // strengthened
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    pair& operator=(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_assignable_v<_Ty1&, const _Other1&>&& is_nothrow_assignable_v<_Ty2&, const _Other2&>) { // strengthened
#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>) { // strengthened
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }

    void swap(pair& _Right) noexcept(_Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        if (this != ::std:: addressof(_Right)) { // different, worth swapping
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }

    _Ty1 first; // the first stored value
    _Ty2 second; // the second stored value
};




#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

template <class _Ty1, class _Ty2, class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>>
void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
    noexcept(noexcept(_Left.swap(_Right))) { // swap _Left and _Right pairs
    _Left.swap(_Right);
}

template <class _Ty1, class _Ty2>
 constexpr bool operator==(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { // test for pair equality
    return _Left.first == _Right.first && _Left.second == _Right.second;
}

template <class _Ty1, class _Ty2>
 constexpr bool operator!=(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { // test for pair inequality
    return !(_Left == _Right);
}

template <class _Ty1, class _Ty2>
 constexpr bool operator<(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { // test if _Left < _Right for pairs
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}

template <class _Ty1, class _Ty2>
 constexpr bool operator>(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { // test if _Left > _Right for pairs
    return _Right < _Left;
}

template <class _Ty1, class _Ty2>
 constexpr bool operator<=(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { // test if _Left <= _Right for pairs
    return !(_Right < _Left);
}

template <class _Ty1, class _Ty2>
 constexpr bool operator>=(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { // test if _Left >= _Right for pairs
    return !(_Left < _Right);
}

// ALIAS TEMPLATE _Unrefwrap_t
template <class _Ty>
struct _Unrefwrap_helper { // leave unchanged if not a reference_wrapper
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { // make a reference from a reference_wrapper
    using type = _Ty&;
};

// decay, then unwrap a reference_wrapper
template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

// FUNCTION TEMPLATE make_pair
template <class _Ty1, class _Ty2>
 constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
    noexcept(is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&& is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) { // strengthened
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
    // return pair composed from arguments
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace rel_ops { // nested namespace to hide relational operators from std
    template <class _Ty>
     bool operator!=(const _Ty& _Left, const _Ty& _Right) { // test for inequality, in terms of equality
        return !(_Left == _Right);
    }

    template <class _Ty>
     bool operator>(const _Ty& _Left, const _Ty& _Right) { // test if _Left > _Right, in terms of operator<
        return _Right < _Left;
    }

    template <class _Ty>
     bool operator<=(const _Ty& _Left, const _Ty& _Right) { // test if _Left <= _Right, in terms of operator<
        return !(_Right < _Left);
    }

    template <class _Ty>
     bool operator>=(const _Ty& _Left, const _Ty& _Right) { // test if _Left >= _Right, in terms of operator<
        return !(_Left < _Right);
    }
} // namespace rel_ops
}

namespace std {
// STRUCTS FOR STRUCTURED BINDINGS tuple_size AND tuple_element
template <class _Tuple>
struct tuple_size;

template <class _Tuple, class = void>
struct _Tuple_size_sfinae { // selected when tuple_size<_Tuple>::value isn't well-formed
};

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> { // selected when tuple_size<_Tuple>::value is well-formed
};

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> { // size of const tuple
};

template <class _Tuple>
struct tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> { // size of volatile tuple
};

template <class _Tuple>
struct tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> { // size of const volatile tuple
};

template <class _Ty>
 constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

template <size_t _Index, class _Tuple>
struct tuple_element;

template <size_t _Index, class _Tuple>
struct tuple_element<_Index, const _Tuple> : public tuple_element<_Index, _Tuple> { // tuple_element for const
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct tuple_element<_Index, volatile _Tuple> : public tuple_element<_Index, _Tuple> { // tuple_element for volatile
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct tuple_element<_Index, const volatile _Tuple>
    : public tuple_element<_Index, _Tuple> { // tuple_element for const volatile
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

// TUPLE INTERFACE TO array
template <class _Ty, size_t _Size>
class array;

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>>
    : integral_constant<size_t, _Size> { // struct to determine number of elements in array
};

template <size_t _Idx, class _Ty, size_t _Size>
struct tuple_element<_Idx, array<_Ty, _Size>> { // struct to determine type of element _Idx in array
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};


// TUPLE INTERFACE TO tuple
template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> { // size of tuple
};

template <size_t _Index>
struct tuple_element<_Index, tuple<>> { // enforce bounds checking
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct tuple_element<0, tuple<_This, _Rest...>> { // select first element
    using type   = _This;
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct tuple_element<_Index, tuple<_This, _Rest...>>
    : public tuple_element<_Index - 1, tuple<_Rest...>> { // recursive tuple_element definition
};

// TUPLE INTERFACE TO pair
template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> { // size of pair
};

template <size_t _Idx, class _Ty1, class _Ty2>
struct tuple_element<_Idx, pair<_Ty1, _Ty2>> { // struct to determine type of element _Idx in pair
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 0>) noexcept { // get reference to element 0 in pair _Pr
    return _Pr.first;
}

template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 1>) noexcept { // get reference to element 1 in pair _Pr
    return _Pr.second;
}

template <size_t _Idx, class _Ty1, class _Ty2>
 constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    pair<_Ty1, _Ty2>& _Pr) noexcept { // get reference to element at _Idx in pair _Pr
    using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>());
}

template <class _Ty1, class _Ty2>
 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept { // get reference to element _Ty1 in pair _Pr
    return ::std:: get<0>(_Pr);
}

template <class _Ty2, class _Ty1>
 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept { // get reference to element _Ty2 in pair _Pr
    return ::std:: get<1>(_Pr);
}

template <size_t _Idx, class _Ty1, class _Ty2>
 constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { // get const reference to element at _Idx in pair _Pr
    using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>());
}

template <class _Ty1, class _Ty2>
 constexpr const _Ty1& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { // get const reference to element _Ty1 in pair _Pr
    return ::std:: get<0>(_Pr);
}

template <class _Ty2, class _Ty1>
 constexpr const _Ty2& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { // get const reference to element _Ty2 in pair _Pr
    return ::std:: get<1>(_Pr);
}

template <size_t _Idx, class _Ty1, class _Ty2>
 constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    pair<_Ty1, _Ty2>&& _Pr) noexcept { // get rvalue reference to element at _Idx in pair _Pr
    using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}

template <class _Ty1, class _Ty2>
 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { // get rvalue reference to element _Ty1 in pair _Pr
    return ::std:: get<0>(::std:: move(_Pr));
}

template <class _Ty2, class _Ty1>
 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { // get rvalue reference to element _Ty2 in pair _Pr
    return ::std:: get<1>(::std:: move(_Pr));
}

template <size_t _Idx, class _Ty1, class _Ty2>
 constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { // get const rvalue reference to element at _Idx in pair _Pr
    using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}

template <class _Ty1, class _Ty2>
 constexpr const _Ty1&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { // get const rvalue reference to element _Ty1 in pair _Pr
    return ::std:: get<0>(::std:: move(_Pr));
}

template <class _Ty2, class _Ty1>
 constexpr const _Ty2&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { // get const rvalue reference to element _Ty2 in pair _Pr
    return ::std:: get<1>(::std:: move(_Pr));
}

// FUNCTION TEMPLATE exchange
template <class _Ty, class _Other = _Ty>
_Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

// FUNCTION TEMPLATE as_const
template <class _Ty>
 constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { // view _Val through const lenses
    return _Val;
}

template <class _Ty>
void as_const(const _Ty&&) = delete;





















#line 562 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: get;
    using ::std:: tuple_element;
    using ::std:: tuple_size;
} // namespace tr1
#line 570 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

}



#pragma warning(pop)
#pragma pack(pop)
#line 578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"
#line 579 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\utility"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )





extern "C" {
// The "noalias" attribute tells the compiler optimizer that pointers going into these hand-vectorized algorithms
// won't be stored beyond the lifetime of the function, and that the function will only reference arrays denoted by
// those pointers. The optimizer also assumes in that case that a pointer parameter is not returned to the caller via
// the return value, so functions using "noalias" must usually return void. This attribute is valuable because these
// functions are in native code objects that the compiler cannot analyze. In the absence of the noalias attribute, the
// compiler has to assume that the denoted arrays are "globally address taken", and that any later calls to
// unanalyzable routines may modify those arrays.
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
}
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

namespace std {
// FUNCTION TEMPLATE _Pass_fn
// TRANSITION, VSO#386225
template <class _Fx>
struct _Ref_fn { // pass function object by value as a reference
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { // forward function call operator
        return _Fn(::std:: forward<_Args>(_Vals)...);
    }

    _Fx& _Fn;
};

template <class _Fn>
 constexpr bool
    _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void*)
                               && conjunction_v<is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;

template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0> // TRANSITION, if constexpr
constexpr _Fn _Pass_fn(_Fn _Val) { // pass functor by value
    return _Val;
}

template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val) { // pass functor by "reference"
    return {_Val};
}

// ITERATOR STUFF (from <iterator>)
// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag { // identifying tag for input iterators
};

struct output_iterator_tag { // identifying tag for output iterators
};

struct forward_iterator_tag : input_iterator_tag { // identifying tag for forward iterators
};

struct bidirectional_iterator_tag : forward_iterator_tag { // identifying tag for bidirectional iterators
};

struct random_access_iterator_tag : bidirectional_iterator_tag { // identifying tag for random-access iterators
};

// STRUCT _Unused_parameter
struct _Unused_parameter { // generic unused parameter struct
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

// ALIAS _Any_tag
using _Any_tag = _Unused_parameter; // generic fallback/default/"other" target for tag dispatch

// ALIAS TEMPLATE _Algorithm_int_t
template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;

// STRUCT TEMPLATE iterator_traits
template <class, class = void>
struct _Iterator_traits_base { // empty for non-iterators
};

template <class _Iter>
struct _Iterator_traits_base<_Iter, void_t<typename _Iter::iterator_category, typename _Iter::value_type,
                                        typename _Iter::difference_type, typename _Iter::pointer,
                                        typename _Iter::reference>> { // defined if _Iter::* types exist
    using iterator_category = typename _Iter::iterator_category;
    using value_type        = typename _Iter::value_type;
    using difference_type   = typename _Iter::difference_type;

    using pointer   = typename _Iter::pointer;
    using reference = typename _Iter::reference;
};

template <class _Ty, bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base { // iterator properties for pointers to object
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t<_Ty>;
    using difference_type   = ptrdiff_t;

    using pointer   = _Ty*;
    using reference = _Ty&;
};

template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> { // iterator properties for pointers to non-object
                                                   // not actually iterators, as no arithmetic is possible -> no members
};

template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> { // get traits from iterator _Iter, if possible
};

template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> { // get traits from pointer, if possible
};

// ALIAS TEMPLATE _Iter_ref_t
template <class _Iter>
using _Iter_ref_t = typename iterator_traits<_Iter>::reference;

// ALIAS TEMPLATE _Iter_value_t
template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

// ALIAS TEMPLATE _Iter_diff_t
template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

// ALIAS TEMPLATE _Common_diff_t
template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

// ALIAS TEMPLATE _Iter_cat_t
template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

// VARIABLE TEMPLATE _Is_iterator_v
template <class _Ty, class = void>
 constexpr bool _Is_iterator_v = false;

template <class _Ty>
 constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

// TRAIT _Is_iterator
template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

// VARIABLE TEMPLATE _Is_input_iter_v
template <class _Iter>
 constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

// VARIABLE TEMPLATE _Is_fwd_iter_v
template <class _Iter>
 constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

// VARIABLE TEMPLATE _Is_bidi_iter_v
template <class _Iter>
 constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

// VARIABLE TEMPLATE _Is_random_iter_v
template <class _Iter>
 constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

// STRUCT TEMPLATE _Is_checked_helper
template <class, class = void>
struct _Is_checked_helper { // default definition, no longer used, retained due to pseudo-documentation
};

// FUNCTION TEMPLATE _Adl_verify_range

template <class _Ty>
constexpr void _Verify_range(
    const _Ty* const _First, const _Ty* const _Last) noexcept { // special case range verification for pointers
    do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 192, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"transposed pointer range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 192, 0); } while (false); } ; } while (false);
}
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Iter, class = void>
struct _Allow_inheriting_unwrap : true_type {};

template <class _Iter>
struct _Allow_inheriting_unwrap<_Iter, enable_if_t<!is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>>>
    : false_type {};

template <class _Iter, class _Sentinel = _Iter, class = void>
struct _Range_verifiable : false_type {};

template <class _Iter, class _Sentinel>
struct _Range_verifiable<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>>
    : _Allow_inheriting_unwrap<_Iter>::type {};

template <class _Iter, class _Sentinel = _Iter>
 constexpr bool _Range_verifiable_v = _Range_verifiable<_Iter, _Sentinel>::value;


template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(
    const _Iter& _First, const _Sentinel& _Last) { // check that [_First, _Last) forms an iterator range
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    } else {
        (void) _First; // TRANSITION, VSO#486357
        (void) _Last; // TRANSITION, VSO#486357
    }
}

















#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"


// FUNCTION TEMPLATE _Get_unwrapped
template <class _Iter, class = void>
struct _Unwrappable : false_type {};

template <class _Iter>
struct _Unwrappable<_Iter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<const _Iter&>()._Unwrapped()))>>
    : _Allow_inheriting_unwrap<_Iter>::type {};

template <class _Iter>
 constexpr bool _Unwrappable_v = _Unwrappable<_Iter>::value;

template <class _Iter, enable_if_t<_Unwrappable_v<_Iter>, int> = 0>
 constexpr auto _Get_unwrapped(const _Iter& _It) {
    // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
    return _It._Unwrapped();
}

template <class _Iter, enable_if_t<!_Unwrappable_v<_Iter>, int> = 0>
 constexpr const _Iter& _Get_unwrapped(const _Iter& _It) {
    // (don't) unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
    return _It;
}

template <class _Iter, enable_if_t<!_Unwrappable_v<_Iter>, int> = 0>
 constexpr const _Iter&& _Get_unwrapped(const _Iter&& _It) {
    // (don't) unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
    return static_cast<const _Iter&&>(_It);
}

template <class _Ty>
 constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { // special case already-unwrapped pointers
    return _Ptr;
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<const _Iter&>()))>;

// FUNCTION TEMPLATE _Get_unwrapped_unverified
template <class _Iter, class = bool>
struct _Do_unwrap_when_unverified : false_type {};

template <class _Iter>
struct _Do_unwrap_when_unverified<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))>
    : bool_constant<static_cast<bool>(_Iter::_Unwrap_when_unverified)> {};

template <class _Iter>
 constexpr bool _Do_unwrap_when_unverified_v = _Do_unwrap_when_unverified<_Iter>::value;

template <class _Iter>
 constexpr bool _Unwrappable_for_unverified_v = _Unwrappable_v<_Iter>&& _Do_unwrap_when_unverified_v<_Iter>;

template <class _Iter, enable_if_t<_Unwrappable_for_unverified_v<_Iter>, int> = 0>
 constexpr auto _Get_unwrapped_unverified(const _Iter& _It) {
    // unwrap an iterator not previously subjected to _Adl_verify_range
    return _It._Unwrapped();
}

template <class _Iter, enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0>
 constexpr const _Iter& _Get_unwrapped_unverified(const _Iter& _It) {
    // (don't) unwrap an iterator not previously subjected to _Adl_verify_range
    return _It;
}

template <class _Iter, enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0>
 constexpr const _Iter&& _Get_unwrapped_unverified(const _Iter&& _It) {
    // (don't) unwrap an iterator not previously subjected to _Adl_verify_range
    return static_cast<const _Iter&&>(_It);
}

template <class _Ty>
 constexpr _Ty* _Get_unwrapped_unverified(_Ty* const _Ptr) { // special case already-unwrapped pointers
    return _Ptr;
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<const _Iter&>()))>;

// FUNCTION TEMPLATE _Get_unwrapped_n
struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
 constexpr _Diff _Max_possible_v = static_cast<_Diff>(static_cast<make_unsigned_t<_Diff>>(-1) >> 1);

template <class _Diff>
 constexpr _Diff _Min_possible_v = -_Max_possible_v<_Diff> - 1;

template <class _Iter, class = void>
struct _Offset_verifiable : false_type {};

template <class _Iter>
struct _Offset_verifiable<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>>
    : true_type {};

template <class _Iter>
 constexpr bool _Offset_verifiable_v = _Offset_verifiable<_Iter>::value;

template <class _Iter>
 constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter>&& _Offset_verifiable_v<_Iter>;

template <class _Iter, class _Diff, enable_if_t<_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>, int> = 0>
 constexpr auto _Get_unwrapped_n(const _Iter& _It, const _Diff _Off) {
    // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
    using _IDiff     = _Iter_diff_t<_Iter>;
    using _CDiff     = common_type_t<_Diff, _IDiff>;
    const auto _COff = static_cast<_CDiff>(_Off);

    do { if (_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>) && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 357, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 357, 0); } while (false); } ; } while (false);
#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
    (void) _COff;

    _It._Verify_offset(static_cast<_IDiff>(_Off));
    return _It._Unwrapped();
}

template <class _Iter, class _Diff,
    enable_if_t<
        _Unwrappable_for_unverified_v<_Iter> //
            && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, _Distance_unknown>),
        int> = 0>
 constexpr auto _Get_unwrapped_n(const _Iter& _It, _Diff) {
    // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
    return _It._Unwrapped();
}

template <class _Iter, class _Diff,
    enable_if_t<
        !_Unwrappable_for_unverified_v<_Iter> //
            && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, _Distance_unknown>),
        int> = 0>
 constexpr const _Iter& _Get_unwrapped_n(const _Iter& _It, _Diff) {
    // pass through lvalue iterator that doesn't participate in checking
    return _It;
}

template <class _Iter, class _Diff,
    enable_if_t<
        !_Unwrappable_for_unverified_v<_Iter> //
            && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, _Distance_unknown>),
        int> = 0>
 constexpr const _Iter&& _Get_unwrapped_n(const _Iter&& _It, _Diff) {
    // pass through rvalue iterator that doesn't participate in checking
    return static_cast<const _Iter&&>(_It);
}

template <class _Ty, class _Diff, enable_if_t<is_same_v<_Diff, _Distance_unknown> || is_integral_v<_Diff>, int> = 0>
 constexpr _Ty* _Get_unwrapped_n(_Ty* const _Src, _Diff) {
    return _Src;
}

template <class _Iter>
using _Unwrapped_n_t = _Remove_cvref_t<decltype(_Get_unwrapped_n(::std:: declval<const _Iter&>(), _Iter_diff_t<_Iter>{}))>;

// FUNCTION TEMPLATE _Seek_wrapped
template <class _Iter, class _UIter, class = void>
struct _Wrapped_seekable : false_type {};

template <class _Iter, class _UIter>
struct _Wrapped_seekable<_Iter, _UIter,
    void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<const _UIter&>()))>> : true_type {};

template <class _Iter, class _UIter>
 constexpr bool _Wrapped_seekable_v = _Wrapped_seekable<_Iter, _UIter>::value;


template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, const _UIter& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(_UIt);
    } else {
        _It = _UIt;
    }
}










#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Ty>
constexpr void _Seek_wrapped(_Ty*& _It, _Ty* const _UIt) {
    _It = _UIt;
}








































#line 479 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE _Idl_distance

template <class _Checked, class _Iter>
auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    // tries to get the distance between _First and _Last if they are random-access iterators
    if constexpr (_Is_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        (void) _First; // TRANSITION, VSO#486357
        (void) _Last; // TRANSITION, VSO#486357
        return _Distance_unknown{};
    }
}


















#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"


// STRUCT TEMPLATE _Unwrap_enum AND ALIAS
template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { // if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { // passthrough non-enum type
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;

// ALGORITHM DISPATCH TRAITS
template <class>
class move_iterator;

template <class _Source, class _Dest>
struct _Ptr_cat_helper { // determines _Ptr_cat's result in the most general case
    using _USource                        = _Unwrap_enum_t<_Source>;
    using _UDest                          = _Unwrap_enum_t<_Dest>;
    static constexpr bool _Really_trivial = conjunction_v<
        bool_constant<sizeof(_USource) == sizeof(_UDest) && is_same_v<bool, _USource> == is_same_v<bool, _UDest>>,
        is_integral<_USource>, is_integral<_UDest>>;
    static constexpr bool _Trivially_copyable = _Really_trivial;
};

template <class _Elem>
struct _Ptr_cat_helper<_Elem, _Elem> { // determines _Ptr_cat's result when the types are the same
    static constexpr bool _Really_trivial     = is_trivial_v<_Elem>;
    static constexpr bool _Trivially_copyable = is_trivially_copyable_v<_Elem>;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, const _Anything*> {
    // determines _Ptr_cat's result when all we do is add const to a pointer
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, volatile _Anything*> {
    // determines _Ptr_cat's result when all we do is add volatile to a pointer
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, const volatile _Anything*> {
    // determines _Ptr_cat's result when all we do is add cv to a pointer
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

struct _False_copy_cat {
    static constexpr bool _Really_trivial     = false;
    static constexpr bool _Trivially_copyable = false;
};

template <class _Source, class _Dest>
struct _Ptr_copy_cat : _False_copy_cat {}; // return pointer copy optimization category for arbitrary iterators

template <class _Source, class _Dest>
struct _Ptr_copy_cat<_Source*, _Dest*>
    : conditional_t<is_trivially_assignable_v<_Dest&, _Source&>,
          _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>, _False_copy_cat> {
}; // return pointer copy optimization category for pointers

template <class _Source, class _Dest>
struct _Ptr_copy_cat<move_iterator<_Source*>, _Dest*> : _Ptr_copy_cat<_Source*, _Dest*> {
}; // return pointer copy optimization category for move iterators

template <class _Source, class _Dest>
struct _Ptr_move_cat : _False_copy_cat {}; // return pointer move optimization category for arbitrary iterators

template <class _Source, class _Dest>
struct _Ptr_move_cat<_Source*, _Dest*>
    : conditional_t<is_trivially_assignable_v<_Dest&, _Source>,
          _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>, _False_copy_cat> {
}; // return pointer move optimization category for pointers

template <class _Source, class _Dest>
struct _Ptr_move_cat<move_iterator<_Source*>, _Dest*> : _Ptr_move_cat<_Source*, _Dest*> {
}; // return pointer move optimization category for move iterators

// DEBUG TESTING MACROS






#line 608 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"





// FUNCTION TEMPLATE _Debug_lt_pred
template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right)
    noexcept(noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left))) {
    // test if _Pred(_Left, _Right) and _Pred is strict weak ordering, when the arguments are the cv-same-type
    const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
    if (_Result) {
        do { if (!_Pred(_Right, _Left)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 621, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 621, 0); } while (false); } ; } while (false);
    }

    return _Result;
}

template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<!is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(noexcept(_Pred(_Left, _Right))) {
    // test if _Pred(_Left, _Right); no debug checks as the types differ
    return static_cast<bool>(_Pred(_Left, _Right));
}

// FUNCTION TEMPLATE _Debug_order_unchecked

template <class _InIt, class _Sentinel, class _Pr>
void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred) {
    // test if range is ordered by predicate
    if constexpr (_Is_fwd_iter_v<_InIt>) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                do { if (!static_cast<bool>(_Pred(*_Next, *_First))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 642, 0, "%s", "sequence not ordered")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"sequence not ordered\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 642, 0); } while (false); } ; } while (false);
            }
        }
    } else {
        (void) _First; // TRANSITION, VSO#486357
        (void) _Last; // TRANSITION, VSO#486357
        (void) _Pred; // TRANSITION, VSO#486357
    }
}





















#line 673 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE _Debug_order_set_unchecked

template <class _OtherIt, class _InIt, class _Pr>
void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred) {
    // test if range is ordered by predicate
    if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>> && _Is_fwd_iter_v<_InIt>) {
        _Debug_order_unchecked(_First, _Last, _Pred);
    } else {
        (void) _First; // TRANSITION, VSO#486357
        (void) _Last; // TRANSITION, VSO#486357
        (void) _Pred; // TRANSITION, VSO#486357
    }
}


























#line 714 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
#line 715 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// MORE ITERATOR STUFF (from <iterator>)
// FUNCTION TEMPLATE advance

template <class _InIt, class _Diff>
inline void advance(_InIt& _Where, _Diff _Off) { // increment iterator by offset
    if constexpr (_Is_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff>) {
            if constexpr (_Is_bidi_iter_v<_InIt>) {
                for (; _Off < 0; ++_Off) {
                    --_Where;
                }
            } else {
                do { if (_Off >= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 730, 0, "%s", "negative advance of non-bidirectional iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"negative advance of non-bidirectional iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 730, 0); } while (false); } ; } while (false);
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_Where;
        }
    }
}





































#line 777 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE distance

template <class _InIt>
 inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) { // return distance between iterators
    if constexpr (_Is_random_iter_v<_InIt>) {
        return _Last - _First; // assume the iterator will do debug checking
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

























#line 822 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE _Next_iter
template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { // increment iterator
    return ++_First;
}

// FUNCTION TEMPLATE next
template <class _InIt>
 inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { // increment iterator
    static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

// FUNCTION TEMPLATE _Prev_iter
template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { // decrement iterator
    return --_First;
}

// FUNCTION TEMPLATE prev
template <class _BidIt>
 inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { // decrement iterator
    static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

// CLASS TEMPLATE reverse_iterator
template <class _Ty>
struct pointer_traits;

template <class _Iterator>
constexpr _Iterator _Operator_arrow(_Iterator _Target, true_type) { // return operator-> where _Iterator is a pointer
    return _Target;
}

template <class _Iterator>
constexpr decltype(auto) _Operator_arrow(_Iterator&& _Target, false_type) {
    // return operator-> where _Iterator is a class type
    return ::std:: forward<_Iterator>(_Target).operator->();
}

template <class _BidIt>
class reverse_iterator { // wrap iterator to run it backwards
public:
    using iterator_category = typename iterator_traits<_BidIt>::iterator_category;
    using value_type        = typename iterator_traits<_BidIt>::value_type;
    using difference_type   = typename iterator_traits<_BidIt>::difference_type;
    using pointer           = typename iterator_traits<_BidIt>::pointer;
    using reference         = typename iterator_traits<_BidIt>::reference;

    using iterator_type = _BidIt;

    inline reverse_iterator() : current() {}

    inline explicit reverse_iterator(_BidIt _Right) : current(_Right) {}

    template <class _Other>
    inline reverse_iterator(const reverse_iterator<_Other>& _Right) : current(_Right.base()) {}

    template <class _Other>
    inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) {

        current = _Right.base();
        return *this;
    }

     inline _BidIt base() const {
        return current;
    }

     inline reference operator*() const {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

     inline pointer operator->() const {
        _BidIt _Tmp = current;
        --_Tmp;
        return _Operator_arrow(_Tmp, is_pointer<_BidIt>());
    }

    inline reverse_iterator& operator++() {
        --current;
        return *this;
    }

    inline reverse_iterator operator++(int) {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    inline reverse_iterator& operator--() {
        ++current;
        return *this;
    }

    inline reverse_iterator operator--(int) {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    // N.B. functions valid for random-access iterators only beyond this point

    inline reverse_iterator& operator+=(const difference_type _Off) {
        current -= _Off;
        return *this;
    }

     inline reverse_iterator operator+(const difference_type _Off) const {
        return reverse_iterator(current - _Off);
    }

    inline reverse_iterator& operator-=(const difference_type _Off) {
        current += _Off;
        return *this;
    }

     inline reverse_iterator operator-(const difference_type _Off) const {
        return reverse_iterator(current + _Off);
    }

     inline reference operator[](const difference_type _Off) const {
        return current[static_cast<difference_type>(-_Off - 1)];
    }

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 958, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 958, 0); } while (false); } ; } while (false);
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
     constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() const {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(current._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, _Src>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) {
        current._Seek_to(_It.base());
    }

protected:
    _BidIt current; // the wrapped iterator
};

template <class _BidIt, class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
constexpr void _Verify_range(const reverse_iterator<_BidIt>& _First, const reverse_iterator<_BidIt2>& _Last) {
    // TRANSITION, VSO#612785
    _Verify_range(_Last.base(), _First.base()); // note reversed parameters
}

template <class _BidIt>
 inline reverse_iterator<_BidIt> operator+(
    typename reverse_iterator<_BidIt>::difference_type _Off, const reverse_iterator<_BidIt>& _Right) {
    return _Right + _Off;
}

template <class _BidIt1, class _BidIt2>
 inline auto operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    -> decltype(_Right.base() - _Left.base()) {
    return _Right.base() - _Left.base();
}

template <class _BidIt1, class _BidIt2>
 inline bool operator==(
    const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) {
    return _Left.base() == _Right.base();
}

template <class _BidIt1, class _BidIt2>
 inline bool operator!=(
    const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) {
    return !(_Left == _Right);
}

template <class _BidIt1, class _BidIt2>
 inline bool operator<(
    const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) {
    return _Right.base() < _Left.base();
}

template <class _BidIt1, class _BidIt2>
 inline bool operator>(
    const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) {
    return _Right < _Left;
}

template <class _BidIt1, class _BidIt2>
 inline bool operator<=(
    const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) {
    return !(_Right < _Left);
}

template <class _BidIt1, class _BidIt2>
 inline bool operator>=(
    const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) {
    return !(_Left < _Right);
}

// FUNCTION TEMPLATE make_reverse_iterator
template <class _BidIt>
 inline reverse_iterator<_BidIt> make_reverse_iterator(
    _BidIt _Iter) { // make reverse_iterator from iterator
    return reverse_iterator<_BidIt>(_Iter);
}

// FUNCTION TEMPLATES begin AND end
template <class _Container>
 inline auto begin(_Container& _Cont) -> decltype(_Cont.begin()) { // get beginning of sequence
    return _Cont.begin();
}

template <class _Container>
 inline auto begin(const _Container& _Cont) -> decltype(_Cont.begin()) { // get beginning of sequence
    return _Cont.begin();
}

template <class _Container>
 inline auto end(_Container& _Cont) -> decltype(_Cont.end()) { // get end of sequence
    return _Cont.end();
}

template <class _Container>
 inline auto end(const _Container& _Cont) -> decltype(_Cont.end()) { // get end of sequence
    return _Cont.end();
}

template <class _Ty, size_t _Size>
 constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept { // get beginning of array
    return _Array;
}

template <class _Ty, size_t _Size>
 constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept { // get end of array
    return _Array + _Size;
}

// FUNCTION TEMPLATES cbegin AND cend
template <class _Container>
 constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) { // get beginning of sequence
    return ::std:: begin(_Cont);
}

template <class _Container>
 constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) { // get end of sequence
    return ::std:: end(_Cont);
}

// FUNCTION TEMPLATES rbegin AND rend
template <class _Container>
 inline auto rbegin(_Container& _Cont)
    -> decltype(_Cont.rbegin()) { // get beginning of reversed sequence
    return _Cont.rbegin();
}

template <class _Container>
 inline auto rbegin(const _Container& _Cont)
    -> decltype(_Cont.rbegin()) { // get beginning of reversed sequence
    return _Cont.rbegin();
}

template <class _Container>
 inline auto rend(_Container& _Cont) -> decltype(_Cont.rend()) { // get end of reversed sequence
    return _Cont.rend();
}

template <class _Container>
 inline auto rend(const _Container& _Cont) -> decltype(_Cont.rend()) { // get end of reversed sequence
    return _Cont.rend();
}

template <class _Ty, size_t _Size>
 inline reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) { // get beginning of reversed array
    return reverse_iterator<_Ty*>(_Array + _Size);
}

template <class _Ty, size_t _Size>
 inline reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) { // get end of reversed array
    return reverse_iterator<_Ty*>(_Array);
}

template <class _Elem>
 inline reverse_iterator<const _Elem*> rbegin(
    initializer_list<_Elem> _Ilist) { // get beginning of reversed sequence
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

template <class _Elem>
 inline reverse_iterator<const _Elem*> rend(
    initializer_list<_Elem> _Ilist) { // get end of reversed sequence
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

// FUNCTION TEMPLATES crbegin AND crend
template <class _Container>
 inline auto crbegin(const _Container& _Cont)
    -> decltype(::std:: rbegin(_Cont)) { // get beginning of reversed sequence
    return ::std:: rbegin(_Cont);
}

template <class _Container>
 inline auto crend(const _Container& _Cont)
    -> decltype(::std:: rend(_Cont)) { // get end of reversed sequence
    return ::std:: rend(_Cont);
}


template <class _Container>
 constexpr auto size(const _Container& _Cont) -> decltype(_Cont.size()) { // get size() for container
    return _Cont.size();
}

template <class _Ty, size_t _Size>
 constexpr size_t size(const _Ty (&)[_Size]) noexcept { // get dimension for array
    return _Size;
}

template <class _Container>
 constexpr auto empty(const _Container& _Cont) -> decltype(_Cont.empty()) { // get empty() for container
    return _Cont.empty();
}

template <class _Ty, size_t _Size>
 constexpr bool empty(const _Ty (&)[_Size]) noexcept { // get dimension==0 for array (can't happen)
    return false;
}

template <class _Elem>
 constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept { // get dimension==0 for initializer_list
    return _Ilist.size() == 0;
}

template <class _Container>
 constexpr auto data(_Container& _Cont) -> decltype(_Cont.data()) { // get data() for container
    return _Cont.data();
}

template <class _Container>
 constexpr auto data(const _Container& _Cont)
    -> decltype(_Cont.data()) { // get pointer to data of const container
    return _Cont.data();
}

template <class _Ty, size_t _Size>
 constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept { // get pointer to data of array
    return _Array;
}

template <class _Elem>
 constexpr const _Elem* data(
    initializer_list<_Elem> _Ilist) noexcept { // get pointer to data of initializer_list
    return _Ilist.begin();
}

// MACRO _STL_VERIFY_ARRAY_SIZE




struct _Container_proxy;
struct _Iterator_base12;

// CLASS TEMPLATE _Array_const_iterator

struct _Iterator_base12_compatible { // TRANSITION, for binary compatibility
    _Container_proxy* _Myproxy{};
    _Iterator_base12* _Mynextiter{};
};
#line 1204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Ty, size_t _Size>
class _Array_const_iterator

    : private _Iterator_base12_compatible
#line 1210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
{ // iterator for nonmutable array
public:
    using iterator_category = random_access_iterator_tag;

    using value_type      = _Ty;
    using difference_type = ptrdiff_t;
    using pointer         = const _Ty*;
    using reference       = const _Ty&;
    enum { _EEN_SIZE = _Size }; // helper for expression evaluator







































































































#line 1323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
    inline _Array_const_iterator() : _Ptr(), _Idx(0) { // construct with null pointer
    }

    inline explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0) : _Ptr(_Parg), _Idx(_Off) {}

     inline reference operator*() const {
        return *operator->();
    }

     inline pointer operator->() const {
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1333, 0, "%s", "cannot dereference value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1333, 0); } while (false); } ; } while (false);
        do { if (_Idx < _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1334, 0, "%s", "cannot dereference out of range array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference out of range array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1334, 0); } while (false); } ; } while (false);
        return _Ptr + _Idx;
    }

    inline _Array_const_iterator& operator++() {
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1339, 0, "%s", "cannot increment value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1339, 0); } while (false); } ; } while (false);
        do { if (_Idx < _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1340, 0, "%s", "cannot increment array iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment array iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1340, 0); } while (false); } ; } while (false);
        ++_Idx;
        return *this;
    }

    inline _Array_const_iterator operator++(int) {
        _Array_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    inline _Array_const_iterator& operator--() {
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1352, 0, "%s", "cannot decrement value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1352, 0); } while (false); } ; } while (false);
        do { if (_Idx != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1353, 0, "%s", "cannot decrement array iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement array iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1353, 0); } while (false); } ; } while (false);
        --_Idx;
        return *this;
    }

    inline _Array_const_iterator operator--(int) {
        _Array_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const ptrdiff_t _Off) const noexcept {
        if (_Off != 0) {
            do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1366, 0, "%s", "cannot seek value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1366, 0); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Idx >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1371, 0, "%s", "cannot seek array iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek array iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1371, 0); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            do { if (_Size - _Idx >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1375, 0, "%s", "cannot seek array iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek array iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1375, 0); } while (false); } ; } while (false);
        }
    }

    inline _Array_const_iterator& operator+=(const ptrdiff_t _Off) {
        _Verify_offset(_Off);
        _Idx += _Off;
        return *this;
    }

     inline _Array_const_iterator operator+(const ptrdiff_t _Off) const {
        _Array_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    inline _Array_const_iterator& operator-=(const ptrdiff_t _Off) {
        return *this += -_Off;
    }

     inline _Array_const_iterator operator-(const ptrdiff_t _Off) const {
        _Array_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

     inline ptrdiff_t operator-(const _Array_const_iterator& _Right) const {
        _Compat(_Right);
        return static_cast<ptrdiff_t>(_Idx - _Right._Idx);
    }

     inline reference operator[](const ptrdiff_t _Off) const {
        return *(*this + _Off);
    }

     inline bool operator==(const _Array_const_iterator& _Right) const {
        _Compat(_Right);
        return _Idx == _Right._Idx;
    }

     inline bool operator!=(const _Array_const_iterator& _Right) const {
        return !(*this == _Right);
    }

     inline bool operator<(const _Array_const_iterator& _Right) const {
        _Compat(_Right);
        return _Idx < _Right._Idx;
    }

     inline bool operator>(const _Array_const_iterator& _Right) const {
        return _Right < *this;
    }

     inline bool operator<=(const _Array_const_iterator& _Right) const {
        return !(_Right < *this);
    }

     inline bool operator>=(const _Array_const_iterator& _Right) const {
        return !(*this < _Right);
    }

    inline void _Compat(const _Array_const_iterator& _Right) const { // test for compatible iterator pair
        do { if (_Ptr == _Right._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1435, 0, "%s", "array iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1435, 0); } while (false); } ; } while (false);
    }

    using _Prevent_inheriting_unwrap = _Array_const_iterator;

     constexpr pointer _Unwrapped() const {
        return _Ptr + _Idx;
    }

    constexpr void _Verify_with(const _Array_const_iterator& _Last) const noexcept {
        // note _Compat check inside operator<=
        do { if (*this <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1446, 0, "%s", "array iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1446, 0); } while (false); } ; } while (false);
    }

    constexpr void _Seek_to(pointer _It) {
        _Idx = static_cast<size_t>(_It - _Ptr);
    }

private:
    pointer _Ptr; // beginning of array
    size_t _Idx; // offset into array
#line 1457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
};


template <class _Ty, size_t _Size>
constexpr void _Verify_range(
    const _Array_const_iterator<_Ty, _Size>& _First, const _Array_const_iterator<_Ty, _Size>& _Last) noexcept {
    // TRANSITION, VSO#612785
    _First._Verify_with(_Last);
}
#line 1467 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Ty, size_t _Size>
 inline _Array_const_iterator<_Ty, _Size> operator+(
    ptrdiff_t _Off, _Array_const_iterator<_Ty, _Size> _Next) {
    return _Next += _Off;
}

// CLASS TEMPLATE _Array_iterator
template <class _Ty, size_t _Size>
class _Array_iterator : public _Array_const_iterator<_Ty, _Size> { // iterator for mutable array
public:
    using _Mybase           = _Array_const_iterator<_Ty, _Size>;
    using iterator_category = random_access_iterator_tag;

    using value_type      = _Ty;
    using difference_type = ptrdiff_t;
    using pointer         = _Ty*;
    using reference       = _Ty&;

    inline _Array_iterator() { // construct with null pointer
    }

    inline explicit _Array_iterator(pointer _Parg, size_t _Off = 0) : _Mybase(_Parg, _Off) {}

    enum { _EEN_SIZE = _Size }; // helper for expression evaluator

     inline reference operator*() const {
        return const_cast<reference>(_Mybase::operator*());
    }

     inline pointer operator->() const {
        return const_cast<pointer>(_Mybase::operator->());
    }

    inline _Array_iterator& operator++() {
        _Mybase::operator++();
        return *this;
    }

    inline _Array_iterator operator++(int) {
        _Array_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Array_iterator& operator--() {
        _Mybase::operator--();
        return *this;
    }

    inline _Array_iterator operator--(int) {
        _Array_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Array_iterator& operator+=(const ptrdiff_t _Off) {
        _Mybase::operator+=(_Off);
        return *this;
    }

     inline _Array_iterator operator+(const ptrdiff_t _Off) const {
        _Array_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    inline _Array_iterator& operator-=(const ptrdiff_t _Off) {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

     inline _Array_iterator operator-(const ptrdiff_t _Off) const {
        _Array_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

     inline reference operator[](const ptrdiff_t _Off) const {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Array_iterator;

     constexpr pointer _Unwrapped() const {
        return const_cast<pointer>(_Mybase::_Unwrapped());
    }
};

template <class _Ty, size_t _Size>
 inline _Array_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_iterator<_Ty, _Size> _Next) {
    return _Next += _Off;
}

// STRUCT _Default_sentinel
struct _Default_sentinel {}; // empty struct to serve as the end of a range

// CLASS TEMPLATE move_iterator
template <class _Iter>
class move_iterator { // wrap iterator to move rvalues
public:
    using iterator_category = typename iterator_traits<_Iter>::iterator_category;
    using value_type        = typename iterator_traits<_Iter>::value_type;
    using difference_type   = typename iterator_traits<_Iter>::difference_type;
    using pointer           = _Iter;
    using _Ref0             = typename iterator_traits<_Iter>::reference;
    using reference         = conditional_t<is_reference_v<_Ref0>, remove_reference_t<_Ref0>&&, _Ref0>;
    using iterator_type     = _Iter;

    inline move_iterator() : current() {}

    inline explicit move_iterator(iterator_type _Right)
        : current(_Right) { // construct wrapped iterator from _Right
    }

    template <class _Iter2>
    inline move_iterator(const move_iterator<_Iter2>& _Right) : current(_Right.base()) {}

    template <class _Iter2>
    inline move_iterator& operator=(const move_iterator<_Iter2>& _Right) {
        current = _Right.base();
        return *this;
    }

     inline _Iter base() const {
        return current;
    }

     inline reference operator*() const {
        return static_cast<reference>(*current);
    }

     inline pointer operator->() const {
        return current;
    }

    inline move_iterator& operator++() {
        ++current;
        return *this;
    }

    inline move_iterator operator++(int) {
        move_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    inline move_iterator& operator--() {
        --current;
        return *this;
    }

    inline move_iterator operator--(int) {
        move_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
     auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
     auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return current != _Sentinel;
    }

    // N.B. functions valid for random-access iterators only beyond this point

    inline move_iterator& operator+=(const difference_type _Off) {
        current += _Off;
        return *this;
    }

     inline move_iterator operator+(const difference_type _Off) const {
        return move_iterator(current + _Off);
    }

    inline move_iterator& operator-=(const difference_type _Off) {
        current -= _Off;
        return *this;
    }

     inline move_iterator operator-(const difference_type _Off) const {
        return move_iterator(current - _Off);
    }

     inline reference operator[](const difference_type _Off) const {
        return ::std:: move(current[_Off]);
    }

    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) {
        _Verify_range(_First.base(), _Last.base());
    }

    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
     constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() const {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(current._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) {
        current._Seek_to(_It.base());
    }

protected:
    iterator_type current; // the wrapped iterator
};

template <class _Iter>
 inline move_iterator<_Iter> operator+(typename move_iterator<_Iter>::difference_type _Off,
    const move_iterator<_Iter>& _Right) { // return move_iterator + integer
    return _Right + _Off;
}

template <class _Iter1, class _Iter2>
 inline auto operator-(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

template <class _Iter1, class _Iter2>
 inline bool operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return _Left.base() == _Right.base();
}

template <class _Iter1, class _Iter2>
 inline bool operator!=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return !(_Left == _Right);
}

template <class _Iter1, class _Iter2>
 inline bool operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return _Left.base() < _Right.base();
}

template <class _Iter1, class _Iter2>
 inline bool operator>(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return _Right < _Left;
}

template <class _Iter1, class _Iter2>
 inline bool operator<=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return !(_Right < _Left);
}

template <class _Iter1, class _Iter2>
 inline bool operator>=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return !(_Left < _Right);
}

// FUNCTION TEMPLATE make_move_iterator
template <class _Iter>
 inline move_iterator<_Iter> make_move_iterator(_Iter _It) { // make move_iterator from iterator
    return move_iterator<_Iter>(_It);
}

// FUNCTION TEMPLATE copy
template <class _InIt, class _OutIt>
_OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) { // implement copy-like function as memmove
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    return reinterpret_cast<_OutIt>(_Dest_ch + _Count);
}

template <class _InIt, class _OutIt>
_OutIt _Copy_memmove(move_iterator<_InIt> _First, move_iterator<_InIt> _Last, _OutIt _Dest) {
    return _Copy_memmove(_First.base(), _Last.base(), _Dest);
}


template <class _InIt, class _OutIt>
_OutIt _Copy_unchecked(
    _InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
                                               // note: _Copy_unchecked is called directly from elsewhere in the STL
    if constexpr (_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable) {
        return _Copy_memmove(_First, _Last, _Dest);
    } else {
        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = *_First;
        }

        return _Dest;
    }
}























#line 1792 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _InIt, class _OutIt>
_OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


template <class _InIt, class _DestTy, size_t _DestSize>
_DestTy* copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize]) { // copy [_First, _Last) to [_Dest, ...)
    return ::std:: copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped();
}
#line 1809 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"




















#line 1830 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE copy_n
// TRANSITION: _Copy_n_unchecked, _Copy_n_unchecked1, _Copy_n_unchecked2, and _Copy_n_unchecked3 are ABI zombie names

template <class _InIt, class _Diff, class _OutIt>
_OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) { // copy [_First, _First + _Count) to [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Trivially_copyable) {
            _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
        } else {
            for (;;) {
                *_UDest = *_UFirst;
                ++_UDest;
                --_Count;
                if (_Count == 0) { // note that we avoid an extra ++_First here to allow istream_iterator to work,
                                   // see LWG#2471
                    break;
                }

                ++_UFirst;
            }
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}







































#line 1901 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"


template <class _SourceTy, size_t _SourceSize, class _Diff, class _OutIt>
_OutIt copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _OutIt _Dest) {
    // copy [_First, _First + _Count) to [_Dest, ...), array source
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1908, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1908, 0); } while (false); } ; } while (false);
        _Seek_wrapped(_Dest, ::std:: copy_n(static_cast<_SourceTy*>(_First), _Count, _Get_unwrapped_n(_Dest, _Count)));
    }

    return _Dest;
}

template <class _InIt, class _Diff, class _DestTy, size_t _DestSize>
_DestTy* copy_n(_InIt _First, _Diff _Count_raw, _DestTy (&_Dest)[_DestSize]) {
    // copy [_First, _First + _Count) to [_Dest, ...), array dest
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1920, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1920, 0); } while (false); } ; } while (false);
        return ::std:: copy_n(_First, _Count, static_cast<_DestTy*>(_Dest));
    }

    return _Dest;
}

template <class _SourceTy, size_t _SourceSize, class _Diff, class _DestTy, size_t _DestSize>
_DestTy* copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _DestTy (&_Dest)[_DestSize]) {
    // copy [_First, _First + _Count) to [_Dest, ...), array source/dest
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1932, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1932, 0); } while (false); } ; } while (false);
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1933, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 1933, 0); } while (false); } ; } while (false);
        return ::std:: copy_n(static_cast<_SourceTy*>(_First), _Count, static_cast<_DestTy*>(_Dest));
    }

    return _Dest;
}
#line 1940 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"






































#line 1979 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE copy_backward
template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // implement copy_backward-like function as memmove
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    return static_cast<_BidIt2>(:: memmove(_Dest_ch - _Count, _First_ch, _Count));
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}


template <class _BidIt1, class _BidIt2>
_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // copy [_First, _Last) backwards to [..., _Dest)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    if constexpr (_Ptr_copy_cat<decltype(_ULast), decltype(_UDest)>::_Trivially_copyable) {
        _UDest = _Copy_backward_memmove(_UFirst, _ULast, _UDest);
    } else {
        while (_UFirst != _ULast) {
            *--_UDest = *--_ULast;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}



























#line 2043 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"








#line 2052 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE move

template <class _InIt, class _OutIt>
_OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    // move [_First, _Last) to [_Dest, ...)
    // note: _Move_unchecked is called directly from elsewhere in the STL
    if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
        return _Copy_memmove(_First, _Last, _Dest);
    } else {
        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = ::std:: move(*_First);
        }

        return _Dest;
    }
}























#line 2093 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _InIt, class _OutIt>
_OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    // move [_First, _Last) to [_Dest, ...)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


template <class _InIt, class _DestTy, size_t _DestSize>
_DestTy* move(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize]) { // move [_First, _Last) to [_Dest, ...)
    return ::std:: move(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped();
}
#line 2111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"




















#line 2132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE move_backward

template <class _BidIt1, class _BidIt2>
_BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // move [_First, _Last) backwards to [..., _Dest)
    // note: _Move_backward_unchecked is called directly from elsewhere in the STL
    if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
        return _Copy_backward_memmove(_First, _Last, _Dest);
    } else {
        while (_First != _Last) {
            *--_Dest = ::std:: move(*--_Last);
        }

        return _Dest;
    }
}
























#line 2174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _BidIt1, class _BidIt2>
_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) { // move [_First, _Last) backwards to [..., _Dest)
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}








#line 2193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE fill
template <class _Ty>
struct _Is_character : false_type {}; // by default, not a character type

template <>
struct _Is_character<char> : true_type {}; // chars are characters

template <>
struct _Is_character<signed char> : true_type {}; // signed chars are also characters

template <>
struct _Is_character<unsigned char> : true_type {}; // unsigned chars are also characters




#line 2211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Ty>
struct _Is_character_or_byte : _Is_character<_Ty>::type {};




#line 2219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// _Fill_memset_is_safe determines if _FwdIt and _Ty are eligible for memset optimization in fill
// clang-format off
template <class _FwdIt, class _Ty,
    class _Value_type = _Iter_value_t<_FwdIt>,
    class _Raw_ty = _Unwrap_enum_t<_Ty>,
    class _Raw_value_type = _Unwrap_enum_t<_Value_type>>
 constexpr bool _Fill_memset_is_safe =
    conjunction_v<
        is_pointer<_FwdIt>,
        disjunction<
            conjunction<_Is_character_or_byte<_Raw_ty>, _Is_character_or_byte<_Raw_value_type>>,
            conjunction<is_same<bool, _Raw_ty>, is_same<bool, _Raw_value_type>>>,
        is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
// clang-format on


template <class _FwdIt, class _Ty>
void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) { // copy _Val through [_First, _Last)
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<_FwdIt>, _Ty>) {
        :: memset(_UFirst, static_cast<unsigned char>(_Val), static_cast<size_t>(_ULast - _UFirst));
    } else {
        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}





















#line 2271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"









#line 2281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE fill_n
// TRANSITION: _Fill_n_unchecked and _Fill_n_unchecked1 are ABI zombie names

template <class _OutIt, class _Diff, class _Ty>
_OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    // copy _Val _Count times through [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
            :: memset(_UDest, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
            _UDest += _Count;
        } else {
            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}































#line 2337 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"









#line 2347 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE equal
template <class _Elem1, class _Elem2>
struct _Value_equality_is_bitwise_equality : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)> {
    // Tests whether the usual arithmetic conversions will preserve the bit-pattern when promoting to int
    // e.g. short == unsigned short -> false
    //      int == unsigned int -> true
};

template <class _Elem1, class _Elem2, class _Pr>
struct _Equal_memcmp_is_safe_helper : false_type { // determines whether it is safe to call memcmp to compare things;
                                                   // defaults to false
};

template <class _Elem1, class _Elem2>
struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
    : bool_constant<conjunction_v<bool_constant<sizeof(_Elem1) == sizeof(_Elem2)
                                                && _Is_nonbool_integral<_Elem1> && _Is_nonbool_integral<_Elem2>>,
          negation<is_volatile<_Elem1>>, negation<is_volatile<_Elem2>>,
          // note that order matters here, as being integral is a precondition
          // of _Value_equality_is_bitwise_equality
          _Value_equality_is_bitwise_equality<_Elem1, _Elem2>>> { // allow memcmping same-size integral non-bool
                                                                  // non-volatile bitwise types using equal_to<>
};

template <class _Elem1, class _Elem2>
struct _Equal_memcmp_is_safe_helper<_Elem1*, _Elem2*, equal_to<>>
    : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type { // allow memcmping pointers-to-cv-T with equal_to<>
};





#line 2382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Elem>
struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
    : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // treat equal_to with exact T as equal_to<>
                                                                     // this is safe because we only activate the
                                                                     // optimization for builtin _Elem (and std::byte)
};

template <class _Iter1, class _Iter2, class _Pr>
false_type _Equal_memcmp_is_safe(
    const _Iter1&, const _Iter2&, const _Pr&) { // return equal optimization category for arbitrary iterators
    return {};
}

template <class _Obj1, class _Obj2, class _Pr>
typename _Equal_memcmp_is_safe_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _Pr>::type _Equal_memcmp_is_safe(
    _Obj1* const&, _Obj2* const&, const _Pr&) { // return equal optimization category for pointers
    return {};
}


template <class _InIt1, class _InIt2, class _Pr>
 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, ...) using _Pred
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (decltype(_Equal_memcmp_is_safe(_UFirst1, _UFirst2, _Pred))::value) {
        const auto _First1_ch = reinterpret_cast<const char*>(_UFirst1);
        const auto _First2_ch = reinterpret_cast<const char*>(_UFirst2);
        const auto _Count     = static_cast<size_t>(reinterpret_cast<const char*>(_ULast1) - _First1_ch);
        return :: memcmp(_First1_ch, _First2_ch, _Count) == 0;
    } else {
        for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }
        }

        return true;
    }
}





































#line 2463 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"


template <class _InIt1, class _RightTy, size_t _RightSize, class _Pr, enable_if_t<!is_same_v<_RightTy*, _Pr>, int> = 0>
 bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize], _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, ...) using _Pred
    return ::std:: equal(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
}
#line 2471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"


















#line 2490 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _InIt1, class _InIt2>
 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    // compare [_First1, _Last1) to [_First2, ...)
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>());
}


template <class _InIt1, class _RightTy, size_t _RightSize>
 bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize]) {
    // compare [_First1, _Last1) to [_First2, ...)
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>());
}
#line 2504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
















#line 2521 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"


template <class _InIt1, class _InIt2, class _Pr>
 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, _Last2) using _Pred
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}










































#line 2600 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"





#line 2606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _InIt1, class _InIt2>
 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    // compare [_First1, _Last1) to [_First2, _Last2)
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>());
}








#line 2621 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE lexicographical_compare
template <class _Elem1, class _Elem2, class _FTy>
struct _Lex_compare_check_element_types_helper
    : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>,
          is_unsigned<_FTy>>> { // checks the lex_compare element types for memcmp safety for builtin functors (e.g.
                                // less<unsigned char>)
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
    : bool_constant<
          conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>> {
    // checks the lex_compare element types for memcmp safety for transparent functors (e.g. less<>)
};











#line 2648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _Memcmp_pr>
struct _Lex_compare_optimize {}; // optimization tag for lexicographical_compare

template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy>
using _Lex_compare_check_element_types = _Lex_compare_optimize<
    conditional_t<_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
        _Memcmp_pr, void>>; // checks the lex_compare element types for memcmp safety

template <class _InIt1, class _InIt2, class _Pr>
_Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&) {
    // return lex_compare optimization category for arbitrary iterators
    return {};
}

template <class _Obj1, class _Obj2, class _FTy>
_Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(
    _Obj1* const&, _Obj2* const&, const less<_FTy>&) {
    // return lex_compare optimization category for pointer iterators and less<_FTy>
    return {};
}

template <class _Obj1, class _Obj2, class _FTy>
_Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(
    _Obj1* const&, _Obj2* const&, const greater<_FTy>&) {
    // return lex_compare optimization category for pointer iterators and greater<_FTy>
    return {};
}

template <class _InIt1, class _InIt2, class _Pr>
bool _Lex_compare_unchecked(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>) {
    // order [_First1, _Last1) vs. [_First2, _Last2) using _Pred, no special optimization
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) { // something to compare, do it
        if (_Debug_lt_pred(_Pred, *_First1, *_First2)) {
            return true;
        } else if (_Pred(*_First2, *_First1)) {
            return false;
        }
    }

    return _First1 == _Last1 && _First2 != _Last2;
}

template <class _InIt1, class _InIt2, class _Pr, class _Memcmp_pr>
bool _Lex_compare_unchecked(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize<_Memcmp_pr>) {
    // order [_First1, _Last1) vs. [_First2, _Last2) memcmp optimization
    const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
    const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
    const int _Ans   = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
    return _Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
}

template <class _InIt1, class _InIt2, class _Pr>
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    // order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    return _Lex_compare_unchecked(
        _UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred), _Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred));
}

template <class _InIt1, class _InIt2>
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>());
}





















#line 2742 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE find
template <class _Ty>
bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag) { // signed _Elem, signed _Ty
    return (-128) <= _Val && _Val <= 127;
}

template <class _Ty>
bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type) {
    // signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
    return _Val <= 127 || static_cast<_Ty>((-128)) <= _Val;
}

template <class _Ty>
bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type) {
    // signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
    return _Val <= 127;
}

template <class _Ty>
bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag) {
    // unsigned _Elem, signed _Ty
    return 0 <= _Val && _Val <= 0xff;
}

template <class _Ty>
bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag) {
    // unsigned _Elem, unsigned _Ty
    return _Val <= 0xff;
}

template <class _InIt, class _Ty>
bool _Within_limits(_InIt, const _Ty& _Val) { // check whether _Val is within the limits of _Elem
    using _Elem = remove_pointer_t<_InIt>;
    return _Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{}, bool_constant<-1 == static_cast<_Ty>(-1)>{});
}

template <class _InIt>
bool _Within_limits(_InIt, const bool&) { // bools are always within the limits of _Elem
    return true;
}

template <class _InIt, class _Ty>
_InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, true_type) {
    // find first byte matching integral _Val
    if (!_Within_limits(_First, _Val)) {
        return _Last;
    }

    _First =
        static_cast<_InIt>(:: memchr(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
    return _First ? _First : _Last;
}

template <class _InIt, class _Ty>
_InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type) {
    // find first matching _Val
    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty>
_InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    // find first matching _Val; choose optimization
    // activate optimization for pointers to (const) bytes and integral values
    using _Memchr_opt = bool_constant<
        is_integral_v<_Ty> && _Is_any_of_v<_InIt, char*, signed char*, unsigned char*, //
            const char*, const signed char*, const unsigned char*>>;

    return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});
}

template <class _InIt, class _Ty>
 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    return _First;
}




#line 2830 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE _Find_pr
template <class _InIt, class _Ty, class _Pr>
_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred) { // find first matching _Val, using _Pred
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

// FUNCTION TEMPLATE count
template <class _InIt, class _Ty>
 _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    // count elements that match _Val
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Val) {
            ++_Count;
        }
    }

    return _Count;
}




#line 2865 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE _Count_pr
template <class _InIt, class _Ty, class _Pr>
_Iter_diff_t<_InIt> _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    // count elements that match _Val, using _Pred
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

// FUNCTION TEMPLATE _Trim_matching_suffixes
template <class _FwdIt1, class _FwdIt2, class _Pr>
void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr, forward_iterator_tag, forward_iterator_tag) {
    // trim matching suffixes, forward iterators (do nothing)
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
void _Trim_matching_suffixes(
    _FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred, bidirectional_iterator_tag, bidirectional_iterator_tag) {
    // trim matching suffixes, bidirectional iterators
    // assumptions: same lengths, non-empty, !_Pred(*_First1, *_First2)
    do { // find last inequality
        --_Last1;
        --_Last2;
    } while (_Pred(*_Last1, *_Last2));
    ++_Last1;
    ++_Last2;
}

// FUNCTION TEMPLATE _Check_match_counts
template <class _FwdIt1, class _FwdIt2, class _Pr>
bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2), using _Pred, same lengths
    _Trim_matching_suffixes(_Last1, _Last2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { // new value, compare match counts
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; // second range lacks value, fail
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; // match counts differ, fail
            }
        }
    }

    return true;
}

// FUNCTION TEMPLATE is_permutation
template <class _FwdIt1, class _FwdIt2, class _Pr>
bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) {
            // found first inequality, check match counts in suffix narrowing _Iter_diff_t<_FwdIt1> to
            // _Iter_diff_t<_FwdIt2> is OK because if the 2nd range is shorter than the 1st, the user already
            // triggered UB
            auto _Last2 = ::std:: next(_First2, static_cast<_Iter_diff_t<_FwdIt2>>(::std:: distance(_First1, _Last1)));
            return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
        }
    }

    return true;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
    _Adl_verify_range(_First1, _Last1);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
    return _Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
}


template <class _FwdIt1, class _RightTy, size_t _RightSize, class _Pr, class = enable_if_t<!is_same_v<_RightTy*, _Pr>>>
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize], _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
    return ::std:: is_permutation(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
}
#line 2957 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _FwdIt1, class _FwdIt2>
bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2) {
    // test if [_First1, _Last1) == permuted [_First2, ...)
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>());
}



template <class _FwdIt1, class _RightTy, size_t _RightSize>
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize]) {
    // test if [_First1, _Last1) == permuted [_First2, ...)
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>());
}
#line 2972 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

template <class _FwdIt1, class _FwdIt2, class _Pr>
bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    forward_iterator_tag, forward_iterator_tag) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2), using _Pred, arbitrary iterators
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) { // found first inequality, check match counts in suffix
            if (::std:: distance(_First1, _Last1) == ::std:: distance(_First2, _Last2)) {
                return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
            } else {
                return false; // lengths differ, fail
            }
        }
    }

    return _First1 == _Last1 && _First2 == _Last2;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    random_access_iterator_tag, random_access_iterator_tag) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2), using _Pred, random-access iterators
    if (_Last1 - _First1 != _Last2 - _First2) {
        return false;
    }

    return _Is_permutation_unchecked(_First1, _Last1, _First2, _Pred);
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2), using _Pred
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    return _Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2),
        _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
}

// FUNCTION TEMPLATE is_permutation WITH TWO RANGES
template <class _FwdIt1, class _FwdIt2>
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2)
    return ::std:: is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>());
}

// FUNCTION TEMPLATE reverse

template <class _BidIt>
void reverse(const _BidIt _First, const _BidIt _Last) { // reverse elements in [_First, _Last)
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);

    using _Elem = remove_pointer_t<decltype(_UFirst)>;
    constexpr bool _Allow_vectorization =
        conjunction_v<is_pointer<decltype(_UFirst)>, _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    if constexpr (_Allow_vectorization && sizeof(_Elem) == 1) {
        __std_reverse_trivially_swappable_1(_UFirst, _ULast);
    } else if constexpr (_Allow_vectorization && sizeof(_Elem) == 2) {
        __std_reverse_trivially_swappable_2(_UFirst, _ULast);
    } else if constexpr (_Allow_vectorization && sizeof(_Elem) == 4) {
        __std_reverse_trivially_swappable_4(_UFirst, _ULast);
    } else if constexpr (_Allow_vectorization && sizeof(_Elem) == 8) {
        __std_reverse_trivially_swappable_8(_UFirst, _ULast);
    } else
#line 3038 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
    {
        for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
            ::std:: iter_swap(_UFirst, _ULast);
        }
    }
}



























































#line 3104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"








#line 3113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE rotate
template <class _BidIt>
pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    // reverse until either _First or _Last hits _Sentinel
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std:: iter_swap(_First, --_Last);
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}


template <class _FwdIt>
_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    // exchange the ranges [_First, _Mid) and [_Mid, _Last)
    // that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
    // returns the iterator pointing at *_First's new home
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { // rotate the first cycle
            ::std:: iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { // rotate subsequent cycles
            _UNext = _UMid;
            do {
                ::std:: iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}

































































#line 3248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"








#line 3257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

// FUNCTION TEMPLATE lower_bound
template <class _FwdIt, class _Ty, class _Pr>
 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    // find first element not before _Val, using _Pred
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { // divide and conquer, find half that contains answer
        const _Iter_diff_t<_FwdIt> _Count2 = _Count >> 1; // TRANSITION, VSO#433486
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { // try top half
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

// CLASS TEMPLATE _Rng_from_urng
template <class _Diff, class _Urng>
class _Rng_from_urng { // wrap a URNG as an RNG
public:
    using _Ty0 = make_unsigned_t<_Diff>;
    using _Ty1 = typename _Urng::result_type;

    using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;

    explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(8 * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {
        for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {
            --_Bits;
        }
    }

    _Diff operator()(_Diff _Index) { // adapt _Urng closed range to [0, _Index)
        for (;;) { // try a sample random value
            _Udiff _Ret  = 0; // random bits
            _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

            while (_Mask < _Udiff(_Index - 1)) { // need more random bits
                _Ret <<= _Bits - 1; // avoid full shift
                _Ret <<= 1;
                _Ret |= _Get_bits();
                _Mask <<= _Bits - 1; // avoid full shift
                _Mask <<= 1;
                _Mask |= _Bmask;
            }

            // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
            if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {
                return static_cast<_Diff>(_Ret % _Index);
            }
        }
    }

    _Udiff _Get_all_bits() { // return a random value
        _Udiff _Ret = 0;

        for (size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits) { // don't mask away any bits
            _Ret <<= _Bits - 1; // avoid full shift
            _Ret <<= 1;
            _Ret |= _Get_bits();
        }

        return _Ret;
    }

    _Rng_from_urng(const _Rng_from_urng&) = delete;
    _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
    _Udiff _Get_bits() { // return a random value within [0, _Bmask]
        for (;;) { // repeat until random value is in range
            _Udiff _Val = _Ref() - (_Urng::min)();

            if (_Val <= _Bmask) {
                return _Val;
            }
        }
    }

    _Urng& _Ref; // reference to URNG
    size_t _Bits; // number of random bits generated by _Get_bits()
    _Udiff _Bmask; // 2^_Bits - 1
};

// CLASS TEMPLATE _Yarn
template <class _Elem>
class __declspec(dllimport) _Yarn { // wrap a NTCTS
public:
     _Yarn() : _Myptr(nullptr), _Nul(0) {}

     _Yarn(const _Yarn& _Right) : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

     _Yarn(const _Elem* _Right) : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

    _Yarn&  operator=(const _Yarn& _Right) {
        return *this = _Right._Myptr;
    }

    _Yarn&  operator=(const _Elem* _Right) { // assign from NTCTS
        if (_Myptr != _Right) { // new value, discard old and copy new
            _Tidy();

            if (_Right) { // new is not empty, copy it
                const _Elem* _Ptr = _Right;
                while (*_Ptr != _Elem{}) {
                    ++_Ptr;
                }

                const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);


                _Myptr = static_cast<_Elem*>(_malloc_dbg(_Count, 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility", 3379));


#line 3383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

                if (_Myptr) {
                    :: memcpy(_Myptr, _Right, _Count);
                }
            }
        }

        return *this;
    }

     ~_Yarn() noexcept {
        _Tidy();
    }

    bool  empty() const {
        return _Myptr == nullptr;
    }

      const _Elem*  c_str() const {
        return _Myptr ? _Myptr : &_Nul;
    }

    bool  _Empty() const {
        return _Myptr == nullptr;
    }

      const _Elem*  _C_str() const {
        return _Myptr ? _Myptr : &_Nul;
    }

private:
    void  _Tidy() noexcept {
        if (_Myptr) {

            _free_dbg(_Myptr, 2);


#line 3421 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
        }

        _Myptr = nullptr;
    }

    _Elem* _Myptr; // pointer to allocated string
    _Elem _Nul; // nul terminator for unallocated string
};


// CLASS TEMPLATE back_insert_iterator
template <class _Container>
class back_insert_iterator { // wrap pushes to back of container as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;

    explicit back_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) { // construct with container
    }

    back_insert_iterator& operator=(const typename _Container::value_type& _Val) { // push value into container
        container->push_back(_Val);
        return *this;
    }

    back_insert_iterator& operator=(typename _Container::value_type&& _Val) { // push value into container
        container->push_back(::std:: move(_Val));
        return *this;
    }

     back_insert_iterator& operator*() { // pretend to return designated value
        return *this;
    }

    back_insert_iterator& operator++() { // pretend to preincrement
        return *this;
    }

    back_insert_iterator operator++(int) { // pretend to postincrement
        return *this;
    }

protected:
    _Container* container; // pointer to container
};

// FUNCTION TEMPLATE back_inserter
template <class _Container>
 back_insert_iterator<_Container> back_inserter(_Container& _Cont) { // return a back_insert_iterator
    return back_insert_iterator<_Container>(_Cont);
}


// STRUCT TEMPLATE _Has_allocator_type
template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type { // tests for suitable _Ty::allocator_type
};

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type { // tests for suitable _Ty::allocator_type
};

// STRUCT allocator_arg_t
struct allocator_arg_t { // tag type for added allocator argument
    explicit allocator_arg_t() = default;
};

 constexpr allocator_arg_t allocator_arg{};

[[noreturn]]  void __cdecl _Xbad_alloc();
[[noreturn]]  void __cdecl _Xinvalid_argument(  const char*);
[[noreturn]]  void __cdecl _Xlength_error(  const char*);
[[noreturn]]  void __cdecl _Xout_of_range(  const char*);
[[noreturn]]  void __cdecl _Xoverflow_error(  const char*);
[[noreturn]]  void __cdecl _Xruntime_error(  const char*);

// STRUCT TEMPLATE uses_allocator
template <class _Ty, class _Alloc>
struct uses_allocator
    : _Has_allocator_type<_Ty, _Alloc>::type { // determine whether _Ty has an allocator_type member type
};

template <class _Ty, class _Alloc>
 constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

// STRUCT TEMPLATE iterator
template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*, class _Reference = _Ty&>
struct  iterator { // base type for iterator classes
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

// STRUCT TEMPLATE _Tidy_guard
template <class _Ty>
struct _Tidy_guard { // class with destructor that calls _Tidy
    _Ty* _Target;
    ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

// STRUCT TEMPLATE _Tidy_deallocate_guard
template <class _Ty>
struct _Tidy_deallocate_guard { // class with destructor that calls _Tidy_deallocate
    _Ty* _Target;
    ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 3549 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"
#line 3550 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xutility"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// FUNCTION TEMPLATE _Get_size_of_n
template <size_t _Ty_size>
 constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if
        constexpr(_Overflow_is_possible) {
            constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
            if (_Count > _Max_possible) {
                _Throw_bad_array_new_length(); // multiply overflow
            }
        }

    return _Count * _Ty_size;
}

// VARIABLE TEMPLATE _New_alignof
template <class _Ty>
 constexpr size_t _New_alignof = _Max_value(alignof(_Ty),
    static_cast<size_t>(8u) // TRANSITION, VSO#522105
);

// STRUCT _Default_allocate_traits
struct _Default_allocate_traits {
    __declspec(allocator) static void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }






};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}


constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;

static_assert(2 * sizeof(void*) <= _Big_allocation_alignment,
    "Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");


constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;


#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"




constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAUL;
#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION _Allocate_manually_vector_aligned
template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    // allocate _Bytes manually aligned to at least _Big_allocation_alignment
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); // add overflow
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do { if (_Ptr_container != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 91, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 91, 0); } while (false); } ; } while (false); // validate even in release since we're doing p[-1]
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;


    static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
    return _Ptr;
}

// FUNCTION TEMPLATE _Adjust_manually_vector_aligned
inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];

    // If the following asserts, it likely means that we are performing
    // an aligned delete on memory coming from an unaligned allocation.
    do { if (_Ptr_user[-2] == _Big_allocation_sentinel) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 111, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 111, 0); } while (false); } ; } while (false);

    // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
    // in range [_Min_back_shift, _Non_user_size]

    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);


#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 121, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 121, 0); } while (false); } ; } while (false);
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATES _Allocate and _Deallocate




































#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!0 || _Align <= 8u), int> = 0>
__declspec(allocator) void* _Allocate(const size_t _Bytes) {
    // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

    if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization
        return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
    }
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }

    return nullptr;
}

template <size_t _Align, enable_if_t<(!0 || _Align <= 8u), int> = 0>
void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

    if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization
        _Adjust_manually_vector_aligned(_Ptr, _Bytes);
    }
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

    ::operator delete(_Ptr, _Bytes);
}



// FUNCTION TEMPLATE _Construct_in_place
template <class _Ty, class... _Types>
void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {
    ::new (const_cast<void*>(static_cast<const volatile void*>(::std:: addressof(_Obj))))
        _Ty(::std:: forward<_Types>(_Args)...);
}

// FUNCTION TEMPLATE _Global_new
template <class _Ty, class... _Types>
_Ty* _Global_new(_Types&&... _Args) { // acts as "new" while disallowing user overload selection
    struct _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };

    _Guard_type _Guard{_Allocate<_New_alignof<_Ty>>(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(::std:: forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std:: exchange(_Guard._Result, nullptr));
}

// STRUCT TEMPLATE _Get_first_parameter
template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { // given _Ty<_First, _Rest...>, extract _First
    using type = _First;
};

// STRUCT TEMPLATE _Replace_first_parameter
template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { // given _Ty<_First, _Rest...>, replace _First
    using type = _Ty<_Newfirst, _Rest...>;
};

// STRUCT TEMPLATE _Get_element_type
template <class _Ty, class = void>
struct _Get_element_type {
    using type = typename _Get_first_parameter<_Ty>::type;
};

template <class _Ty>
struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>> {
    using type = typename _Ty::element_type;
};

// STRUCT TEMPLATE _Get_ptr_difference_type
template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

// STRUCT TEMPLATE _Get_rebind_alias
template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};

// STRUCT TEMPLATE pointer_traits
template <class _Ty>
struct pointer_traits {
    using element_type    = typename _Get_element_type<_Ty>::type;
    using pointer         = _Ty;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<element_type>, char&, add_lvalue_reference_t<element_type>>;

     static pointer pointer_to(_Reftype _Val) {
        return _Ty::pointer_to(_Val);
    }
};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using element_type    = _Ty;
    using pointer         = _Ty*;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char&, add_lvalue_reference_t<_Ty>>;

     static pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};

// ALIAS TEMPLATE _Rebind_pointer_t
template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

// FUNCTION TEMPLATE _Refancy
template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
_Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
_Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

// FUNCTION TEMPLATE _Destroy_in_place
template <class _Ty>
void _Destroy_in_place(_Ty& _Obj) noexcept {
    _Obj.~_Ty();
}

// FUNCTION TEMPLATE _Const_cast
template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { // remove constness from a fancy pointer
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

// STRUCT TEMPLATE _Get_pointer_type
template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
#pragma warning(pop)

// STRUCT TEMPLATE _Get_const_pointer_type
template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
#pragma warning(pop)

// STRUCT TEMPLATE _Get_void_pointer_type
template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

// STRUCT TEMPLATE _Get_const_void_pointer_type
template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

// STRUCT TEMPLATE _Get_difference_type
template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

// STRUCT TEMPLATE _Get_size_type
template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

// STRUCT TEMPLATE _Get_propagate_on_container_copy
template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

// STRUCT TEMPLATE _Get_propagate_on_container_move
template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

// STRUCT TEMPLATE _Get_propagate_on_container_swap
template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

// STRUCT TEMPLATE _Get_is_always_equal
template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = typename is_empty<_Ty>::type;
};

template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};

// STRUCT TEMPLATE _Get_rebind_type
template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
#pragma warning(pop)

// STRUCT TEMPLATE _Is_default_allocator
template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized> : true_type {};

// ALIAS TEMPLATES _Uses_default_construct
template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
#pragma warning(pop)

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;


// ALIAS TEMPLATE _Uses_default_destroy AND _Uses_default_destroy_t
template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type {};
#pragma warning(pop)

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Ptr>
using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;


// STRUCT TEMPLATE _Has_allocate_hint
template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(
        ::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>> : true_type {};
#pragma warning(pop)

// STRUCT TEMPLATE _Has_max_size
template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>> : true_type {};
#pragma warning(pop)

// STRUCT TEMPLATE _Has_select_on_container_copy_construction
template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};


// STRUCT TEMPLATE allocator_traits
template <class _Alloc>
struct allocator_traits;

#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc>
struct _Normal_allocator_traits { // defines traits for allocators
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

     static __declspec(allocator) pointer allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count) {
        return _Al.allocate(_Count);
    }


     static __declspec(allocator) pointer allocate(
        _Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            (void) _Hint;
            return _Al.allocate(_Count);
        }
    }















#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

    static void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }


    template <class _Ty, class... _Types>
    static void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
            (void) _Al;
            ::new (static_cast<void*>(_Ptr)) _Ty(::std:: forward<_Types>(_Args)...);
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }
















#line 643 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


    template <class _Ty>
    static void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy_t<_Alloc, _Ty*>::value) {
            (void) _Al;
            _Ptr->~_Ty();
        } else {
            _Al.destroy(_Ptr);
        }
    }















#line 670 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


     static size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            (void) _Al;
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }












#line 693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


     static _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }












#line 715 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
};
#pragma warning(pop)

template <class _Alloc>
struct _Default_allocator_traits { // traits for std::allocator
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

     static __declspec(allocator) pointer allocate(_Alloc&, __declspec(guard(overflow)) const size_type _Count) {
        return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
    }

     static __declspec(allocator) pointer allocate(
        _Alloc&, __declspec(guard(overflow)) const size_type _Count, const_void_pointer) {
        return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
    }

    static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {
        // no overflow check on the following multiply; we assume _Allocate did that check
        _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
    }

    template <class _Objty, class... _Types>
    static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std:: forward<_Types>(_Args)...);
    }

    template <class _Uty>
    static void destroy(_Alloc&, _Uty* const _Ptr) {
        _Ptr->~_Uty();
    }

     static size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

     static _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {};

// _Choose_pocca returns whether an attempt to propagate allocators is necessary in copy assignment operations.
// Note that even when false_type, callers should call _Pocca as we want to assign allocators even when equal.
template <class _Alloc>
using _Choose_pocca = bool_constant<allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                                    && !allocator_traits<_Alloc>::is_always_equal::value>;

struct _Equal_allocators {}; // usually allows contents to be stolen (e.g. with swap)
using _Propagate_allocators    = true_type; // usually allows the allocator to be propagated, and then contents stolen
using _No_propagate_allocators = false_type; // usually turns moves into copies

template <class _Alloc>
using _Choose_pocma = conditional_t<allocator_traits<_Alloc>::is_always_equal::value, _Equal_allocators,
    typename allocator_traits<_Alloc>::propagate_on_container_move_assignment::type>;

// ALIAS TEMPLATE _Rebind_alloc_t
template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;

// ALIAS TEMPLATE _Maybe_rebind_alloc_t
// If _Alloc is already rebound appropriately, binds an lvalue reference to it, avoiding a copy. Otherwise, creates a
// rebound copy.
template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;

// VARIABLE TEMPLATE _Is_simple_alloc_v
template <class _Alloc> // tests if allocator has simple addressing
 constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>&&
    is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>&&
        is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>&&
            is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

// STRUCT TEMPLATE _Simple_types
template <class _Value_type>
struct _Simple_types { // wraps types from allocators with simple addressing for use in iterators
                       // and other SCARY machinery
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};

// CLASS TEMPLATE allocator
template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");

    using _Not_user_specialized = void;

    using value_type = _Ty;

     typedef _Ty* pointer;
     typedef const _Ty* const_pointer;

     typedef _Ty& reference;
     typedef const _Ty& const_reference;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };

      _Ty* address(_Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }

      const _Ty* address(const _Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}

    void deallocate(_Ty* const _Ptr, const size_t _Count) {
        // no overflow check on the following multiply; we assume _Allocate did that check
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

     __declspec(allocator) _Ty* allocate(__declspec(guard(overflow)) const size_t _Count) {
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }

      __declspec(allocator) _Ty* allocate(
        __declspec(guard(overflow)) const size_t _Count, const void*) {
        return allocate(_Count);
    }

    template <class _Objty, class... _Types>
     void construct(_Objty* const _Ptr, _Types&&... _Args) {
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std:: forward<_Types>(_Args)...);
    }

    template <class _Uty>
     void destroy(_Uty* const _Ptr) {
        _Ptr->~_Uty();
    }

      size_t max_size() const noexcept {
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
};

// CLASS allocator<void>
template <>
class allocator<void> {
public:
    using value_type = void;
     typedef void* pointer;
     typedef const void* const_pointer;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };
};

template <class _Ty, class _Other>
 bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}

template <class _Ty, class _Other>
 bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return false;
}






#line 930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// ALIAS TEMPLATE _Alloc_ptr_t
template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

// ALIAS_TEMPLATE _Alloc_size_t
template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

// FUNCTION TEMPLATE _Pocca

template <class _Alloc>
void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    } else {
        (void) _Left; // TRANSITION, VSO#486357
        (void) _Right; // TRANSITION, VSO#486357
    }
}













#line 964 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE _Pocma

template <class _Alloc>
void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    } else {
        (void) _Left; // TRANSITION, VSO#486357
        (void) _Right; // TRANSITION, VSO#486357
    }
}














#line 991 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE _Pocs

template <class _Alloc>
void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
        do { if (_Left == _Right) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 999, 0, "%s", "containers incompatible for swap")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"containers incompatible for swap\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 999, 0); } while (false); } ; } while (false);
        (void) _Left; // TRANSITION, VSO#486357
        (void) _Right; // TRANSITION, VSO#486357
    }
}


















#line 1023 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


// FUNCTION TEMPLATE _Destroy_range WITH ALLOC
template <class _Alloc>
void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
    using _Ty = typename _Alloc::value_type;
    if
        constexpr(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
            (void) _First;
            (void) _Last;
            (void) _Al;
        }
    else {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}


// FUNCTION TEMPLATE _Destroy_range
template <class _NoThrowFwdIt>
void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowFwdIt _Last) noexcept {
    // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
    if
        constexpr(is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
            (void) _First;
            (void) _Last;
        }
    else {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}


// FUNCTION TEMPLATE _Convert_size
template <class _Size_type>
 constexpr _Size_type _Convert_size(const size_t _Len) noexcept {
    // convert size_t to _Size_type, avoiding truncation
    if (_Len > (numeric_limits<_Size_type>::max)()) {
        _Xlength_error("size_t too long for _Size_type");
    }

    return static_cast<_Size_type>(_Len);
}

template <>
 constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {
    // convert size_t to size_t, unchanged
    return _Len;
}

// FUNCTION TEMPLATE _Deallocate_plain

template <class _Alloc>
void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    // deallocate a plain pointer using an allocator
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}














#line 1106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE _Delete_plain_internal
template <class _Alloc>
void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _Deallocate_plain(_Al, _Ptr);
}

// STRUCT TEMPLATE _Alloc_construct_ptr
template <class _Alloc>
struct _Alloc_construct_ptr { // pointer used to help construct 1 _Alloc::value_type without EH
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

     pointer _Release() noexcept { // disengage *this and return contained pointer
        return ::std:: exchange(_Ptr, nullptr);
    }

    void _Allocate() { // disengage *this, then allocate a new memory block
        _Ptr = nullptr; // if allocate throws, prevents double-free
        _Ptr = _Al.allocate(1);
    }

    ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

// CLASSES _Container_base*, _Iterator_base*
struct _Fake_allocator {};

struct _Container_base0 {
    void _Orphan_all() noexcept {}
    void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    void _Adopt(const void*) noexcept {}
    const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

// CLASS _Container_proxy
struct _Container_base12;
struct _Container_proxy { // store head of iterator chain and back pointer
    _Container_proxy() noexcept : _Mycont(nullptr), _Myfirstiter(nullptr) {}
    _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

    const _Container_base12* _Mycont;
    _Iterator_base12* _Myfirstiter;
};

struct _Container_base12 {
public:
    _Container_base12() : _Myproxy(nullptr) {} // construct childless container

    _Container_base12(const _Container_base12&) = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    void _Orphan_all() noexcept;
    void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        // pre: no iterators refer to the existing proxy
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy;
};

struct _Iterator_base12 { // store links to container proxy, next iterator
    _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

    _Iterator_base12(const _Iterator_base12& _Right) noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {
        *this = _Right;
    }

    _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
        if (_Myproxy != _Right._Myproxy) {
            if (_Right._Myproxy) {
                _Adopt(_Right._Myproxy->_Mycont);
            } else { // becoming invalid, disown current parent

                _Lockit _Lock(3);
                _Orphan_me();


#line 1221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
            }
        }

        return *this;
    }

    ~_Iterator_base12() noexcept {

        _Lockit _Lock(3);
        _Orphan_me();
#line 1232 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
    }

    void _Adopt(const _Container_base12* _Parent) noexcept {
        if (_Parent) {
            // have a parent, do adoption
            _Container_proxy* _Parent_proxy = _Parent->_Myproxy;


            if (_Myproxy != _Parent_proxy) { // change parentage
                _Lockit _Lock(3);
                _Orphan_me();
                _Mynextiter                 = _Parent_proxy->_Myfirstiter;
                _Parent_proxy->_Myfirstiter = this;
                _Myproxy                    = _Parent_proxy;
            }



#line 1251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
        } else {
            // no future parent, just disown current parent

            _Lockit _Lock(3);
            _Orphan_me();


#line 1259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
        }
    }

    const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }


    void _Orphan_me() noexcept {
        if (_Myproxy) { // adopted, remove self from list
            _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;
            while (*_Pnext && *_Pnext != this) {
                _Pnext = &(*_Pnext)->_Mynextiter;
            }

            do { if (*_Pnext) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 1274, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"ITERATOR LIST CORRUPTED!\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory", 1274, 0); } while (false); } ; } while (false);
            *_Pnext  = _Mynextiter;
            _Myproxy = nullptr;
        }
    }
#line 1280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

    static constexpr bool _Unwrap_when_unverified = 2 == 0;

    _Container_proxy* _Myproxy;
    _Iterator_base12* _Mynextiter;
};

// MEMBER FUNCTIONS FOR _Container_base12
inline void _Container_base12::_Orphan_all() noexcept {

    if (_Myproxy) { // proxy allocated, drain it
        _Lockit _Lock(3);

        for (auto _Pnext = &_Myproxy->_Myfirstiter; *_Pnext; *_Pnext = (*_Pnext)->_Mynextiter) {
            (*_Pnext)->_Myproxy = nullptr;
        }

        _Myproxy->_Myfirstiter = nullptr;
    }
#line 1300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
}

inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

    _Lockit _Lock(3);
#line 1306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}





#line 1325 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
#line 1328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


// ALIAS TEMPLATE _Container_proxy_ptr AND SUPPORTING MACHINERY
struct _Leave_proxy_unbound {}; // tag to indicate that a proxy is being allocated before it is safe to bind to a
                                // _Container_base12

struct _Fake_proxy_ptr_impl { // fake replacement for a container proxy smart pointer when no container proxy is in use
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    // smart pointer components for a _Container_proxy * that don't depend on the allocator
    _Container_proxy* _Ptr;

    void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12
        _Ptr = nullptr;
    }

protected:
    _Basic_container_proxy_ptr12()                                    = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12
    : _Basic_container_proxy_ptr12 { // smart pointer components for a _Container_proxy * for an allocator family
    _Alloc& _Al;

    _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) { // create a new unbound _Container_proxy
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)
        : _Al(_Al_) { // create a new _Container_proxy pointing at _Mycont
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std:: addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        // Attach the proxy stored in *this to _Mycont, and destroy _Mycont's existing proxy
        // with _Old_alloc. Requires that no iterators are alive referring to _Mycont.
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }

    ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};





#line 1394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

template <class _Alloc>
using _Container_proxy_ptr = _Container_proxy_ptr12<_Rebind_alloc_t<_Alloc, _Container_proxy>>;
#line 1398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// CLASS TEMPLATE _Compressed_pair
struct _Zero_then_variadic_args_t {}; // tag type for value-initializing first, constructing second from remaining args

struct _One_then_variadic_args_t {
}; // tag type for constructing first from one arg, constructing second from remaining args

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { // store a pair of values, deriving from empty first
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; // for visualization

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2)
        : _Ty1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    _Ty1& _Get_first() noexcept {
        return *this;
    }

    const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { // store a pair of values, not deriving from first
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2)
        : _Myval1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {};

// FUNCTION TEMPLATE _Get_temporary_buffer
template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;





            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

// FUNCTION TEMPLATE _Return_temporary_buffer
template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {





    {
        ::operator delete(_Pbuf);
    }
}

// STRUCT TEMPLATE _Uninitialized_backout
template <class _NoThrowFwdIt>
struct _Uninitialized_backout { // struct to undo partially constructed ranges in _Uninitialized_xxx algorithms
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&) = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    ~_Uninitialized_backout() {
        _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }
};

// FUNCTION TEMPLATE _Uninitialized_move_unchecked

template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // move [_First, _Last) to raw [_Dest, ...)
    if constexpr (_Ptr_move_cat<_InIt, _NoThrowFwdIt>::_Really_trivial) {
        return _Copy_memmove(_First, _Last, _Dest);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
        for (; _First != _Last; ++_First) {
            _Backout._Emplace_back(::std:: move(*_First));
        }

        return _Backout._Release();
    }
}

























#line 1563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// STRUCT TEMPLATE _Uninitialized_backout_al
template <class _Alloc>
class _Uninitialized_backout_al { // struct to undo partially constructed ranges in _Uninitialized_xxx_al algorithms
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    ~_Uninitialized_backout_al() {
        _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    pointer _Release() { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

// FUNCTION TEMPLATE _Uninitialized_copy WITH ALLOCATOR

template <class _InIt, class _Alloc>
_Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    // copy [_First, _Last) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval = typename _Alloc::value_type*;

    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
        _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
        _Dest += _ULast - _UFirst;
        (void) _Al;
    } else {
        _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
        for (; _UFirst != _ULast; ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _Dest = _Backout._Release();
    }

    return _Dest;
}




































#line 1661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE uninitialized_copy

template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // copy [_First, _Last) to raw [_Dest, ...)
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
        _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
        for (; _UFirst != _ULast; ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}






























#line 1716 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


template <class _InIt, class _OutTy, size_t _OutSize>
_OutTy* uninitialized_copy(const _InIt _First, const _InIt _Last, _OutTy (&_Dest)[_OutSize]) {
    // copy [_First, _Last) to raw [_Dest, ...)
    return ::std:: uninitialized_copy(_First, _Last, _Array_iterator<_OutTy, _OutSize>(_Dest))._Unwrapped();
}
#line 1724 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE _Uninitialized_move WITH ALLOCATOR

template <class _InIt, class _Alloc>
_Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    // move [_First, _Last) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval     = typename _Alloc::value_type*;
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std:: move(*_UFirst))>>) {
        _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
        return _Dest + (_ULast - _UFirst);
        (void) _Al;
    } else {
        _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
        for (; _UFirst != _ULast; ++_UFirst) {
            _Backout._Emplace_back(::std:: move(*_UFirst));
        }

        return _Backout._Release();
    }
}








































#line 1790 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE _Uninitialized_fill_n WITH ALLOCATOR

template <class _Alloc>
_Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    // copy _Count copies of _Val to raw _First, using _Al
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
        (void) _Al;
        :: memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
        return _First + _Count;
    } else {
        _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back(_Val);
        }

        return _Backout._Release();
    }
}





























#line 1841 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE uninitialized_fill

template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    // copy _Val throughout raw [_First, _Last)
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<_NoThrowFwdIt>, _Tval>) {
        :: memset(_UFirst, static_cast<unsigned char>(_Val), static_cast<size_t>(_ULast - _UFirst));
    } else {
        _Uninitialized_backout<_Unwrapped_t<_NoThrowFwdIt>> _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}




























#line 1890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE _Uninitialized_value_construct_n WITH ALLOCATOR
template <class _NoThrowFwdIt>
 constexpr bool _Use_memset_value_construct_v = conjunction_v<is_pointer<_NoThrowFwdIt>,
    is_scalar<_Iter_value_t<_NoThrowFwdIt>>, negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
    negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes
    char* const _First_ch = reinterpret_cast<char*>(_First);
    char* const _Last_ch  = reinterpret_cast<char*>(_Last);
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}


template <class _Alloc>
_Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    // value-initialize _Count objects to raw _First, using _Al
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
        (void) _Al;
        auto _PFirst = _Unfancy(_First);
        _Zero_range(_PFirst, _PFirst + _Count);
        return _First + _Count;
    } else {
        _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}






























#line 1956 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"


template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
    ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}



















#line 1993 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

// FUNCTION TEMPLATE get_temporary_buffer
template <class _Ty>
  pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept {
    return _Get_temporary_buffer<_Ty>(_Count);
}

// FUNCTION TEMPLATE return_temporary_buffer
template <class _Ty>
 void return_temporary_buffer(_Ty* _Pbuf) {
    _Return_temporary_buffer(_Pbuf);
}

// STRUCT TEMPLATE _In_place_key_extract_set
// assumes _Args have already been _Remove_cvref_t'd
template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    // by default we can't extract the key in the emplace family and must construct a node we might not use
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    // we can extract the key in emplace if the emplaced type is identical to the key type
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};

// STRUCT TEMPLATE _In_place_key_extract_map
// assumes _Args have already been _Remove_cvref_t'd
template <class _Key, class... Args>
struct _In_place_key_extract_map {
    // by default we can't extract the key in the emplace family and must construct a node we might not use
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    // if we would call the pair(key, value) constructor family, we can use the first parameter as the key
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    // if we would call the pair(pair<other, other>) constructor family, we can use the pair.first member as the key
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) {
        return _Val.first;
    }
};

// STRUCT TEMPLATE _Wrap
template <class _Ty>
struct _Wrap {
    _Ty _Value; // workaround for "T^ is not allowed in a union"
};

// STRUCT TEMPLATE _Alloc_temporary
template <class _Alloc>
struct _Alloc_temporary {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits<_Alloc>;

    _Alloc& _Al;
    union {
        _Wrap<value_type> _Storage;
    };

    template <class... _Args>
    explicit _Alloc_temporary(_Alloc& _Al_, _Args&&... _Vals) noexcept(noexcept(_Traits::construct(_Al_, ::std:: addressof(_Storage._Value), ::std:: forward<_Args>(_Vals)...)))
#line 2070 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
        : _Al(_Al_) {
        _Traits::construct(_Al, ::std:: addressof(_Storage._Value), ::std:: forward<_Args>(_Vals)...);
    }

    _Alloc_temporary(const _Alloc_temporary&) = delete;
    _Alloc_temporary& operator=(const _Alloc_temporary&) = delete;

    ~_Alloc_temporary() {
        _Traits::destroy(_Al, ::std:: addressof(_Storage._Value));
    }
};
}



#pragma warning(pop)
#pragma pack(pop)
#line 2087 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"
#line 2088 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xmemory"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"



#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// STRUCT TEMPLATE _Char_traits (FROM <string>)
template <class _Elem, class _Int_type>
struct _Char_traits { // properties of a string or stream element
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;

     static inline int compare(  const _Elem* _First1,
          const _Elem* _First2, size_t _Count) noexcept { // strengthened
        // compare [_First1, _First1 + _Count) with [_First2, ...)
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }

        return 0;
    }

     static inline size_t length(  const _Elem* _First) noexcept { // strengthened
        // find length of null-terminated sequence
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }

        return _Count;
    }

    static _Elem* copy(  _Elem* const _First1,   const _Elem* _First2,
        size_t _Count) noexcept { // strengthened
        // copy [_First2, _First2 + _Count) to [_First1, ...)
        return static_cast<_Elem*>(:: memcpy(_First1, _First2, _Count * sizeof(_Elem)));
    }

      static _Elem* _Copy_s(  _Elem* const _First1,
        const size_t _Dest_size,   const _Elem* const _First2,
        const size_t _Count) noexcept { // copy [_First2, _First2 + _Count) to [_First1, _First1 + _Dest_size)
        do { if (_Count <= _Dest_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 63, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 63, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }

     static inline const _Elem* find(
          const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept { // strengthened
        // look for _Ch in [_First, _First + _Count)
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }

        return nullptr;
    }

    static _Elem* move(  _Elem* const _First1,   const _Elem* _First2,
        size_t _Count) noexcept { // strengthened
        // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
        return static_cast<_Elem*>(:: memmove(_First1, _First2, _Count * sizeof(_Elem)));
    }

    static _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept { // strengthened
        // assign _Count * _Ch to [_First, ...)
        _Elem* _Next = _First;
        for (; 0 < _Count; --_Count, ++_Next) {
            *_Next = _Ch;
        }

        return _First;
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept { // assign an element
        _Left = _Right;
    }

     static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept { // test for element equality
        return _Left == _Right;
    }

     static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        // test if _Left precedes _Right
        return _Left < _Right;
    }

     static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        // convert metacharacter to character
        return static_cast<_Elem>(_Meta);
    }

     static constexpr int_type to_int_type(const _Elem& _Ch) noexcept { // convert character to metacharacter
        return static_cast<int_type>(_Ch);
    }

     static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        // test for metacharacter equality
        return _Left == _Right;
    }

     static constexpr int_type not_eof(const int_type& _Meta) noexcept { // return anything but EOF
        return _Meta != eof() ? _Meta : !eof();
    }

     static constexpr int_type eof() noexcept { // return end-of-file metacharacter
        return static_cast<int_type>((-1));
    }
};

// STRUCT TEMPLATE _WChar_traits
template <class _Elem>
struct _WChar_traits { // char_traits for the char16_t-likes: char16_t, wchar_t, unsigned short
    using char_type  = _Elem;
    using int_type   = unsigned short;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;

     static inline int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept { // strengthened
        // compare [_First1, _First1 + _Count) with [_First2, ...)






#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return :: wmemcmp(
            reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

     static inline size_t length(  const _Elem* _First) noexcept { // strengthened
        // find length of null-terminated sequence






#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return :: wcslen(reinterpret_cast<const wchar_t*>(_First));
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

    static _Elem* copy(  _Elem* const _First1,   const _Elem* const _First2,
        const size_t _Count) noexcept { // strengthened
        // copy [_First2, _First2 + _Count) to [_First1, ...)
        return reinterpret_cast<_Elem*>(
            :: wmemcpy(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count));
    }

      static _Elem* _Copy_s( 
                                                                        _Elem* const _First1,
        const size_t _Size_in_words,   const _Elem* const _First2,
        const size_t _Count) noexcept { // copy [_First2, _First2 + _Count) to [_First1, ...)
        do { if (_Count <= _Size_in_words) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 180, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 180, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }

     static inline const _Elem* find(
          const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept { // strengthened
        // look for _Ch in [_First, _First + _Count)






#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return reinterpret_cast<const _Elem*>(:: wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

    static _Elem* move(  _Elem* const _First1,   const _Elem* const _First2,
        const size_t _Count) noexcept { // strengthened
        // copy [_First2, _First2 + _Count) to [_First1, ...)
        return reinterpret_cast<_Elem*>(
            :: wmemmove(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count));
    }

    static _Elem* assign(
          _Elem* const _First, size_t _Count, _Elem _Ch) noexcept { // strengthened
        // assign _Count * _Ch to [_First, ...)
        return reinterpret_cast<_Elem*>(:: wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept { // assign an element
        _Left = _Right;
    }

     static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept { // test for element equality
        return _Left == _Right;
    }

     static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        // test if _Left precedes _Right
        return _Left < _Right;
    }

     static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        // convert metacharacter to character
        return _Meta;
    }

     static constexpr int_type to_int_type(const _Elem& _Ch) noexcept { // convert character to metacharacter
        return _Ch;
    }

     static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        // test for metacharacter equality
        return _Left == _Right;
    }

     static constexpr int_type not_eof(const int_type& _Meta) noexcept { // return anything but EOF
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }

     static constexpr int_type eof() noexcept { // return end-of-file metacharacter
        return ((wint_t)(0xFFFF));
    }
};

// STRUCT TEMPLATE char_traits
template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {}; // properties of a string or stream unknown element

// STRUCT char_traits<char16_t>
template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {}; // properties of a string or stream char16_t element

using u16streampos = streampos;

// STRUCT char_traits<char32_t>
template <>
struct char_traits<char32_t>
    : _Char_traits<char32_t, unsigned int> { // properties of a string or stream char32_t element
};

using u32streampos = streampos;

// STRUCT char_traits<wchar_t>
template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {}; // properties of a string or stream wchar_t element


// STRUCT char_traits<unsigned short>
template <>
struct char_traits<unsigned short> : _WChar_traits<unsigned short> {
    // properties of a string or stream unsigned short element
};
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"



#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

// STRUCT TEMPLATE _Narrow_char_traits
template <class _Elem, class _Int_type>
struct _Narrow_char_traits { // Implement char_traits for narrow character types char and char8_t
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;

     static inline int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept { // strengthened
        // compare [_First1, _First1 + _Count) with [_First2, ...)









#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return :: memcmp(_First1, _First2, _Count);
#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

     static inline size_t length(  const _Elem* const _First) noexcept { // strengthened
        // find length of null-terminated string













#line 326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return :: strlen(reinterpret_cast<const char*>(_First));
#line 328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

    static _Elem* copy(  _Elem* const _First1,   const _Elem* const _First2,
        const size_t _Count) noexcept { // strengthened
        // copy [_First2, _First2 + _Count) to [_First1, ...)
        return static_cast<_Elem*>(:: memcpy(_First1, _First2, _Count));
    }

      static _Elem* _Copy_s( 
                                                                        _Elem* const _First1,
        const size_t _Size_in_bytes,   const _Elem* const _First2, const size_t _Count) noexcept {
        // copy [_First2, _First2 + _Count) to [_First1, ...)
        do { if (_Count <= _Size_in_bytes) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 340, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 340, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }

     static inline const _Elem* find(
          const _Elem* const _First, const size_t _Count, const _Elem& _Ch) noexcept { // strengthened
        // look for _Ch in [_First, _First + _Count)













#line 361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return static_cast<const _Elem*>(:: memchr(_First, _Ch, _Count));
#line 363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

    static _Elem* move(  _Elem* const _First1,   const _Elem* const _First2,
        const size_t _Count) noexcept { // strengthened
        // copy [_First2, _First2 + _Count) to [_First1, ...)
        return static_cast<_Elem*>(:: memmove(_First1, _First2, _Count));
    }

    static _Elem* assign(  _Elem* const _First, const size_t _Count,
        const _Elem _Ch) noexcept { // strengthened
        // assign _Count * _Ch to [_First, ...)
        return static_cast<_Elem*>(:: memset(_First, _Ch, _Count));
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept { // assign an element
        _Left = _Right;
    }

     static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        // test for element equality
        return _Left == _Right;
    }

     static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        // test if _Left precedes _Right
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }

     static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        // convert metacharacter to character
        return static_cast<_Elem>(_Meta);
    }

     static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        // convert character to metacharacter
        return static_cast<unsigned char>(_Ch);
    }

     static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        // test for metacharacter equality
        return _Left == _Right;
    }

     static constexpr int_type not_eof(const int_type& _Meta) noexcept { // return anything but EOF
        return _Meta != eof() ? _Meta : !eof();
    }

     static constexpr int_type eof() noexcept { // return end-of-file metacharacter
        return static_cast<int_type>((-1));
    }
};



// STRUCT char_traits<char> (FROM <string>)
template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element









#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data,
    const _SizeT _Size) { // insert a character-type sequence into _Ostr as if through a basic_string copy
    using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    } else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }

    const typename _Ostr_t::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else { // state okay, insert characters
        try {
        if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
            for (; 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        if (_State == _Ostr_t::goodbit
            && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
            _State |= _Ostr_t::badbit;
        } else {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(_Ostr_t::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

// STRUCT TEMPLATE _Char_traits_eq
template <class _Traits>
struct _Char_traits_eq {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const {
        return _Traits::eq(_Left, _Right);
    }
};

// STRUCT TEMPLATE _Char_traits_lt
template <class _Traits>
struct _Char_traits_lt {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const {
        return _Traits::lt(_Left, _Right);
    }
};

template <class _Elem>
struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
    : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
};

template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;

template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;

template <class _Traits>
constexpr bool _Traits_equal(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}

template <class _Traits>
constexpr int _Traits_compare(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
    const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));

    if (_Ans != 0) {
        return _Ans;
    }

    if (_Left_size < _Right_size) {
        return -1;
    }

    if (_Left_size > _Right_size) {
        return 1;
    }

    return 0;
}

template <class _Traits>
constexpr size_t _Traits_find(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept { // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle +
                                          // _Needle_size), at/after _Start_at
    if (_Needle_size > _Hay_size
        || _Start_at > _Hay_size - _Needle_size) { // xpos cannot exist, report failure
                                                   // N4659 24.3.2.7.2 [string.find]/1 says:
                                                   // 1. _Start_at <= xpos
                                                   // 2. xpos + _Needle_size <= _Hay_size;
                                                   // therefore:
                                                   // 3. _Needle_size <= _Hay_size (by 2) (checked above)
                                                   // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
                                                   // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to
                                                   // other side) (also checked above)
        return static_cast<size_t>(-1);
    }

    if (_Needle_size == 0) { // empty string always matches if xpos is possible
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { // didn't find first character; report failure
            return static_cast<size_t>(-1);
        }

        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}

template <class _Traits>
constexpr size_t _Traits_find_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }

    return static_cast<size_t>(-1); // (npos) no match
}

template <class _Traits>
constexpr size_t _Traits_rfind(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept { // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle +
                                          // _Needle_size) beginning before _Start_at
    if (_Needle_size == 0) {
        return _Min_value(_Start_at, _Hay_size); // empty string always matches
    }

    if (_Needle_size <= _Hay_size) { // room for match, look for it
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_rfind_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
    if (_Hay_size != 0) { // room for match, look for it
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap { // _String_bitmap for character types
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
        // mark this bitmap such that the characters in [_First, _Last) are intended to match
        // returns whether all inputs can be placed in the bitmap
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};

template <class _Elem>
class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");

    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) {
        // mark this bitmap such that the characters in [_First, _Last) are intended to match
        // returns whether all inputs can be placed in the bitmap
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }

            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};

template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
    // general algorithm
    if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
    // special case for std::char_traits
    if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
                                                                // fall back to the serial algorithm
            return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
    // general algorithm
    if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
    // special case for std::char_traits
    if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
                                                                // fall back to the serial algorithm
            return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
    // general algorithm
    if (_Start_at < _Hay_size) { // room for match, look for it
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
    // special case for std::char_traits
    if (_Start_at < _Hay_size) { // room for match, look for it
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
                                                                // fall back to the serial algorithm
            return _Traits_find_first_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
    if (_Start_at < _Hay_size) { // room for match, look for it
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
    // general algorithm
    if (_Hay_size != 0) { // worth searching, do it
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
    // special case for std::char_traits
    if (_Hay_size != 0) { // worth searching, do it
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
                                                                // fall back to the serial algorithm
            return _Traits_find_last_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
    if (_Hay_size != 0) { // room for match, look for it
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}


























































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1788 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

// CLASS TEMPLATE _String_const_iterator
template <class _Mystr>
class _String_const_iterator : public _Iterator_base { // iterator for immutable string
public:
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer         = typename _Mystr::const_pointer;
    using reference       = const value_type&;

    _String_const_iterator() : _Ptr() {} // construct with null pointer

    _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) : _Ptr(_Parg) {
        this->_Adopt(_Pstring);
    }

     reference operator*() const {

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1808, 0, "%s", "cannot dereference value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1808, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1811, 0, "%s", "cannot dereference string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1811, 0); } while (false); } ; } while (false);
#line 1813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr  = _Unfancy(_Ptr);
        do { if (_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1815, 0, "%s", "cannot dereference string iterator because it is out of range (e.g. an end iterator)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because it is out of range (e.g. an end iterator)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1815, 0); } while (false); } ; } while (false);
#line 1817 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
#line 1817 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        ;
        return *_Ptr;
    }

     pointer operator->() const {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _String_const_iterator& operator++() {

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1828, 0, "%s", "cannot increment value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1828, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1831, 0, "%s", "cannot increment string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1831, 0); } while (false); } ; } while (false);
#line 1833 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        do { if (_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1832, 0, "%s", "cannot increment string iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1832, 0); } while (false); } ; } while (false);
#line 1834 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        ++_Ptr;
        return *this;
    }

    _String_const_iterator operator++(int) {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _String_const_iterator& operator--() {

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1847, 0, "%s", "cannot decrement value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1847, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1850, 0, "%s", "cannot decrement string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1850, 0); } while (false); } ; } while (false);
#line 1852 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        do { if (_Mycont->_Myptr() < _Unfancy(_Ptr)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1851, 0, "%s", "cannot decrement string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1851, 0); } while (false); } ; } while (false);
#line 1853 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        --_Ptr;
        return *this;
    }

    _String_const_iterator operator--(int) {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    void _Verify_offset(const difference_type _Off) const noexcept {

        if (_Off == 0) {
            return;
        }

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1870, 0, "%s", "cannot seek value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1870, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1873, 0, "%s", "cannot seek string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1873, 0); } while (false); } ; } while (false);
#line 1875 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr  = _Unfancy(_Ptr);

        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Contptr - _Rawptr <= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1879, 0, "%s", "cannot seek string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1879, 0); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            using _Size_type = typename _Mystr::size_type;
            const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
            do { if (static_cast<_Size_type>(_Off) <= _Left) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1885, 0, "%s", "cannot seek string iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1885, 0); } while (false); } ; } while (false);
        }


#line 1890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

    _String_const_iterator& operator+=(const difference_type _Off) {

        _Verify_offset(_Off);
#line 1896 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        _Ptr += _Off;
        return *this;
    }

     _String_const_iterator operator+(const difference_type _Off) const {
        _String_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _String_const_iterator& operator-=(const difference_type _Off) {
        return *this += -_Off;
    }

     _String_const_iterator operator-(const difference_type _Off) const {
        _String_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

     difference_type operator-(const _String_const_iterator& _Right) const {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

     reference operator[](const difference_type _Off) const {
        return *(*this + _Off);
    }

     bool operator==(const _String_const_iterator& _Right) const {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }

     bool operator!=(const _String_const_iterator& _Right) const {
        return !(*this == _Right);
    }

     bool operator<(const _String_const_iterator& _Right) const {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

     bool operator>(const _String_const_iterator& _Right) const {
        return _Right < *this;
    }

     bool operator<=(const _String_const_iterator& _Right) const {
        return !(_Right < *this);
    }

     bool operator>=(const _String_const_iterator& _Right) const {
        return !(*this < _Right);
    }

    void _Compat(const _String_const_iterator& _Right) const { // test for compatible iterator pair

        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1952, 0, "%s", "string iterators incompatible (e.g." " point to different string instances)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible (e.g.\" \" point to different string instances)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1952, 0); } while (false); } ; } while (false);
#line 1954 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"


#line 1956 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }


    friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
        do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1960, 0, "%s", "string iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators in range are from different containers\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1960, 0); } while (false); } ; } while (false);
        do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1961, 0, "%s", "string iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 1961, 0); } while (false); } ; } while (false);
    }
#line 1964 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_const_iterator;

     const value_type* _Unwrapped() const {
        return _Unfancy(_Ptr);
    }

    void _Seek_to(const value_type* _It) {
        _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
    }

    pointer _Ptr; // pointer to element in string
};

template <class _Mystr>
 _String_const_iterator<_Mystr> operator+(
    typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) {
    return _Next += _Off;
}

// CLASS TEMPLATE _String_iterator
template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> { // iterator for mutable string
public:
    using _Mybase           = _String_const_iterator<_Mystr>;
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer         = typename _Mystr::pointer;
    using reference       = value_type&;

    _String_iterator() {} // construct with null string pointer

    _String_iterator(pointer _Parg, const _Container_base* _Pstring) : _Mybase(_Parg, _Pstring) {}

     reference operator*() const {
        return const_cast<reference>(_Mybase::operator*());
    }

     pointer operator->() const {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _String_iterator& operator++() {
        _Mybase::operator++();
        return *this;
    }

    _String_iterator operator++(int) {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _String_iterator& operator--() {
        _Mybase::operator--();
        return *this;
    }

    _String_iterator operator--(int) {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _String_iterator& operator+=(const difference_type _Off) {
        _Mybase::operator+=(_Off);
        return *this;
    }

     _String_iterator operator+(const difference_type _Off) const {
        _String_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _String_iterator& operator-=(const difference_type _Off) {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

     _String_iterator operator-(const difference_type _Off) const {
        _String_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

     reference operator[](const difference_type _Off) const {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

     value_type* _Unwrapped() const {
        return const_cast<value_type*>(_Unfancy(this->_Ptr));
    }
};

template <class _Mystr>
 _String_iterator<_Mystr> operator+(
    typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) {
    return _Next += _Off;
}

// basic_string TYPE WRAPPERS
template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _String_iter_types { // wraps types needed by iterators
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

// CLASS TEMPLATE _String_val
template <class _Val_types>
class _String_val : public _Container_base { // base class for basic_string to hold data
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

    // length of internal buffer, [1, 16]:
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    // roundup mask for allocated buffers, [0, 15]:
    static constexpr size_type _ALLOC_MASK =
        sizeof(value_type) <= 1
            ? 15
            : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;

    value_type* _Myptr() { // determine current pointer to buffer for mutable string
        value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    const value_type* _Myptr() const { // determine current pointer to buffer for immutable string
        const value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    bool _Large_string_engaged() const { // returns whether the large string mode (allocated memory) is engaged
        return _BUF_SIZE <= _Myres;
    }

    void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    [[noreturn]] static void _Xran() { // report an out_of_range error
        _Xout_of_range("invalid string position");
    }

    size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        // trims _Size to the longest it can be assuming a string at/after _Off
        return _Min_value(_Size, _Mysize - _Off);
    }

    union _Bxty { // storage for small buffer or pointer to larger one
        _Bxty() {} // user-provided, for fancy pointers

        ~_Bxty() noexcept {} // user-provided, for fancy pointers

        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; // retained for /clr bincompat; unused
    } _Bx;

    size_type _Mysize; // current length of string
    size_type _Myres; // current storage reserved for string
};

// CLASS TEMPLATE basic_string
template <class _Ty>
constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd

template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { // null-terminated transparent array of elements
private:
    friend _Tidy_deallocate_guard<basic_string>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;

    static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");

public:
    using traits_type    = _Traits;
    using allocator_type = _Alloc;

    using value_type      = _Elem;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using iterator       = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

private:
    static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;

    // When doing _String_val operations by memcpy, we are touching:
    //   _String_val::_Bx::_Buf (type is array of _Elem)
    //   _String_val::_Bx::_Ptr (type is pointer)
    //   _String_val::_Mysize   (type is size_type)
    //   _String_val::_Myres    (type is size_type)
    // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
    // We need to ask if pointer is safe to memcpy.
    // size_type must be an unsigned integral type so memcpy is safe.
    // We also need to disable memcpy if the user has supplied _Traits, since
    //   they can observe traits::assign and similar.
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    // This offset skips over the _Container_base members, if any
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;

    template <class _Iter>
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;






#line 2228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

public:
    basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        // construct by copying _Right
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }

    basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
        // construct by copying with allocator
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }

    basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t()) {
        // construct empty string
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }

    explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al) {
        // construct empty string with allocator
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }

    basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, <end>)
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Right, _Roff, npos);
        _Proxy._Release();
    }

    basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Right [_Roff, _Roff + _Count)
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Right, _Roff, _Count);
        _Proxy._Release();
    }

    basic_string(  const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t()) { // construct from [_Ptr, _Ptr + _Count)
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }

    basic_string(
          const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from [_Ptr, _Ptr + _Count) with allocator
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }

    basic_string(  const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {
        // construct from [_Ptr, <null>)
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }



#line 2309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    basic_string(  const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) {
        // construct from [_Ptr, <null>) with allocator
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }

    basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t()) {
        // construct from _Count * _Ch
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }



#line 2330 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ch with allocator
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }

    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {
        // construct from [_First, _Last) with optional allocator
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        _Adl_verify_range(_First, _Last);
        _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
        _Proxy._Release();
    }

    template <class _Iter>
    void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
        // initialize from [_First, _Last), input iterators
        _Tidy_deallocate_guard<basic_string> _Guard{this};
        for (; _First != _Last; ++_First) {
            push_back(*_First);
        }

        _Guard._Target = nullptr;
    }

    template <class _Iter>
    void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
        // initialize from [_First, _Last), forward iterators
        const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        reserve(_Count);
        _Construct(_First, _Last, input_iterator_tag());
    }

    void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
        // initialize from [_First, _Last), pointers
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }

    void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
        // initialize from [_First, _Last), const pointers
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }

    basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Right._Getal())) {
        // construct by moving _Right
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
    }

    basic_string(basic_string&& _Right, const _Alloc& _Al)
        noexcept(_Alty_traits::is_always_equal::value) // strengthened
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct by moving _Right, allocator
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        if
            constexpr(!_Alty_traits::is_always_equal::value) {
                if (_Getal() != _Right._Getal()) {
                    _Construct_lv_contents(_Right);
                    _Proxy._Release();
                    return;
                }
            }

        _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
        _Proxy._Release();
    }






















#line 2429 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

private:
    void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
        _Tidy_deallocate();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
    }

    void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            // intentionally slams into noexcept on OOM, TRANSITION, VSO#466800
            _Mypair._Myval2._Orphan_all();
            _Mypair._Myval2._Reload_proxy(
                static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
            _Pocma(_Getal(), _Right._Getal());
            _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
        }
    }

    void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

public:
    basic_string& operator=(basic_string&& _Right)
        noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }

        return *this;
    }

    basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std:: move(_Right))) {
        // assign by moving _Right
        *this = ::std:: move(_Right);
        return *this;
    }

private:
    void _Memcpy_val_from(const basic_string& _Right) noexcept {
        ; // TRANSITION, if constexpr
        const auto _My_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast<const unsigned char*>(::std:: addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    }

    void _Take_contents(basic_string& _Right, true_type) noexcept {
        // assign by stealing _Right's buffer, memcpy optimization
        // pre: this != &_Right
        // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
        // pre: *this owns no memory, iterators orphaned (note:
        // _Buf/_Ptr/_Mysize/_Myres may be garbage init)

        if (_Right._Mypair._Myval2._Large_string_engaged()) {
            // take ownership of _Right's iterators along with its buffer
            _Swap_proxy_and_iterators(_Right);
        } else {
            _Right._Mypair._Myval2._Orphan_all();
        }
#line 2498 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        _Memcpy_val_from(_Right);
        _Right._Tidy_init();
    }

    void _Take_contents(basic_string& _Right, false_type) noexcept {
        // assign by stealing _Right's buffer, general case
        // pre: this != &_Right
        // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
        // pre: *this owns no memory, iterators orphaned
        // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        if (_Right_data._Large_string_engaged()) { // steal buffer
            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = pointer();
            _Swap_proxy_and_iterators(_Right);
        } else { // copy small string buffer
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right_data._Orphan_all();
        }

        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres  = _Right_data._Myres;
        _Right._Tidy_init();
    }

    void _Construct_lv_contents(const basic_string& _Right) {
        // assign by copying data stored in _Right
        // pre: this != &_Right
        // pre: *this owns no memory, iterators orphaned (note:
        // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
        auto& _Right_data             = _Right._Mypair._Myval2;
        const size_type _Right_size   = _Right_data._Mysize;
        const _Elem* const _Right_ptr = _Right_data._Myptr();
        auto& _My_data                = _Mypair._Myval2;
        if (_Right_size < _BUF_SIZE) { // stay small, don't allocate
            _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
            _My_data._Mysize = _Right_size;
            _My_data._Myres  = _BUF_SIZE - 1;
            return;
        }

        auto& _Al                     = _Getal();
        const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
        const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws
        _Construct_in_place(_My_data._Bx._Ptr, _New_array);
        _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
        _My_data._Mysize = _Right_size;
        _My_data._Myres  = _New_capacity;
    }

public:
    basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from initializer_list
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }

    basic_string& operator=(initializer_list<_Elem> _Ilist) { // assign initializer_list
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    basic_string& operator+=(initializer_list<_Elem> _Ilist) { // append initializer_list
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    basic_string& assign(initializer_list<_Elem> _Ilist) { // assign initializer_list
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    basic_string& append(initializer_list<_Elem> _Ilist) { // append initializer_list
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) { // insert initializer_list

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 2578, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 2578, 0); } while (false); } ; } while (false);
#line 2580 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }

    basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
        // replace with initializer_list
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 2590, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 2590, 0); } while (false); } ; } while (false);
#line 2592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    ~basic_string() noexcept { // destroy the string
        _Tidy_deallocate();

        auto&& _Alproxy          = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        const auto _To_delete    = _Mypair._Myval2._Myproxy;
        _Mypair._Myval2._Myproxy = nullptr;
        _Delete_plain_internal(_Alproxy, _To_delete);
#line 2605 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
    }

    static constexpr auto npos{static_cast<size_type>(-1)};

private:
    void _Copy_assign_val_from_small(const basic_string& _Right) {
        // TRANSITION, VSO#761321; inline into only caller when that's fixed
        _Tidy_deallocate();
        if
            constexpr(_Can_memcpy_val) {
                _Memcpy_val_from(_Right);
            }
        else {
            _Traits::copy(
                _Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
            _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
            _Mypair._Myval2._Myres  = _Right._Mypair._Myval2._Myres;
        }
    }

    void _Copy_assign(const basic_string& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    void _Copy_assign(const basic_string& _Right, true_type) {
        auto& _Al             = _Getal();
        const auto& _Right_al = _Right._Getal();
        if (_Al == _Right_al) {
            _Copy_assign(_Right, false_type{});
            return;
        }

        auto&& _Alproxy       = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        auto&& _Right_alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right_al);
        _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws

        if (_Right._Mypair._Myval2._Large_string_engaged()) {
            const auto _New_size     = _Right._Mypair._Myval2._Mysize;
            const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
            auto _Right_al_non_const = _Right_al;
            const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); // throws
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
            _Tidy_deallocate();
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
            _Mypair._Myval2._Mysize  = _New_size;
            _Mypair._Myval2._Myres   = _New_capacity;
        } else {
            _Copy_assign_val_from_small(_Right);
        }

        _Pocca(_Al, _Right_al);
        _New_proxy._Bind(_Alproxy, ::std:: addressof(_Mypair._Myval2));
    }

public:
    basic_string& operator=(const basic_string& _Right) { // assign _Right
        if (this != ::std:: addressof(_Right)) { // different, assign it
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }






#line 2675 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& operator=(  const _Elem* const _Ptr) { // assign [_Ptr, <null>)
        return assign(_Ptr);
    }

    basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }

    basic_string& operator+=(const basic_string& _Right) { // append _Right
        return append(_Right);
    }






#line 2698 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& operator+=(  const _Elem* const _Ptr) { // append [_Ptr, <null>)
        return append(_Ptr);
    }

    basic_string& operator+=(_Elem _Ch) { // append 1 * _Ch
        push_back(_Ch);
        return *this;
    }

    basic_string& append(const basic_string& _Right) { // append _Right
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        // append _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }














#line 2733 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& append(  const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count) {
        // append [_Ptr, _Ptr + _Count)
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }

    basic_string& append(  const _Elem* const _Ptr) { // append [_Ptr, <null>)
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    basic_string& append(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) { // append _Count * _Ch
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }


    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string& append(const _Iter _First, const _Iter _Last) { // append [_First, _Last), input iterators
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }


















#line 2813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& assign(const basic_string& _Right) { // assign _Right
        *this = _Right;
        return *this;
    }

    basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        // assign _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }














#line 2840 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& assign(  const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count) {
        // assign [_Ptr, _Ptr + _Count)
        if (_Count <= _Mypair._Myval2._Myres) {
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }

    basic_string& assign(  const _Elem* const _Ptr) { // assign [_Ptr, <null>)
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    basic_string& assign(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch
        if (_Count <= _Mypair._Myval2._Myres) {
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }


    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string& assign(const _Iter _First, const _Iter _Last) {
        // assign [_First, _Last), input iterators
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }

























#line 2928 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        // insert _Right [_Roff, _Roff + _Count) at _Off
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }














#line 2955 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& insert(
        const size_type _Off,   const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count) {
        // insert [_Ptr, _Ptr + _Count) at _Off
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
            // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at
                || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias
                _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
            } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts
                _Ptr_shifted_after = 0;
            } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }

            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }

    basic_string& insert(const size_type _Off,   const _Elem* const _Ptr) { // insert [_Ptr, <null>) at _Off
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    basic_string& insert(const size_type _Off, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) {
        // insert _Count * _Ch at _Off
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
            _Traits::assign(_Insert_at, _Count, _Ch); // fill hole
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }

    iterator insert(const const_iterator _Where, const _Elem _Ch) { // insert _Ch at _Where

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3025, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3025, 0); } while (false); } ; } while (false);
#line 3027 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    iterator insert(const const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) {
        // insert _Count * _Elem at _Where

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3035, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3035, 0); } while (false); } ; } while (false);
#line 3037 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }


    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        // insert [_First, _Last) at _Where, input iterators

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3047, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3047, 0); } while (false); } ; } while (false);
#line 3049 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }
























#line 3087 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

    basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at    = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Mypair._Myval2._Mysize   = _New_size;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
        return *this;
    }

    iterator erase(const const_iterator _Where) { // erase element at _Where

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3108, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3108, 0); } while (false); } ; } while (false);
#line 3110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        erase(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }

    iterator erase(const const_iterator _First, const const_iterator _Last) { // erase substring [_First, _Last)
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3118, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3118, 0); } while (false); } ; } while (false);
#line 3120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        erase(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }

    void clear() noexcept { // erase all
        _Eos(0);
    }

    basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right) {
        // replace [_Off, _Off + _N0) with _Right
        return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    basic_string& replace(const size_type _Off, size_type _N0, const basic_string& _Right, const size_type _Roff,
        size_type _Count = npos) {
        // replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
















#line 3158 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& replace(
        const size_type _Off, size_type _N0,   const _Elem* const _Ptr, const size_type _Count) {
        // replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
        if (_N0 == _Count) { // size doesn't change, so a single move does the trick
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }

        const size_type _Old_size    = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
        if (_Count < _N0) { // suffix shifts backwards; we don't have to move anything out of the way
            _Mypair._Myval2._Mysize = _Old_size - (_N0 - _Count);
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
            return *this;
        }

        const size_type _Growth = static_cast<size_type>(_Count - _N0);
        if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits
            _Mypair._Myval2._Mysize = _Old_size + _Growth;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Elem* const _Suffix_at = _Insert_at + _N0;

            size_type _Ptr_shifted_after; // see rationale in insert
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                _Ptr_shifted_after = _Count;
            } else if (_Suffix_at <= _Ptr) {
                _Ptr_shifted_after = 0;
            } else {
                _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
            }

            _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
            // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
            // this case doesn't occur in insert because the new content must come from outside the removed
            // content there (because in insert there is no removed content)
            _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
            // the next case can be copy, because it comes from the chunk moved out of the way in the
            // first move, and the hole we're filling can't alias the chunk we moved out of the way
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _N0, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
            },
            _Off, _N0, _Ptr, _Count);
    }

    basic_string& replace(const size_type _Off, const size_type _N0,   const _Elem* const _Ptr) {
        // replace [_Off, _Off + _N0) with [_Ptr, <null>)
        return replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch) {
        // replace [_Off, _Off + _N0) with _Count * _Ch
        _Mypair._Myval2._Check_offset(_Off);
        _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
        if (_Count == _N0) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _N0
            || _Count - _N0 <= _Mypair._Myval2._Myres - _Old_size) { // either we are shrinking, or the growth fits
            _Mypair._Myval2._Mysize = _Old_size + _Count - _N0; // may temporarily overflow;
                                                                // OK because size_type must be unsigned
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count - _N0,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _N0, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
            },
            _Off, _N0, _Count, _Ch);
    }

    basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
        // replace [_First, _Last) with _Right
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3260, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3260, 0); } while (false); } ; } while (false);
#line 3262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }












#line 3278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    basic_string& replace(const const_iterator _First, const const_iterator _Last,
          const _Elem* const _Ptr, const size_type _Count) {
        // replace [_First, _Last) with [_Ptr, _Ptr + _Count)
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3284, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3284, 0); } while (false); } ; } while (false);
#line 3286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }

    basic_string& replace(const const_iterator _First, const const_iterator _Last,   const _Elem* const _Ptr) {
        // replace [_First, _Last) with [_Ptr, <null>)
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3294, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3294, 0); } while (false); } ; } while (false);
#line 3296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }

    basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
        // replace [_First, _Last) with _Count * _Ch
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3305, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3305, 0); } while (false); } ; } while (false);
#line 3307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }


    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        // replace [_First, _Last) with [_First2, _Last2), input iterators
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3318, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3318, 0); } while (false); } ; } while (false);
#line 3320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2  = _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        } else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }






























#line 3363 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     iterator begin() noexcept { // return iterator for beginning of mutable sequence
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

     const_iterator begin() const noexcept { // return iterator for beginning of immutable sequence
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

     iterator end() noexcept { // return iterator for end of mutable sequence
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

     const_iterator end() const noexcept { // return iterator for end of immutable sequence
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    _Elem* _Unchecked_begin() noexcept { // return pointer for beginning of mutable sequence
        return _Mypair._Myval2._Myptr();
    }

    const _Elem* _Unchecked_begin() const noexcept { // return pointer for beginning of immutable sequence
        return _Mypair._Myval2._Myptr();
    }

    _Elem* _Unchecked_end() noexcept { // return pointer for end of mutable sequence
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    const _Elem* _Unchecked_end() const noexcept { // return pointer for end of immutable sequence
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

     reverse_iterator rbegin() noexcept { // return iterator for beginning of reversed mutable sequence
        return reverse_iterator(end());
    }

     const_reverse_iterator rbegin() const noexcept {
        // return iterator for beginning of reversed immutable sequence
        return const_reverse_iterator(end());
    }

     reverse_iterator rend() noexcept { // return iterator for end of reversed mutable sequence
        return reverse_iterator(begin());
    }

     const_reverse_iterator rend() const noexcept { // return iterator for end of reversed immutable sequence
        return const_reverse_iterator(begin());
    }

     const_iterator cbegin() const noexcept { // return iterator for beginning of immutable sequence
        return begin();
    }

     const_iterator cend() const noexcept { // return iterator for end of immutable sequence
        return end();
    }

     const_reverse_iterator crbegin() const noexcept {
        // return iterator for beginning of reversed immutable sequence
        return rbegin();
    }

     const_reverse_iterator crend() const noexcept { // return iterator for end of reversed immutable sequence
        return rend();
    }

    void shrink_to_fit() { // reduce capacity
        auto& _My_data = _Mypair._Myval2;
        if (!_My_data._Large_string_engaged()) { // can't shrink from small mode
            return;
        }

        if (_My_data._Mysize < _BUF_SIZE) {
            _Become_small();
            return;
        }

        const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());
        if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it
            auto& _Al              = _Getal();
            const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws
            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres   = _Target_capacity;
        }
    }

     reference at(const size_type _Off) {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

     const_reference at(const size_type _Off) const {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

     reference operator[](const size_type _Off) noexcept { // strengthened

        do { if (_Off <= _Mypair._Myval2._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3469, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3469, 0); } while (false); } ; } while (false);
#line 3471 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }

     const_reference operator[](const size_type _Off) const noexcept { // strengthened

        do { if (_Off <= _Mypair._Myval2._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3476, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3476, 0); } while (false); } ; } while (false);
#line 3478 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }






#line 3487 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

    void push_back(const _Elem _Ch) { // insert element at end
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }

        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }

    void pop_back() { // erase element at end
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        do { if (_Old_size != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3511, 0, "%s", "invalid to pop_back empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid to pop_back empty string\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3511, 0); } while (false); } ; } while (false);
#line 3513 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        _Eos(_Old_size - 1);
    }

     reference front() {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3518, 0, "%s", "front() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty string\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3518, 0); } while (false); } ; } while (false);
#line 3520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

     const_reference front() const {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3526, 0, "%s", "front() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty string\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3526, 0); } while (false); } ; } while (false);
#line 3528 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

     reference back() {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3534, 0, "%s", "back() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty string\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3534, 0); } while (false); } ; } while (false);
#line 3536 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

     const_reference back() const {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3542, 0, "%s", "back() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty string\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring", 3542, 0); } while (false); } ; } while (false);
#line 3544 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

       const _Elem* c_str() const noexcept { // return pointer to null-terminated immutable array
        return _Mypair._Myval2._Myptr();
    }

       const _Elem* data() const noexcept { // return pointer to immutable array
        return _Mypair._Myval2._Myptr();
    }





#line 3561 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type length() const noexcept { // return length of sequence
        return _Mypair._Myval2._Mysize;
    }

     size_type size() const noexcept { // return length of sequence
        return _Mypair._Myval2._Mysize;
    }

     size_type max_size() const noexcept { // return maximum possible length of sequence
        const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = // can always store small string
            _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1 // -1 is for null terminator and/or npos
        );
    }

    void resize(__declspec(guard(overflow)) const size_type _Newsize, const _Elem _Ch = _Elem()) {
        // determine new length, padding with _Ch elements as needed
        const size_type _Old_size = size();
        if (_Newsize <= _Old_size) {
            _Eos(_Newsize);
        } else {
            append(_Newsize - _Old_size, _Ch);
        }
    }

     size_type capacity() const noexcept { // return current length of allocated storage
        return _Mypair._Myval2._Myres;
    }

    void reserve(__declspec(guard(overflow)) const size_type _Newcap = 0) { // determine new minimum length of allocated storage
        if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore
            return; // nothing to do
        }

        if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity
            return; // nothing to do
        }

        if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            _Reallocate_grow_by(
                _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                });

            _Mypair._Myval2._Mysize = _Old_size;
            return;
        }

        if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {
            // deallocate everything; switch back to "small" mode
            _Become_small();
            return;
        }

        // ignore requests to reserve to [_BUF_SIZE, _Myres)
    }

     bool empty() const noexcept { // test if sequence is empty
        return size() == 0;
    }

    size_type copy(  _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        // copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

      size_type _Copy_s(  _Elem* const _Dest,
        const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
        // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Dest_size)
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    void _Swap_data(basic_string& _Right, true_type) {
        // exchange _String_val instances with _Right, memcpy optimization
        const auto _My_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        unsigned char _Temp_mem[_Memcpy_val_size];
        :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
        :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);
    }

    void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) {
        // exchange a string in large mode with one in small mode
        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Destroy_in_place(_Starts_large._Bx._Ptr);
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }

    void _Swap_data(basic_string& _Right, false_type) {
        // exchange _String_val instances with _Right, general case
        auto& _My_data          = _Mypair._Myval2;
        auto& _Right_data       = _Right._Mypair._Myval2;
        const bool _My_large    = _My_data._Large_string_engaged();
        const bool _Right_large = _Right_data._Large_string_engaged();
        if (_My_large) {
            if (_Right_large) { // swap buffers, iterators preserved
                _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            } else { // swap large with small
                _Swap_bx_large_with_small(_My_data, _Right_data);
            }
        } else {
            if (_Right_large) { // swap small with large
                _Swap_bx_large_with_small(_Right_data, _My_data);
            } else {
                _Elem _Temp_buf[_BUF_SIZE];
                _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _BUF_SIZE);
            }
        }

        ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        ::std:: swap(_My_data._Myres, _Right_data._Myres);
    }

    void swap(basic_string& _Right) noexcept { // strengthened
        // exchange contents with _Right
        if (this != ::std:: addressof(_Right)) { // (maybe) swap allocators, swap control information
            _Pocs(_Getal(), _Right._Getal());


            const bool _My_large    = _Mypair._Myval2._Large_string_engaged();
            const bool _Right_large = _Right._Mypair._Myval2._Large_string_engaged();
            if (!_My_large) {
                _Mypair._Myval2._Orphan_all();
            }

            if (!_Right_large) {
                _Right._Mypair._Myval2._Orphan_all();
            }

            if (_My_large || _Right_large) {
                _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
            }
#line 3710 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
        }

        _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
    }









#line 3724 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        // look for _Right beginning at or after _Off
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

     size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { // strengthened
        // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

     size_type find(  const _Elem* const _Ptr, const size_type _Off = 0) const noexcept { // strengthened
        // look for [_Ptr, <null>) beginning at or after _Off
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

     size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept { // strengthened
        // look for _Ch at or after _Off
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 3759 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        // look for _Right beginning before _Off
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

     size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { // strengthened
        // look for [_Ptr, _Ptr + _Count) beginning before _Off
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

     size_type rfind(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { // strengthened
        // look for [_Ptr, <null>) beginning before _Off
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

     size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept { // strengthened
        // look for _Ch before _Off
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 3795 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type find_first_of(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        // look for one of _Right at or after _Off
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { // strengthened
        // look for one of [_Ptr, _Ptr + _Count) at or after _Off
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off = 0) const
        noexcept { // strengthened
        // look for one of [_Ptr, <null>) at or after _Off
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept { // strengthened
        // look for _Ch at or after _Off
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 3832 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
        // look for one of _Right before _Off
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { // strengthened
        // look for one of [_Ptr, _Ptr + _Count) before _Off
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { // strengthened
        // look for one of [_Ptr, <null>) before _Off
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept { // strengthened
        // look for _Ch before _Off
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }










#line 3870 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type find_first_not_of(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        // look for none of _Right at or after _Off
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_first_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { // strengthened
        // look for none of [_Ptr, _Ptr + _Count) at or after _Off
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_first_not_of(  const _Elem* const _Ptr, size_type _Off = 0) const
        noexcept { // strengthened
        // look for one of [_Ptr, <null>) at or after _Off
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept { // strengthened
        // look for non _Ch at or after _Off
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }










#line 3908 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     size_type find_last_not_of(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        // look for none of _Right before _Off
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { // strengthened
        // look for none of [_Ptr, _Ptr + _Count) before _Off
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { // strengthened
        // look for none of [_Ptr, <null>) before _Off
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

     size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept { // strengthened
        // look for non _Ch before _Off
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }






#line 3942 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const {
        // return [_Off, _Off + _Count) as new string
        return basic_string(*this, _Off, _Count, get_allocator());
    }

    bool _Equal(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right for equality
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    bool _Equal(  const _Elem* const _Ptr) const noexcept { // compare [0, size()) with _Ptr for equality
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }




























#line 3985 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     int compare(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

     int compare(size_type _Off, size_type _N0, const basic_string& _Right) const {
        // compare [_Off, _Off + _N0) with _Right
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _N0),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

     int compare(const size_type _Off, const size_type _N0, const basic_string& _Right, const size_type _Roff,
        const size_type _Count = npos) const {
        // compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _N0),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

     int compare(  const _Elem* const _Ptr) const noexcept { // strengthened
        // compare [0, size()) with [_Ptr, <null>)
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

     int compare(const size_type _Off, const size_type _N0,   const _Elem* const _Ptr) const {
        // compare [_Off, _Off + _N0) with [_Ptr, <null>)
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _N0),
            _Ptr, _Traits::length(_Ptr));
    }

     int compare(const size_type _Off, const size_type _N0,   const _Elem* const _Ptr,
        const size_type _Count) const { // compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _N0), _Ptr, _Count);
    }































#line 4057 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

     allocator_type get_allocator() const noexcept { // return allocator object for values
        return static_cast<allocator_type>(_Getal());
    }

private:
     static size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if (_Masked > _Max) { // the mask overflows, settle for max_size()
            return _Max;
        }

        if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
            return _Max;
        }

        return _Max_value(_Masked, _Old + _Old / 2);
    }

     size_type _Calculate_growth(const size_type _Requested) const noexcept {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }

    template <class _Fty, class... _ArgTys>
    basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        // reallocate to store exactly _New_size elements, new buffer prepared by
        // _Fn(_New_ptr, _New_size, _Args...)
        if (_New_size > max_size()) {
            _Xlen(); // result too long
        }

        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws
        _Mypair._Myval2._Orphan_all();
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres  = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_BUF_SIZE <= _Old_capacity) {
            _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        } else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        }

        return *this;
    }

    template <class _Fty, class... _ArgTys>
    basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        // reallocate to increase size by _Size_increase elements, new buffer prepared by
        // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
        auto& _My_data            = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen(); // result too long
        }

        const size_type _New_size     = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws
        _My_data._Orphan_all();
        _My_data._Mysize      = _New_size;
        _My_data._Myres       = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_BUF_SIZE <= _Old_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Al.deallocate(_Old_ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        }

        return *this;
    }

    void _Become_small() {
        // release any held storage and return to small string mode
        // pre: *this is in large string mode
        // pre: this is small enough to return to small string mode
        _Mypair._Myval2._Orphan_all();
        const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
        auto& _Al          = _Getal();
        _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
        _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);
        _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
        _Mypair._Myval2._Myres = _BUF_SIZE - 1;
    }

    void _Eos(const size_type _Newsize) { // set new length and null terminator
        _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());
    }

    void _Tidy_init() noexcept { // initialize basic_string data members
        _Mypair._Myval2._Mysize = 0;
        _Mypair._Myval2._Myres  = _BUF_SIZE - 1;
        // the _Traits::assign is last so the codegen doesn't think the char
        // write can alias this
        _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());
    }

    void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage
        _Mypair._Myval2._Orphan_all();
        if (_Mypair._Myval2._Large_string_engaged()) {
            const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
            auto& _Al          = _Getal();
            _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
            _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
        }

        _Mypair._Myval2._Mysize = 0;
        _Mypair._Myval2._Myres  = _BUF_SIZE - 1;
        // the _Traits::assign is last so the codegen doesn't think the char
        // write can alias this
        _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());
    }

    [[noreturn]] static void _Xlen() { // report a length_error
        _Xlength_error("string too long");
    }

public:
    void _Orphan_all() noexcept { // orphan all iterators, used by filesystem::path
        _Mypair._Myval2._Orphan_all();
    }

private:
    void _Swap_proxy_and_iterators(basic_string& _Right) { // swap all iterators
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    _Alty& _Getal() noexcept { // return reference to allocator
        return _Mypair._Get_first();
    }

    const _Alty& _Getal() const noexcept { // return const reference to allocator
        return _Mypair._Get_first();
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};

















#line 4222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

template <class _Elem, class _Traits, class _Alloc>
void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // strengthened
    // swap _Left and _Right strings
    _Left.swap(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    // return string + string
    basic_string<_Elem, _Traits, _Alloc> _Ans;
    _Ans.reserve(_Left.size() + _Right.size());
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { // return NTCTS + string
    using _String_type = basic_string<_Elem, _Traits, _Alloc>;
    using _Size_type   = typename _String_type::size_type;
    _String_type _Ans;
    _Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { // return character + string
    basic_string<_Elem, _Traits, _Alloc> _Ans;
    _Ans.reserve(1 + _Right.size());
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { // return string + NTCTS
    using _String_type = basic_string<_Elem, _Traits, _Alloc>;
    using _Size_type   = typename _String_type::size_type;
    _String_type _Ans;
    _Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const _Elem _Right) { // return string + character
    basic_string<_Elem, _Traits, _Alloc> _Ans;
    _Ans.reserve(_Left.size() + 1);
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>&& _Right) { // return string + string
    return ::std:: move(_Right.insert(0, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) { // return string + string
    return ::std:: move(_Left.append(_Right));
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
    basic_string<_Elem, _Traits, _Alloc>&& _Right) { // return string + string
    if (_Right.size() <= _Left.capacity() - _Left.size() || _Right.capacity() - _Right.size() < _Left.size()) {
        return ::std:: move(_Left.append(_Right));
    } else {
        return ::std:: move(_Right.insert(0, _Left));
    }
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) { // return NTCTS + string
    return ::std:: move(_Right.insert(0, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) { // return character + string
    return ::std:: move(_Right.insert(0, 1, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
      const _Elem* const _Right) { // return string + NTCTS
    return ::std:: move(_Left.append(_Right));
}

template <class _Elem, class _Traits, class _Alloc>
 basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
    const _Elem _Right) { // return string + character
    _Left.push_back(_Right);
    return ::std:: move(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // test for string equality
    return _Left._Equal(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator==(  const _Elem* const _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) { // test for NTCTS vs. string equality
    return _Right._Equal(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { // test for string vs. NTCTS equality
    return _Left._Equal(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // test for string inequality
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator!=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    // test for NTCTS vs. string inequality
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    // test for string vs. NTCTS inequality
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // test if string < string
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator<(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    // test if NTCTS < string
    return _Right.compare(_Left) > 0;
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    // test if string < NTCTS
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // test if string > string
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator>(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    // test if NTCTS > string
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    // test if string > NTCTS
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // test if string <= string
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator<=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    // test if NTCTS <= string
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    // test if string <= NTCTS
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { // test if string >= string
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator>=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    // test if NTCTS >= string
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
 bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    // test if string >= NTCTS
    return !(_Left < _Right);
}

using string  = basic_string<char, char_traits<char>, allocator<char>>;
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;



using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

// STRUCT TEMPLATE SPECIALIZATION hash
template <class _Elem, class _Traits, class _Alloc>
struct hash<basic_string<_Elem, _Traits, _Alloc>> { // hash functor for basic_string
     typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
     typedef size_t result_type;

     size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const noexcept {
        // hash _Keyval to size_t value by pseudorandomizing transform
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};

// basic_string INSERTERS AND EXTRACTORS
template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) { // extract a string
    using _Myis   = basic_istream<_Elem, _Traits>;
    using _Ctype  = typename _Myis::_Ctype;
    using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { // state okay, extract characters
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();

        try {
        _Mysizt _Size;
        if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
            _Size = static_cast<_Mysizt>(_Istr.width());
        } else {
            _Size = _Str.max_size();
        }

        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                _State |= _Myis::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; // whitespace, quit
            } else { // add character to string
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }

    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return _Istr;
}

template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) { // extract a string
    return ::std:: move(_Istr) >> _Str;
}

template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) { // insert a string
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

// basic_string LITERALS
inline namespace literals {
    inline namespace string_literals {
         inline string operator"" s(const char* _Str, size_t _Len) {
            // construct literal from [_Str, _Str + _Len)
            return string(_Str, _Len);
        }

         inline wstring operator"" s(const wchar_t* _Str, size_t _Len) {
            // construct literal from [_Str, _Str + _Len)
            return wstring(_Str, _Len);
        }






#line 4541 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

         inline u16string operator"" s(
            const char16_t* _Str, size_t _Len) { // construct literal from [_Str, _Str + _Len)
            return u16string(_Str, _Len);
        }

         inline u32string operator"" s(const char32_t* _Str, size_t _Len) {
            // construct literal from [_Str, _Str + _Len)
            return u32string(_Str, _Len);
        }
    } // namespace string_literals
} // namespace literals














#line 4568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
}



#pragma warning(pop)
#pragma pack(pop)
#line 4575 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"
#line 4576 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xstring"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )



namespace std {
// CLASS logic_error
class logic_error : public exception { // base of all logic-error exceptions
public:
    using _Mybase = exception;

    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit logic_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS domain_error
class domain_error : public logic_error { // base of all domain-error exceptions
public:
    using _Mybase = logic_error;

    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit domain_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS invalid_argument
class invalid_argument : public logic_error { // base of all invalid-argument exceptions
public:
    using _Mybase = logic_error;

    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit invalid_argument(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS length_error
class length_error : public logic_error { // base of all length-error exceptions
public:
    using _Mybase = logic_error;

    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit length_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS out_of_range
class out_of_range : public logic_error { // base of all out-of-range exceptions
public:
    using _Mybase = logic_error;

    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit out_of_range(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS runtime_error
class runtime_error : public exception { // base of all runtime-error exceptions
public:
    using _Mybase = exception;

    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit runtime_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS overflow_error
class overflow_error : public runtime_error { // base of all overflow-error exceptions
public:
    using _Mybase = runtime_error;

    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit overflow_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS underflow_error
class underflow_error : public runtime_error { // base of all underflow-error exceptions
public:
    using _Mybase = runtime_error;

    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit underflow_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

// CLASS range_error
class range_error : public runtime_error { // base of all range-error exceptions
public:
    using _Mybase = runtime_error;

    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string
    }

    explicit range_error(const char* _Message) : _Mybase(_Message) { // construct from message string
    }








#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
};

[[noreturn]] inline void _Throw_range_error(const char* const _Message) {
    throw range_error{_Message};
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"
#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\stdexcept"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xcall_once.h"
// xcall_once.h internal header
#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// STRUCT once_flag
struct once_flag { // opaque data structure for call_once()
    constexpr once_flag() noexcept : _Opaque(nullptr) {}

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;

    void* _Opaque;
};

using _Execute_once_fp_t = int(__stdcall*)(void*, void*, void**);

 int __cdecl _Execute_once(
    once_flag& _Flag, _Execute_once_fp_t _Callback, void* _Pv) noexcept;
























template <class _Ty>
int __stdcall _Immortalize_impl(void*, void* _Storage_ptr, void**) noexcept {
    // adapt True Placement New to _Execute_once
    ::new (_Storage_ptr) _Ty();
    return 1;
}

template <class _Ty>
_Ty& _Immortalize() { // return a reference to an object that will live forever
    static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO#406237");
    static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO#406237");
    static void* _Flag = nullptr;
    static aligned_union_t<1, _Ty> _Storage;
    if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0) {
        // _Execute_once should never fail if the callback never fails
        ::std:: terminate();
    }

    return reinterpret_cast<_Ty&>(_Storage);
}
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xcall_once.h"

}



#pragma warning(pop)
#pragma pack(pop)
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xcall_once.h"
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xcall_once.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xerrc.h"
// xerrc.h internal header
#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// ENUM CLASS errc
enum class errc { // names for generic error codes
    address_family_not_supported       = 102, // EAFNOSUPPORT
    address_in_use                     = 100, // EADDRINUSE
    address_not_available              = 101, // EADDRNOTAVAIL
    already_connected                  = 113, // EISCONN
    argument_list_too_long             = 7, // E2BIG
    argument_out_of_domain             = 33, // EDOM
    bad_address                        = 14, // EFAULT
    bad_file_descriptor                = 9, // EBADF
    bad_message                        = 104, // EBADMSG
    broken_pipe                        = 32, // EPIPE
    connection_aborted                 = 106, // ECONNABORTED
    connection_already_in_progress     = 103, // EALREADY
    connection_refused                 = 107, // ECONNREFUSED
    connection_reset                   = 108, // ECONNRESET
    cross_device_link                  = 18, // EXDEV
    destination_address_required       = 109, // EDESTADDRREQ
    device_or_resource_busy            = 16, // EBUSY
    directory_not_empty                = 41, // ENOTEMPTY
    executable_format_error            = 8, // ENOEXEC
    file_exists                        = 17, // EEXIST
    file_too_large                     = 27, // EFBIG
    filename_too_long                  = 38, // ENAMETOOLONG
    function_not_supported             = 40, // ENOSYS
    host_unreachable                   = 110, // EHOSTUNREACH
    identifier_removed                 = 111, // EIDRM
    illegal_byte_sequence              = 42, // EILSEQ
    inappropriate_io_control_operation = 25, // ENOTTY
    interrupted                        = 4, // EINTR
    invalid_argument                   = 22, // EINVAL
    invalid_seek                       = 29, // ESPIPE
    io_error                           = 5, // EIO
    is_a_directory                     = 21, // EISDIR
    message_size                       = 115, // EMSGSIZE
    network_down                       = 116, // ENETDOWN
    network_reset                      = 117, // ENETRESET
    network_unreachable                = 118, // ENETUNREACH
    no_buffer_space                    = 119, // ENOBUFS
    no_child_process                   = 10, // ECHILD
    no_link                            = 121, // ENOLINK
    no_lock_available                  = 39, // ENOLCK
    no_message_available               = 120, // ENODATA
    no_message                         = 122, // ENOMSG
    no_protocol_option                 = 123, // ENOPROTOOPT
    no_space_on_device                 = 28, // ENOSPC
    no_stream_resources                = 124, // ENOSR
    no_such_device_or_address          = 6, // ENXIO
    no_such_device                     = 19, // ENODEV
    no_such_file_or_directory          = 2, // ENOENT
    no_such_process                    = 3, // ESRCH
    not_a_directory                    = 20, // ENOTDIR
    not_a_socket                       = 128, // ENOTSOCK
    not_a_stream                       = 125, // ENOSTR
    not_connected                      = 126, // ENOTCONN
    not_enough_memory                  = 12, // ENOMEM
    not_supported                      = 129, // ENOTSUP
    operation_canceled                 = 105, // ECANCELED
    operation_in_progress              = 112, // EINPROGRESS
    operation_not_permitted            = 1, // EPERM
    operation_not_supported            = 130, // EOPNOTSUPP
    operation_would_block              = 140, // EWOULDBLOCK
    owner_dead                         = 133, // EOWNERDEAD
    permission_denied                  = 13, // EACCES
    protocol_error                     = 134, // EPROTO
    protocol_not_supported             = 135, // EPROTONOSUPPORT
    read_only_file_system              = 30, // EROFS
    resource_deadlock_would_occur      = 36, // EDEADLK
    resource_unavailable_try_again     = 11, // EAGAIN
    result_out_of_range                = 34, // ERANGE
    state_not_recoverable              = 127, // ENOTRECOVERABLE
    stream_timeout                     = 137, // ETIME
    text_file_busy                     = 139, // ETXTBSY
    timed_out                          = 138, // ETIMEDOUT
    too_many_files_open_in_system      = 23, // ENFILE
    too_many_files_open                = 24, // EMFILE
    too_many_links                     = 31, // EMLINK
    too_many_symbolic_link_levels      = 114, // ELOOP
    value_too_large                    = 132, // EOVERFLOW
    wrong_protocol_type                = 136 // EPROTOTYPE
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xerrc.h"
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xerrc.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// ENUM CLASS io_errc
enum class io_errc { // error codes for ios_base::failure
    stream = 1
};

// STRUCT TEMPLATE is_error_code_enum
template <class _Enum>
struct is_error_code_enum : false_type { // tests for error_code enumeration
};

template <>
struct is_error_code_enum<io_errc> : true_type { // tests for error_condition enumeration
};

template <class _Ty>
 constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

// STRUCT TEMPLATE is_error_condition_enum
template <class _Enum>
struct is_error_condition_enum : false_type { // tests for error_condition enumeration
};

template <>
struct is_error_condition_enum<errc> : true_type { // tests for error_condition enumeration
};

template <class _Ty>
 constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

class error_code;
class error_condition;
 error_code make_error_code(errc) noexcept;
 error_code make_error_code(io_errc) noexcept;
 error_condition make_error_condition(errc) noexcept;
 error_condition make_error_condition(io_errc) noexcept;

// CLASS error_category
class error_category;

 const error_category& generic_category() noexcept;
 const error_category& iostream_category() noexcept;
 const error_category& system_category() noexcept;

class __declspec(novtable) error_category { // categorize an error
public:
    /* constexpr */ error_category() noexcept { // TRANSITION, ABI
        _Addr = reinterpret_cast<uintptr_t>(this);
    }

    virtual ~error_category() noexcept {}

     virtual const char* name() const noexcept = 0;

     virtual string message(int _Errval) const = 0;

     virtual error_condition default_error_condition(int _Errval) const noexcept;

     virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

     virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

     bool operator==(const error_category& _Right) const noexcept { // compare categories for equality
        return _Addr == _Right._Addr;
    }

     bool operator!=(const error_category& _Right) const noexcept { // compare categories for inequality
        return !(*this == _Right);
    }

     bool operator<(const error_category& _Right) const noexcept { // compare categories for order
        return _Addr < _Right._Addr;
    }

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

protected:
    uintptr_t _Addr;

    enum : uintptr_t { // imaginary addresses for Standard error_category objects
        _Future_addr   = 1,
        _Generic_addr  = 3,
        _Iostream_addr = 5,
        _System_addr   = 7
    };
};

// CLASS error_code
class error_code { // store an implementation-specific error code and category
public:
    error_code() noexcept : _Myval(0), _Mycat(&system_category()) { // construct non-error
    }

    error_code(int _Val, const error_category& _Cat) noexcept
        : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) { // construct from enumerated error code
        *this = make_error_code(_Errcode); // using ADL
    }

    void assign(int _Val, const error_category& _Cat) noexcept { // assign error code and category
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept { // assign enumerated error code

        *this = make_error_code(_Errcode); // using ADL
        return *this;
    }

    void clear() noexcept { // assign non-error
        _Myval = 0;
        _Mycat = &system_category();
    }

     int value() const noexcept { // get error code
        return _Myval;
    }

     const error_category& category() const noexcept { // get category
        return *_Mycat;
    }

     error_condition default_error_condition() const noexcept;

     string message() const { // get name of error code
        return category().message(value());
    }

    explicit operator bool() const noexcept { // test for actual error
        return value() != 0;
    }

private:
    int _Myval; // the stored error number
    const error_category* _Mycat; // pointer to error category
};

// CLASS error_condition
class error_condition { // store an abstract error code and category
public:
    error_condition() noexcept : _Myval(0), _Mycat(&generic_category()) { // construct non-error
    }

    error_condition(int _Val, const error_category& _Cat) noexcept
        : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) { // construct from enumerated error code
        *this = make_error_condition(_Errcode); // using ADL
    }

    void assign(int _Val, const error_category& _Cat) noexcept { // assign error code and category
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept { // assign enumerated error code

        *this = make_error_condition(_Errcode); // using ADL
        return *this;
    }

    void clear() noexcept { // assign non-error
        _Myval = 0;
        _Mycat = &generic_category();
    }

     int value() const noexcept { // get error code
        return _Myval;
    }

     const error_category& category() const noexcept { // get category
        return *_Mycat;
    }

     string message() const { // get name of error code
        return category().message(value());
    }

    explicit operator bool() const noexcept { // test for actual error
        return value() != 0;
    }

private:
    int _Myval; // the stored error number
    const error_category* _Mycat; // pointer to error category
};

// operator== FOR error_code/error_condition
 inline bool operator==(
    const error_code& _Left, const error_code& _Right) noexcept { // test errors for equality
    return _Left.category() == _Right.category() && _Left.value() == _Right.value();
}

 inline bool operator==(
    const error_code& _Left, const error_condition& _Right) noexcept { // test errors for equality
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}

 inline bool operator==(
    const error_condition& _Left, const error_code& _Right) noexcept { // test errors for equality
    return _Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value());
}

 inline bool operator==(
    const error_condition& _Left, const error_condition& _Right) noexcept { // test errors for equality
    return _Left.category() == _Right.category() && _Left.value() == _Right.value();
}

// operator!= FOR error_code/error_condition
 inline bool operator!=(
    const error_code& _Left, const error_code& _Right) noexcept { // test errors for inequality
    return !(_Left == _Right);
}

 inline bool operator!=(
    const error_code& _Left, const error_condition& _Right) noexcept { // test errors for inequality
    return !(_Left == _Right);
}

 inline bool operator!=(
    const error_condition& _Left, const error_code& _Right) noexcept { // test errors for inequality
    return !(_Left == _Right);
}

 inline bool operator!=(
    const error_condition& _Left, const error_condition& _Right) noexcept { // test errors for inequality
    return !(_Left == _Right);
}

// operator< FOR error_code/error_condition
 inline bool operator<(const error_code& _Left, const error_code& _Right) noexcept { // test if _Left < _Right
    return _Left.category() < _Right.category()
           || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
}

 inline bool operator<(
    const error_condition& _Left, const error_condition& _Right) noexcept { // test if _Left < _Right
    return _Left.category() < _Right.category()
           || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
}

// VIRTUALS FOR error_category
 inline error_condition error_category::default_error_condition(int _Errval) const
    noexcept { // make error_condition for error code
    return error_condition(_Errval, *this);
}

 inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const
    noexcept { // test if error code same condition
    return default_error_condition(_Errval) == _Cond;
}

 inline bool error_category::equivalent(const error_code& _Code, int _Errval) const
    noexcept { // test if conditions same for this category
    return *this == _Code.category() && _Code.value() == _Errval;
}

// MEMBER FUNCTIONS for error_code
 inline error_condition error_code::default_error_condition() const
    noexcept { // make error_condition for error code
    return category().default_error_condition(value());
}

// FUNCTION make_error_code
 inline error_code make_error_code(errc _Errno) noexcept { // make an error_code
    return error_code(static_cast<int>(_Errno), generic_category());
}

 inline error_code make_error_code(io_errc _Errno) noexcept { // make an error_code
    return error_code(static_cast<int>(_Errno), iostream_category());
}

// FUNCTION make_error_condition
 inline error_condition make_error_condition(errc _Errno) noexcept { // make an error_condition
    return error_condition(static_cast<int>(_Errno), generic_category());
}

 inline error_condition make_error_condition(io_errc _Errno) noexcept { // make an error_condition
    return error_condition(static_cast<int>(_Errno), iostream_category());
}

// STRUCT TEMPLATE SPECIALIZATION hash
template <>
struct hash<error_code> { // hash functor for error_code
     typedef error_code argument_type;
     typedef size_t result_type;

     size_t operator()(const error_code& _Keyval) const
        noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return hash<int>{}(_Keyval.value());
    }
};

template <>
struct hash<error_condition> { // hash functor for error_condition
     typedef error_condition argument_type;
     typedef size_t result_type;

     size_t operator()(const error_condition& _Keyval) const
        noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return hash<int>{}(_Keyval.value());
    }
};

// CLASS system_error
class _System_error : public runtime_error { // base of all system-error exceptions
private:
    static string _Makestr(error_code _Errcode, string _Message) { // compose error message
        if (!_Message.empty()) {
            _Message.append(": ");
        }

        _Message.append(_Errcode.message());
        return _Message;
    }

protected:
    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)),
          _Mycode(_Errcode) { // construct from error code and message string
    }

    error_code _Mycode; // the stored error code
};

class system_error : public _System_error { // base of all system-error exceptions
private:
    using _Mybase = _System_error;

public:
    system_error(error_code _Errcode) : _Mybase(_Errcode, "") { // construct from error code
    }

    system_error(error_code _Errcode, const string& _Message)
        : _Mybase(_Errcode, _Message) { // construct from error code and message string
    }

    system_error(error_code _Errcode, const char* _Message)
        : _Mybase(_Errcode, _Message) { // construct from error code and message string
    }

    system_error(int _Errval, const error_category& _Errcat)
        : _Mybase(error_code(_Errval, _Errcat), "") { // construct from error code components
    }

    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) { // construct from error code components and message string
    }

    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) { // construct from error code components and message string
    }

     const error_code& code() const noexcept { // return stored error code
        return _Mycode;
    }








#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"
};

[[noreturn]] inline void _Throw_system_error(const errc _Errno) {
    throw system_error{::std:: make_error_code(_Errno)};
}

 const char* __cdecl _Syserror_map(int);
 int __cdecl _Winerror_map(int);
 unsigned long __cdecl _Winerror_message(
    unsigned long _Message_id, char* _Narrow, unsigned long _Size);

// CLASS _Generic_error_category
class _Generic_error_category : public error_category { // categorize a generic error
public:
    _Generic_error_category() noexcept {
        _Addr = _Generic_addr;
    }

     virtual const char* name() const noexcept override { // get name of category
        return "generic";
    }

     virtual string message(int _Errcode) const override { // convert to name of error
        return _Syserror_map(_Errcode);
    }
};

// CLASS _Iostream_error_category
class _Iostream_error_category : public _Generic_error_category { // categorize an iostream error
public:
    _Iostream_error_category() noexcept {
        _Addr = _Iostream_addr;
    }

     virtual const char* name() const noexcept override { // get name of category
        return "iostream";
    }

     virtual string message(int _Errcode) const override { // convert to name of error
        if (_Errcode == static_cast<int>(io_errc::stream)) {
            return "iostream stream error";
        } else {
            return _Generic_error_category::message(_Errcode);
        }
    }
};

// CLASS _System_error_category
class _System_error_category : public error_category { // categorize an operating system error
public:
    _System_error_category() noexcept {
        _Addr = _System_addr;
    }

     virtual const char* name() const noexcept override { // get name of category
        return "system";
    }

     virtual string message(int _Errcode) const override { // convert to name of error
        const unsigned long _Size = 32767;
        string _Narrow(_Size, '\0');

        const unsigned long _Val = _Winerror_message(static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);
        if (_Val == 0) {
            _Narrow = "unknown error";
        } else {
            _Narrow.resize(_Val);
        }

        _Narrow.shrink_to_fit();
        return _Narrow;
    }

     virtual error_condition default_error_condition(int _Errval) const
        noexcept override { // make error_condition for error code (generic if possible)
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, system_category());
        } else {
            return error_condition(_Posv, generic_category());
        }
    }
};

 inline const error_category& generic_category() noexcept { // get generic_category
    return _Immortalize<_Generic_error_category>();
}

 inline const error_category& iostream_category() noexcept { // get iostream_category
    return _Immortalize<_Iostream_error_category>();
}

 inline const error_category& system_category() noexcept { // get system_category
    return _Immortalize<_System_error_category>();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"
#line 496 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\system_error"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
// xlocale internal header (from <locale>)
#pragma once






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"
// memory standard header
#pragma once







#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\typeinfo"
// typeinfo standard header

/***
 *typeinfo - Defines the type_info structure and exceptions used for RTTI
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Modified January 1996 by P.J. Plauger
 *
 *Purpose:
 *       Defines the type_info structure and exceptions used for
 *       Runtime Type Identification.
 *
 *       [Public]
 *
 ****/

#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




#pragma warning(disable : 4275) 

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"
//
// vcruntime_typeinfo.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <typeinfo> functionality that is implemented in the VCRuntime.
//
#pragma once





#pragma pack(push, 8)





#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

 int __cdecl __std_type_info_compare(
      const __std_type_info_data* _Lhs,
      const __std_type_info_data* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
      const __std_type_info_data* _Data
    );

 const char* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))


#pragma warning(push)
#pragma warning(disable: 4577) 
class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    const char* name() const noexcept
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"
    }

    const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:

    mutable __std_type_info_data _Data;
};
#pragma warning(pop)

namespace std {
	using ::type_info;
}



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:

    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};

#pragma warning(pop)
} // namespace std

#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\vcruntime_typeinfo.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\typeinfo"

namespace std {

// size in pointers of std::function and std::any (roughly 3 pointers larger than std::string when building debug)
constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);




































#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\typeinfo"

[[noreturn]] inline void _Throw_bad_cast() {
    throw bad_cast{};
}

}



#pragma pack(pop)
#pragma warning(pop)
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\typeinfo"
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\typeinfo"

/*
 * Copyright (c) Microsoft Corporation.  ALL RIGHTS RESERVED.
 * Modified January 1996 by P.J. Plauger
 * Modified November 1998 by P.J. Plauger
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// FUNCTION TEMPLATE uninitialized_copy_n
// TRANSITION: _Uninitialized_copy_n_unchecked and _Uninitialized_copy_n_unchecked1 are ABI zombie names

template <class _InIt, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    // copy [_First, _First + _Count) to [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
            _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
        } else {
            _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
            for (; 0 < _Count; --_Count, (void) ++_UFirst) {
                _Backout._Emplace_back(*_UFirst);
            }

            _UDest = _Backout._Release();
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}































#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"


template <class _InTy, size_t _InSize, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    // copy [_First, _First + _Count) to [_Dest, ...), array input
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 86, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 86, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_copy_n(static_cast<_InTy*>(_First), _Count, _Dest);
    }

    return _Dest;
}

template <class _InIt, class _Diff, class _OutTy, size_t _OutSize>
_OutTy* uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _OutTy (&_Dest)[_OutSize]) {
    // copy [_First, _First + _Count) to [_Dest, ...), array dest
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 98, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 98, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_copy_n(_Get_unwrapped_n(_First, _Count), _Count, static_cast<_OutTy*>(_Dest));
    }

    return _Dest;
}

template <class _InTy, size_t _InSize, class _Diff, class _OutTy, size_t _OutSize>
_OutTy* uninitialized_copy_n(_InTy (&_First)[_InSize], const _Diff _Count_raw, _OutTy (&_Dest)[_OutSize]) {
    // copy [_First, _First + _Count) to [_Dest, ...), array input/dest
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 110, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 110, 0); } while (false); } ; } while (false);
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 111, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 111, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_copy_n(static_cast<_InTy*>(_First), _Count, static_cast<_OutTy*>(_Dest));
    }

    return _Dest;
}
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

































































































































#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

// FUNCTION TEMPLATE uninitialized_fill_n
// TRANSITION: _Uninitialized_fill_n_unchecked is an ABI zombie name

template <class _NoThrowFwdIt, class _Diff, class _Tval>
_NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) {
    // copy _Count copies of _Val to raw _First
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        if constexpr (_Fill_memset_is_safe<_Unwrapped_n_t<_NoThrowFwdIt>, _Tval>) {
            :: memset(_UFirst, static_cast<unsigned char>(_Val), _Count);
            _UFirst += _Count;
        } else {
            _Uninitialized_backout<_Unwrapped_n_t<_NoThrowFwdIt>> _Backout{_UFirst};
            for (; 0 < _Count; --_Count) {
                _Backout._Emplace_back(_Val);
            }

            _UFirst = _Backout._Release();
        }

        _Seek_wrapped(_First, _UFirst);
    }

    return _First;
}

































#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"












































































































#line 418 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"


// CLASS TEMPLATE raw_storage_iterator
template <class _OutIt, class _Ty>
class  raw_storage_iterator { // wrap stores to raw buffer as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;

    explicit raw_storage_iterator(_OutIt _First) : _Next(_First) {} // construct with iterator

     raw_storage_iterator& operator*() { // pretend to return designated value
        return *this;
    }

    raw_storage_iterator& operator=(const _Ty& _Val) { // construct value designated by stored iterator
        _Construct_in_place(*_Next, _Val);
        return *this;
    }

    raw_storage_iterator& operator=(_Ty&& _Val) { // construct value designated by stored iterator
        _Construct_in_place(*_Next, ::std:: move(_Val));
        return *this;
    }

    raw_storage_iterator& operator++() {
        ++_Next;
        return *this;
    }

    raw_storage_iterator operator++(int) {
        raw_storage_iterator _Ans = *this;
        ++_Next;
        return _Ans;
    }

     _OutIt base() const { // return the stored iterator
        return _Next;
    }

private:
    _OutIt _Next; // the stored iterator
};



// CLASS TEMPLATE auto_ptr
template <class _Ty>
class auto_ptr;

template <class _Ty>
struct auto_ptr_ref { // proxy reference for auto_ptr copying
    explicit auto_ptr_ref(_Ty* _Right) : _Ref(_Right) {} // construct from generic pointer to auto_ptr ptr

    _Ty* _Ref; // generic pointer to auto_ptr ptr
};

template <class _Ty>
class auto_ptr { // wrap an object pointer to ensure destruction
public:
    using element_type = _Ty;

    explicit auto_ptr(_Ty* _Ptr = nullptr) noexcept : _Myptr(_Ptr) {} // construct from object pointer

    auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release()) {
        // construct by assuming pointer from _Right auto_ptr
    }

    auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept { // construct by assuming pointer from _Right auto_ptr_ref
        _Ty* _Ptr   = _Right._Ref;
        _Right._Ref = nullptr; // release old
        _Myptr      = _Ptr; // reset this
    }

    template <class _Other>
    operator auto_ptr<_Other>() noexcept { // convert to compatible auto_ptr
        return auto_ptr<_Other>(*this);
    }

    template <class _Other>
    operator auto_ptr_ref<_Other>() noexcept { // convert to compatible auto_ptr_ref
        _Other* _Cvtptr = _Myptr; // test implicit conversion
        auto_ptr_ref<_Other> _Ans(_Cvtptr);
        _Myptr = nullptr; // pass ownership to auto_ptr_ref
        return _Ans;
    }

    template <class _Other>
    auto_ptr& operator=(auto_ptr<_Other>& _Right) noexcept { // assign compatible _Right (assume pointer)
        reset(_Right.release());
        return *this;
    }

    template <class _Other>
    auto_ptr(auto_ptr<_Other>& _Right) noexcept : _Myptr(_Right.release()) {
        // construct by assuming pointer from _Right
    }

    auto_ptr& operator=(auto_ptr& _Right) noexcept { // assign compatible _Right (assume pointer)
        reset(_Right.release());
        return *this;
    }

    auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) noexcept { // assign compatible _Right._Ref (assume pointer)

        _Ty* _Ptr   = _Right._Ref;
        _Right._Ref = 0; // release old
        reset(_Ptr); // set new
        return *this;
    }

    ~auto_ptr() noexcept {
        delete _Myptr;
    }

     _Ty& operator*() const noexcept {

        do { if (_Myptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 538, 0, "%s", "auto_ptr not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"auto_ptr not dereferencable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 538, 0); } while (false); } ; } while (false);
#line 540 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

        return *get();
    }

     _Ty* operator->() const noexcept {

        do { if (_Myptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 546, 0, "%s", "auto_ptr not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"auto_ptr not dereferencable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory", 546, 0); } while (false); } ; } while (false);
#line 548 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

        return get();
    }

     _Ty* get() const noexcept { // return wrapped pointer
        return _Myptr;
    }

    _Ty* release() noexcept { // return wrapped pointer and give up ownership
        _Ty* _Tmp = _Myptr;
        _Myptr    = nullptr;
        return _Tmp;
    }

    void reset(_Ty* _Ptr = nullptr) { // destroy designated object and store new pointer
        if (_Ptr != _Myptr) {
            delete _Myptr;
        }

        _Myptr = _Ptr;
    }

private:
    _Ty* _Myptr; // the wrapped object pointer
};

template <>
class auto_ptr<void> {
public:
    using element_type = void;
};
#line 580 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"


// CLASS bad_weak_ptr
class bad_weak_ptr : public exception { // exception type for invalid use of expired weak_ptr object
public:
    bad_weak_ptr() noexcept {}

     virtual const char*  what() const noexcept override {
        // return pointer to message string
        return "bad_weak_ptr";
    }
};

[[noreturn]] inline void _Throw_bad_weak_ptr() {
    throw bad_weak_ptr{};
}

// CLASS _Ref_count_base
class __declspec(novtable) _Ref_count_base { // common code for reference counting
private:










    virtual void _Destroy() noexcept     = 0; // destroy managed resource
    virtual void _Delete_this() noexcept = 0; // destroy self
#line 613 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    _Atomic_counter_t _Uses  = 1;
    _Atomic_counter_t _Weaks = 1;

protected:
    constexpr _Ref_count_base() noexcept = default; // non-atomic initializations

public:
    _Ref_count_base(const _Ref_count_base&) = delete;
    _Ref_count_base& operator=(const _Ref_count_base&) = delete;

    virtual ~_Ref_count_base() noexcept {} // TRANSITION, should be non-virtual

    bool _Incref_nz() noexcept { // increment use count if not zero, return true if successful
        auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);
        long _Count          = (*_Atomic_address_as<const long>(_Volatile_uses));

        while (_Count != 0) {
            const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + 1, _Count);
            if (_Old_value == _Count) {
                return true;
            }

            _Count = _Old_value;
        }

        return false;
    }

    void _Incref() noexcept { // increment use count
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses));
    }

    void _Incwref() noexcept { // increment weak reference count
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks));
    }

    void _Decref() noexcept { // decrement use count
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0) {
            _Destroy();
            _Decwref();
        }
    }

    void _Decwref() noexcept { // decrement weak reference count
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0) {
            _Delete_this();
        }
    }

    long _Use_count() const noexcept { // return use count
        return static_cast<long>(_Uses);
    }

    virtual void* _Get_deleter(const type_info&) const noexcept { // return address of deleter object
        return nullptr;
    }
};

// CLASS TEMPLATE _Ref_count
template <class _Ty>
class _Ref_count : public _Ref_count_base { // handle reference counting for pointer without deleter
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    virtual void _Destroy() noexcept override { // destroy managed resource
        delete _Ptr;
    }

    virtual void _Delete_this() noexcept override { // destroy self
        delete this;
    }

    _Ty* _Ptr;
};

// CLASS TEMPLATE _Ref_count_resource
template <class _Resource, class _Dx>
class _Ref_count_resource : public _Ref_count_base { // handle reference counting for object with deleter
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _Px) {}

    virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override { // return address of deleter object

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

        return nullptr;
    }

private:
    virtual void _Destroy() noexcept override { // destroy managed resource
        _Mypair._Get_first()(_Mypair._Myval2);
    }

    virtual void _Delete_this() noexcept override { // destroy self
        delete this;
    }

    _Compressed_pair<_Dx, _Resource> _Mypair;
};

// CLASS TEMPLATE _Ref_count_resource_alloc
template <class _Resource, class _Dx, class _Alloc>
class _Ref_count_resource_alloc : public _Ref_count_base {
    // handle reference counting for object with deleter and allocator
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
          _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _One_then_variadic_args_t(), _Ax, _Px) {}

    virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override { // return address of deleter object

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

        return nullptr;
    }

private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

    virtual void _Destroy() noexcept override { // destroy managed resource
        _Mypair._Get_first()(_Mypair._Myval2._Myval2);
    }

    virtual void _Delete_this() noexcept override { // destroy self
        _Myalty _Al = _Mypair._Myval2._Get_first();
        this->~_Ref_count_resource_alloc();
        _Deallocate_plain(_Al, this);
    }

    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};

// DECLARATIONS
template <class _Ty>
struct default_delete;

template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;

template <class _Ty>
class shared_ptr;

template <class _Ty>
class weak_ptr;

template <class _Yty, class = void>
struct _Can_enable_shared : false_type {}; // detect unambiguous and accessible inheritance from enable_shared_from_this

template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type {
    // is_convertible is necessary to verify unambiguous inheritance
};














#line 794 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

// CLASS TEMPLATE _Ptr_base
struct _Exception_ptr_access;

template <class _Ty>
class _Ptr_base { // base class for shared_ptr and weak_ptr
public:
    using element_type = remove_extent_t<_Ty>;

     long use_count() const noexcept { // return use count
        return _Rep ? _Rep->_Use_count() : 0;
    }

    template <class _Ty2>
     bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { // compare addresses of manager objects
        return _Rep < _Right._Rep;
    }

    _Ptr_base(const _Ptr_base&) = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
     element_type* get() const noexcept { // return pointer to resource
        return _Ptr;
    }

    constexpr _Ptr_base() noexcept = default;

    ~_Ptr_base() = default;

    template <class _Ty2>
    void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
        // implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;

        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }

    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
        // implement shared_ptr's (converting) copy ctor
        if (_Other._Rep) {
            _Other._Rep->_Incref();
        }

        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
        // implement shared_ptr's aliasing ctor
        if (_Other._Rep) {
            _Other._Rep->_Incref();
        }

        _Ptr = _Px;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
        // implement shared_ptr's aliasing move ctor
        _Ptr = _Px;
        _Rep = _Other._Rep;

        _Other._Ptr = nullptr;
        _Other._Rep = nullptr;
    }

    template <class _Ty0>
    friend class weak_ptr; // specifically, weak_ptr::lock()

    template <class _Ty2>
    bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
        // implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }

        return false;
    }

    void _Decref() noexcept { // decrement reference count
        if (_Rep) {
            _Rep->_Decref();
        }
    }

    void _Swap(_Ptr_base& _Right) noexcept { // swap pointers
        ::std:: swap(_Ptr, _Right._Ptr);
        ::std:: swap(_Rep, _Right._Rep);
    }

    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { // implement weak_ptr's ctors
        if (_Other._Rep) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            _Rep->_Incwref();
        } else {
            ;
        }
    }

    void _Decwref() noexcept { // decrement weak reference count
        if (_Rep) {
            _Rep->_Decwref();
        }
    }

private:
    element_type* _Ptr{nullptr};
    _Ref_count_base* _Rep{nullptr};

    template <class _Ty0>
    friend class _Ptr_base;

    friend shared_ptr<_Ty>;

    friend _Exception_ptr_access;


    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#line 924 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"
};

// TYPE TRAIT _Can_scalar_delete
template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty*>())>> : true_type {};

// TYPE TRAIT _Can_array_delete
template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty*>())>> : true_type {};

// TYPE TRAIT _Can_call_function_object
template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>> : true_type {};

// TYPE TRAIT _SP_convertible
template <class _Yty, class _Ty>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {};

// TYPE TRAIT _SP_pointer_compatible
template <class _Yty, class _Ty>
struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type {
    // N4659 [util.smartptr.shared]/5 "a pointer type Y* is said to be compatible
    // with a pointer type T* " "when either Y* is convertible to T* ..."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type {
    // N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type {
    // N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type {
    // N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type {
    // N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
};

// CLASS TEMPLATE shared_ptr
template <class _Ux>
struct _Temporary_owner {
    _Ux* _Ptr;

    explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_) {}
    _Temporary_owner(const _Temporary_owner&) = delete;
    _Temporary_owner& operator=(const _Temporary_owner&) = delete;
    ~_Temporary_owner() {
        delete _Ptr;
    }
};

template <class _UxptrOrNullptr, class _Dx>
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx& _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_) {}
    _Temporary_owner_del(const _Temporary_owner_del&) = delete;
    _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
    ~_Temporary_owner_del() {
        if (_Call_deleter) {
            _Dt(_Ptr);
        }
    }
};

template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { // class for reference counted resource management
private:
    using _Mybase = _Ptr_base<_Ty>;

public:
    using typename _Mybase::element_type;



#line 1015 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    constexpr shared_ptr() noexcept {} // construct empty shared_ptr

    constexpr shared_ptr(nullptr_t) noexcept {} // construct empty shared_ptr

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    explicit shared_ptr(_Ux* _Px) { // construct shared_ptr object that owns _Px

        if constexpr (is_array_v<_Ty>) {
            _Setpd(_Px, default_delete<_Ux[]>{});
        } else {
            _Temporary_owner<_Ux> _Owner(_Px);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
            _Owner._Ptr = nullptr;
        }


#line 1036 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt) { // construct with _Px, deleter
        _Setpd(_Px, ::std:: move(_Dt));
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { // construct with _Px, deleter, allocator
        _Setpda(_Px, ::std:: move(_Dt), _Ax);
    }

    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { // construct with nullptr, deleter
        _Setpd(nullptr, ::std:: move(_Dt));
    }

    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { // construct with nullptr, deleter, allocator
        _Setpda(nullptr, ::std:: move(_Dt), _Ax);
    }

    template <class _Ty2>
    shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept {
        // construct shared_ptr object that aliases _Right
        this->_Alias_construct_from(_Right, _Px);
    }

    template <class _Ty2>
    shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept {
        // move construct shared_ptr object that aliases _Right
        this->_Alias_move_construct_from(::std:: move(_Right), _Px);
    }

    shared_ptr(const shared_ptr& _Other) noexcept { // construct shared_ptr object that owns same resource as _Other
        this->_Copy_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        // construct shared_ptr object that owns same resource as _Other
        this->_Copy_construct_from(_Other);
    }

    shared_ptr(shared_ptr&& _Right) noexcept { // construct shared_ptr object that takes resource from _Right
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { // construct shared_ptr object that takes resource from _Right
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { // construct shared_ptr object that owns resource *_Other
        if (!this->_Construct_from_weak(_Other)) {
            _Throw_bad_weak_ptr();
        }
    }


    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    shared_ptr(auto_ptr<_Ty2>&& _Other) { // construct shared_ptr object that owns *_Other.get()
        _Ty2* _Px = _Other.get();
        _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
        _Other.release();
    }
#line 1112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) { // construct from unique_ptr
        using _Fancy_t   = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t     = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;

        const _Fancy_t _Fancy = _Other.get();

        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx    = new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _Other.get_deleter());
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }

    ~shared_ptr() noexcept { // release resource
        this->_Decref();
    }

    shared_ptr& operator=(const shared_ptr& _Right) noexcept { // assign shared ownership of resource owned by _Right
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2>
    shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        // assign shared ownership of resource owned by _Right
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& _Right) noexcept { // take resource from _Right
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { // take resource from _Right
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }


    template <class _Ty2>
    shared_ptr& operator=(auto_ptr<_Ty2>&& _Right) { // assign ownership of resource pointed to by _Right
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
#line 1166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    template <class _Ux, class _Dx>
    shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { // move from unique_ptr
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    void swap(shared_ptr& _Other) noexcept { // swap pointers
        this->_Swap(_Other);
    }

    void reset() noexcept { // release resource and convert to empty shared_ptr object
        shared_ptr().swap(*this);
    }

    template <class _Ux>
    void reset(_Ux* _Px) { // release, take ownership of _Px
        shared_ptr(_Px).swap(*this);
    }

    template <class _Ux, class _Dx>
    void reset(_Ux* _Px, _Dx _Dt) { // release, take ownership of _Px, with deleter _Dt
        shared_ptr(_Px, _Dt).swap(*this);
    }

    template <class _Ux, class _Dx, class _Alloc>
    void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { // release, take ownership of _Px, with deleter _Dt, allocator _Ax
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }

    using _Mybase::get;

    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
     _Ty2& operator*() const noexcept { // return reference to resource
        return *get();
    }

    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
     _Ty2* operator->() const noexcept { // return pointer to resource
        return get();
    }

    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
     _Elem& operator[](ptrdiff_t _Idx) const noexcept { // strengthened
        return get()[_Idx];
    }

      bool unique() const noexcept {
        // return true if no other shared_ptr object owns this resource
        return this->use_count() == 1;
    }

    explicit operator bool() const noexcept { // test if shared_ptr object owns a resource
        return get() != nullptr;
    }

private:












#line 1236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt) { // take ownership of _Px, deleter _Dt
        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Set_ptr_rep_and_enable_shared(
            _Owner._Ptr, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, ::std:: move(_Dt)));
        _Owner._Call_deleter = false;
    }

    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { // take ownership of _Px, deleter _Dt, allocator _Ax
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Alref_alloc _Alref(_Ax);
        _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, ::std:: move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));
        _Constructor._Ptr    = nullptr;
        _Owner._Call_deleter = false;
    }

    template <class _Ty0, class... _Types>
    friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { // take ownership of _Px
        this->_Ptr = _Px;
        this->_Rep = _Rx;

        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }




#line 1280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"
    }

    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept { // take ownership of nullptr
        this->_Ptr = nullptr;
        this->_Rep = _Rx;
    }
};







#line 1295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

template <class _Ty1, class _Ty2>
 bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}

template <class _Ty1, class _Ty2>
 bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() != _Right.get();
}

template <class _Ty1, class _Ty2>
 bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() < _Right.get();
}

template <class _Ty1, class _Ty2>
 bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() >= _Right.get();
}

template <class _Ty1, class _Ty2>
 bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() > _Right.get();
}

template <class _Ty1, class _Ty2>
 bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <= _Right.get();
}

template <class _Ty>
 bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}

template <class _Ty>
 bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr == _Right.get();
}

template <class _Ty>
 bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() != nullptr;
}

template <class _Ty>
 bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr != _Right.get();
}

template <class _Ty>
 bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() < static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
 bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) < _Right.get();
}

template <class _Ty>
 bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
 bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) >= _Right.get();
}

template <class _Ty>
 bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() > static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
 bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) > _Right.get();
}

template <class _Ty>
 bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
 bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) <= _Right.get();
}

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) {
    // write contained pointer to stream
    return _Out << _Px.get();
}

template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept { // swap _Left and _Right shared_ptrs
    _Left.swap(_Right);
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // static_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // static_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // const_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // const_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // reinterpret_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // reinterpret_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}


template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // dynamic_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    return shared_ptr<_Ty1>();
}

template <class _Ty1, class _Ty2>
 shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // dynamic_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
    }

    return shared_ptr<_Ty1>();
}





#line 1469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"


template <class _Dx, class _Ty>
 _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept {
    // return pointer to shared_ptr's deleter object if its type is _Dx
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }

    return nullptr;
}



#line 1484 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

// _Ref_count_obj is an ABI zombie name

// CLASS TEMPLATE _Ref_count_obj2
template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { // handle reference counting for object in control block, no allocator
public:
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() { // construct from argument list
        _Construct_in_place(_Storage._Value, ::std:: forward<_Types>(_Args)...);
    }

    ~_Ref_count_obj2() {
        // nothing to do, _Storage._Value was already destroyed in _Destroy
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    virtual void _Destroy() noexcept override { // destroy managed resource
        _Destroy_in_place(_Storage._Value);
    }

    virtual void _Delete_this() noexcept override { // destroy self
        delete this;
    }
};

// CLASS TEMPLATE _Ebco_base
template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty { // Empty Base Class Optimization, active
private:
    using _Mybase = _Ty; // for visualization

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std:: forward<_Other>(_Val)) {}

    _Ty& _Get_val() noexcept {
        return *this;
    }

    const _Ty& _Get_val() const noexcept {
        return *this;
    }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { // Empty Base Class Optimization, inactive
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std:: forward<_Other>(_Val)) {}

    _Ty& _Get_val() noexcept {
        return _Myval;
    }

    const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

// _Ref_count_obj_alloc is an ABI zombie name

// CLASS TEMPLATE _Ref_count_obj_alloc2
template <class _Ty, class _Alloc>
class __declspec(empty_bases) _Ref_count_obj_alloc2 : public _Ebco_base<_Alloc>, public _Ref_count_base {
    // handle reference counting for object in control block, allocator
public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc2(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Alloc>(_Al_arg), _Ref_count_base() { // construct from argument list, allocator
        _Maybe_rebind_alloc_t<_Alloc, _Ty> _Alty(this->_Get_val());
        allocator_traits<_Rebind_alloc_t<_Alloc, _Ty>>::construct(
            _Alty, ::std:: addressof(_Storage._Value), ::std:: forward<_Types>(_Args)...);
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_obj_alloc2() {
        // nothing to do; _Storage._Value already destroyed by _Destroy()
    }

    virtual void _Destroy() noexcept override { // destroy managed resource
        _Maybe_rebind_alloc_t<_Alloc, _Ty> _Alty(this->_Get_val());
        allocator_traits<_Rebind_alloc_t<_Alloc, _Ty>>::destroy(_Alty, ::std:: addressof(_Storage._Value));
    }

    virtual void _Delete_this() noexcept override { // destroy self
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc2> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc2();
        _Deallocate_plain(_Al, this);
    }
};

// FUNCTION TEMPLATE make_shared
template <class _Ty, class... _Types>
 shared_ptr<_Ty> make_shared(_Types&&... _Args) { // make a shared_ptr
    const auto _Rx = new _Ref_count_obj2<_Ty>(::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
}

// FUNCTION TEMPLATE allocate_shared
template <class _Ty, class _Alloc, class... _Types>
 shared_ptr<_Ty> allocate_shared(const _Alloc& _Al, _Types&&... _Args) { // make a shared_ptr
    // Note: As of 2019-05-28, this implements the proposed resolution of LWG 3210 (which controls whether
    // allocator::construct sees T or const T when _Ty is const qualified)
    using _Refoa   = _Ref_count_obj_alloc2<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
    _Constructor._Allocate();
    _Construct_in_place(*_Constructor._Ptr, _Al, ::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}

// CLASS TEMPLATE weak_ptr
template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { // class for pointer to reference counted resource
public:
    constexpr weak_ptr() noexcept {} // construct empty weak_ptr object

    weak_ptr(const weak_ptr& _Other) noexcept { // construct weak_ptr object for resource pointed to by _Other
        this->_Weakly_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept { // construct weak_ptr object for resource owned by _Other
        this->_Weakly_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept { // construct weak_ptr object for resource pointed to by _Other
        this->_Weakly_construct_from(_Other.lock());
    }

    weak_ptr(weak_ptr&& _Other) noexcept { // move construct from _Other
        this->_Move_construct_from(::std:: move(_Other));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept { // move construct from _Other
        this->_Weakly_construct_from(_Other.lock());
        _Other.reset();
    }

    ~weak_ptr() noexcept { // release resource
        this->_Decwref();
    }

    weak_ptr& operator=(const weak_ptr& _Right) noexcept { // assign from _Right
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept { // assign from _Right
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    weak_ptr& operator=(weak_ptr&& _Right) noexcept { // move assign from _Right
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept { // move assign from _Right
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept { // assign from _Right
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    void reset() noexcept { // release resource, convert to null weak_ptr object
        weak_ptr().swap(*this);
    }

    void swap(weak_ptr& _Other) noexcept { // swap pointers
        this->_Swap(_Other);
    }

     bool expired() const noexcept { // return true if resource no longer exists
        return this->use_count() == 0;
    }

     shared_ptr<_Ty> lock() const noexcept { // convert to shared_ptr
        shared_ptr<_Ty> _Ret;
        (void) _Ret._Construct_from_weak(*this);
        return _Ret;
    }
};




#line 1701 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept { // swap contents of _Left and _Right
    _Left.swap(_Right);
}

// CLASS TEMPLATE enable_shared_from_this
template <class _Ty>
class enable_shared_from_this { // provide member functions that create shared_ptr to this
public:
    using _Esft_type = enable_shared_from_this;

     shared_ptr<_Ty> shared_from_this() { // return shared_ptr
        return shared_ptr<_Ty>(_Wptr);
    }

     shared_ptr<const _Ty> shared_from_this() const { // return shared_ptr
        return shared_ptr<const _Ty>(_Wptr);
    }

     weak_ptr<_Ty> weak_from_this() noexcept { // return weak_ptr
        return _Wptr;
    }

     weak_ptr<const _Ty> weak_from_this() const noexcept { // return weak_ptr
        return _Wptr;
    }

protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() {}

    enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr() {
        // construct (must value-initialize _Wptr)
    }

    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { // assign (must not change _Wptr)
        return *this;
    }

    ~enable_shared_from_this() = default;

private:

    template <class _Yty>
    friend class shared_ptr;



#line 1750 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    mutable weak_ptr<_Ty> _Wptr;
};


// CLASS TEMPLATE unique_ptr AND HELPERS

// STRUCT TEMPLATE default_delete
template <class _Ty>
struct default_delete { // default deleter for unique_ptr
    constexpr default_delete() noexcept = default;

    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    default_delete(const default_delete<_Ty2>&) noexcept {}

    void operator()(_Ty* _Ptr) const noexcept { // delete a pointer
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};

template <class _Ty>
struct default_delete<_Ty[]> { // default deleter for unique_ptr to array of unknown size
    constexpr default_delete() noexcept = default;

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    default_delete(const default_delete<_Uty[]>&) noexcept {}

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    void operator()(_Uty* _Ptr) const noexcept { // delete a pointer
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};

// STRUCT TEMPLATE _Get_deleter_pointer_type
template <class _Ty, class _Dx_noref, class = void>
struct _Get_deleter_pointer_type { // provide fallback
    using type = _Ty*;
};

template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { // get _Dx_noref::pointer
    using type = typename _Dx_noref::pointer;
};

template <class _Dx2>
using _Unique_ptr_enable_default_t =
    enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

// CLASS TEMPLATE unique_ptr SCALAR
template <class _Ty, class _Dx /* = default_delete<_Ty> */>
class unique_ptr { // non-copyable pointer to an object
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), _Dt, _Ptr) {}

    template <class _Dx2                                                                            = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _Ptr) {}

    template <class _Dx2                                                                                      = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Ty2, class _Dx2,
        enable_if_t<
            conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
            int> = 0>
    unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}


    template <class _Ty2,
        enable_if_t<conjunction_v<is_convertible<_Ty2*, _Ty*>, is_same<_Dx, default_delete<_Ty>>>, int> = 0>
    unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Right.release()) {}
#line 1849 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
                        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
            int> = 0>
    unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Dx2>(_Right._Mypair._Get_first());
        return *this;
    }

    unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: forward<_Dx>(_Right._Mypair._Get_first());
        }
        return *this;
    }

    void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

     _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

     const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

     add_lvalue_reference_t<_Ty> operator*() const noexcept { // strengthened
        return *_Mypair._Myval2;
    }

     pointer operator->() const noexcept {
        return _Mypair._Myval2;
    }

     pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, pointer());
    }

    void reset(pointer _Ptr = pointer()) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

// CLASS TEMPLATE unique_ptr ARRAY
template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> { // non-copyable pointer to an array object
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset = enable_if_t<is_same_v<_Uty, pointer> //
                                           || _Is_nullptr::value //
                                           || (is_same_v<pointer, element_type*> //
                                               && is_pointer_v<_Uty> //
                                               && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>)>;

    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, class = _Enable_ctor_reset<_Uty>>
    explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), _Dt, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: move(_Right._Mypair._Get_first());
        }

        return *this;
    }

    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>,
        is_same<_UP_pointer, _UP_element_type*>, is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>>;

    template <class _Uty, class _Ex,
        class = _Enable_conversion<_Uty, _Ex,
            conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>>>
    unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Ex>(_Right.get_deleter()), _Right.release()) {}

    template <class _Uty, class _Ex, class = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>>>
    unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Ex>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t()) {}

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    void reset(nullptr_t = nullptr) noexcept {
        reset(pointer());
    }

    void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

     _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

     const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

     _Ty& operator[](size_t _Idx) const noexcept { // strengthened
        return _Mypair._Myval2[_Idx];
    }

     pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, pointer());
    }

    template <class _Uty, class = _Enable_ctor_reset<_Uty, false_type>>
    void reset(_Uty _Ptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};


// FUNCTION TEMPLATE make_unique
template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr
    return unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...));
}

template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
 unique_ptr<_Ty> make_unique(size_t _Size) { // make a unique_ptr
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}

template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
 bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // test if unique_ptr _Left equals _Right
    return _Left.get() == _Right.get();
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
 bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // test if unique_ptr _Left doesn't equal _Right
    return !(_Left == _Right);
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
 bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // test if unique_ptr _Left precedes _Right
    using _Ptr1   = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2   = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>()(_Left.get(), _Right.get());
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
 bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // test if unique_ptr _Left doesn't precede _Right
    return !(_Left < _Right);
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
 bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // test if unique_ptr _Right precedes _Left
    return _Right < _Left;
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
 bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // test if unique_ptr _Right doesn't precede _Left
    return !(_Right < _Left);
}

template <class _Ty, class _Dx>
 bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept { // test if unique_ptr == nullptr
    return !_Left;
}

template <class _Ty, class _Dx>
 bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept { // test if nullptr == unique_ptr
    return !_Right;
}

template <class _Ty, class _Dx>
 bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) noexcept {
    // test if unique_ptr != nullptr
    return !(_Left == _Right);
}

template <class _Ty, class _Dx>
 bool operator!=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    // test if nullptr != unique_ptr
    return !(_Left == _Right);
}

template <class _Ty, class _Dx>
 bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { // test if unique_ptr < nullptr
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>()(_Left.get(), _Right);
}

template <class _Ty, class _Dx>
 bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { // test if nullptr < unique_ptr
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>()(_Left, _Right.get());
}

template <class _Ty, class _Dx>
 bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { // test if unique_ptr >= nullptr
    return !(_Left < _Right);
}

template <class _Ty, class _Dx>
 bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { // test if nullptr >= unique_ptr
    return !(_Left < _Right);
}

template <class _Ty, class _Dx>
 bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { // test if unique_ptr > nullptr
    return _Right < _Left;
}

template <class _Ty, class _Dx>
 bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { // test if nullptr > unique_ptr
    return _Right < _Left;
}

template <class _Ty, class _Dx>
 bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { // test if unique_ptr <= nullptr
    return !(_Right < _Left);
}

template <class _Ty, class _Dx>
 bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { // test if nullptr <= unique_ptr
    return !(_Right < _Left);
}

template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
    : true_type {};

template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) {
    // write contained pointer to stream
    _Out << _Px.get();
    return _Out;
}

























#line 2211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

// GARBAGE COLLECTION
enum class pointer_safety { // return codes for get_pointer_safety
    relaxed,
    preferred,
    strict
};

inline void declare_reachable(void*) {} // increment pointer reachable count

template <class _Ty>
_Ty* undeclare_reachable(_Ty* _Ptr) { // decrement pointer reachable count
    return _Ptr;
}

inline void declare_no_pointers(char*, size_t) {} // declare region to be pointer free

inline void undeclare_no_pointers(char*, size_t) {} // undeclare region to be pointer free

inline pointer_safety get_pointer_safety() noexcept { // get pointer safety status
    return pointer_safety::relaxed;
}

// STRUCT TEMPLATE owner_less
template <class _Ty = void>
struct owner_less; // not defined

template <class _Ty>
struct owner_less<shared_ptr<_Ty>> { // functor for owner_before
     typedef shared_ptr<_Ty> first_argument_type;
     typedef shared_ptr<_Ty> second_argument_type;
     typedef bool result_type;

     bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

     bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

     bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }
};

template <class _Ty>
struct owner_less<weak_ptr<_Ty>> { // functor for owner_before
     typedef weak_ptr<_Ty> first_argument_type;
     typedef weak_ptr<_Ty> second_argument_type;
     typedef bool result_type;

     bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

     bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

     bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }
};

template <>
struct owner_less<void> { // functor for owner_before
    using is_transparent = int;

    template <class _Ty, class _Uty>
     bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
     bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
     bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
     bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        // apply owner_before to operands
        return _Left.owner_before(_Right);
    }
};

// STRUCT TEMPLATE SPECIALIZATION hash
template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>>
    : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
          is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> { // hash functor
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval)
        noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) { // strengthened
        // hash _Keyval to size_t value by pseudorandomizing transform
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};

template <class _Ty>
struct hash<shared_ptr<_Ty>> { // hash functor
     typedef shared_ptr<_Ty> argument_type;
     typedef size_t result_type;

     size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept {
        // hash _Keyval to size_t value by pseudorandomizing transform
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};

// FUNCTION align
inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept {
    // try to carve out _Size bytes on boundary _Bound
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; // number of bytes to skip
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    // enough room, update
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}









#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

// SPIN LOCKS
extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}

// WRAP SPIN-LOCK
struct _Shared_ptr_spin_lock { // class to manage a spin lock for shared_ptr atomic operations
    _Shared_ptr_spin_lock() { // lock the spin lock
        _Lock_shared_ptr_spin_lock();
    }

    ~_Shared_ptr_spin_lock() noexcept { // unlock the spin lock
        _Unlock_shared_ptr_spin_lock();
    }
};

template <class _Ty>
 bool atomic_is_lock_free(const shared_ptr<_Ty>*) {
    // return true if atomic operations on shared_ptr<_Ty> are lock-free
    return false;
}

template <class _Ty>
 shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty>* _Ptr, memory_order) {
    // load *_Ptr atomically
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}

template <class _Ty>
 shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty>* _Ptr) { // load *_Ptr atomically
    return ::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst);
}

template <class _Ty>
void atomic_store_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    // store _Other to *_Ptr atomically
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}

template <class _Ty>
void atomic_store(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { // store _Other to *_Ptr atomically
    ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

template <class _Ty>
shared_ptr<_Ty> atomic_exchange_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    // copy _Other to *_Ptr and return previous value of *_Ptr atomically
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}

template <class _Ty>
shared_ptr<_Ty> atomic_exchange(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) {
    // copy _Other to *_Ptr and return previous value of *_Ptr atomically
    return ::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

template <class _Ty>
bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value,
    memory_order, memory_order) { // atomically compare and exchange
    shared_ptr<_Ty> _Old_exp; // destroyed outside spin lock
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    } else { // match failed
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}

template <class _Ty>
bool atomic_compare_exchange_weak(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    // atomically compare and exchange
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

template <class _Ty>
bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value,
    memory_order, memory_order) { // atomically compare and exchange
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

template <class _Ty>
bool atomic_compare_exchange_strong(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    // atomically compare and exchange
    return ::std:: atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: allocate_shared;
    using ::std:: bad_weak_ptr;
    using ::std:: const_pointer_cast;
    using ::std:: dynamic_pointer_cast;
    using ::std:: enable_shared_from_this;
    using ::std:: get_deleter;
    using ::std:: make_shared;
    using ::std:: shared_ptr;
    using ::std:: static_pointer_cast;
    using ::std:: swap;
    using ::std:: weak_ptr;
} // namespace tr1
#line 2475 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

}


#pragma warning(pop)
#pragma pack(pop)
#line 2482 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"
#line 2483 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\memory"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xfacet"
// xfacet internal header
#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




// This must be as small as possible, because its contents are
// injected into the msvcprt.lib and msvcprtd.lib import libraries.
// Do not include or define anything else here.
// In particular, basic_string must not be included here.

namespace std {
// CLASS _Facet_base
class __declspec(dllimport) _Facet_base { // code for reference counting a facet
public:
    virtual  ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly
    }

    // increment use count
    virtual void  _Incref() noexcept = 0;

    // decrement use count
    virtual _Facet_base*  _Decref() noexcept = 0;
};




#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base*);
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xfacet"
}


#pragma warning(pop)
#pragma pack(pop)
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xfacet"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xfacet"

/*
* Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"
// xlocinfo internal header for Microsoft
#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"
// xlocinfo.h internal header for Microsoft
#pragma once





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
//
// ctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the narrow character (char) classification functionality.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Function Declarations
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isdigit(  int _C);

  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isspace(  int _C);

  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl toupper(  int _C);


   __declspec(dllimport) int __cdecl tolower(  int _C);

   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Macro Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
__inline int __cdecl __acrt_locale_get_ctype_array_value(
      unsigned short const * const _Locale_pctype_array,
              int                    const _Char_value,
                             int                    const _Mask
    )
{
    // The C Standard specifies valid input to a ctype function ranges from -1 to 255.
    // To avoid undefined behavior, we should check this range for all accesses.
    // Note _locale_pctype array does extend to -127 to support accessing
    // _pctype directly with signed chars.
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    // Maximum number of bytes in multi-byte character in the current locale
    // (also defined in stdlib.h).
    




















    // In the debug CRT, we make all calls through the validation function to catch
    // invalid integer inputs that yield undefined behavior.
    
        __declspec(dllimport) int __cdecl _chvalidator(  int _Ch,   int _Mask);
        
    


#line 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"



    
    
    
    
    
    
    
    



    












#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    
    __declspec(dllimport) int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);
    #line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"

    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        
        return _chvalidator_l(_Locale, _C, _Mask);
        






#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    // Microsoft C version 2.0 extended ctype macros
    
    
    
    

    
    
    
    

#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"



    
    
    
    
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"



#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
//
// locale.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C locale library.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {



// Locale categories










// Locale convention structure
struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;

// ANSI: char lconv members default is CHAR_MAX which is compile time dependent.
// Defining and using __do_unsigned_char_lconv_initialization here causes CRT
// startup code to initialize lconv members properly



















    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    
    __declspec(dllimport) int __cdecl _configthreadlocale(
          int _Flag
        );

        
    __declspec(dllimport) char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );

    
    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    
    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    
    __declspec(dllimport) _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );

    __declspec(dllimport) void __cdecl _free_locale(
          _locale_t _Locale
        );

    // Also declared in <wchar.h>
        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);




    // Time-related functions
     
     
    __declspec(dllimport) char*    __cdecl _Getdays(void);

     
     
    __declspec(dllimport) char*    __cdecl _Getmonths(void);

    __declspec(dllimport) void*    __cdecl _Gettnames(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void*    __cdecl _W_Gettnames(void);

     
    __declspec(dllimport) size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);

     
    __declspec(dllimport) size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );

#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"


} __pragma(pack(pop))
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )






extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"

// CTYPE CODE BITS












// SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS



















typedef struct _Collvec { // stuff needed by _Strcoll, etc.
    unsigned int _Page; // UINT
    wchar_t* _LocaleName;
} _Collvec;

typedef struct _Ctypevec { // stuff needed by _Tolower, etc.
    unsigned int _Page; // UINT
    const short* _Table;
    int _Delfl;
    wchar_t* _LocaleName;
} _Ctypevec;

typedef struct _Cvtvec { // stuff needed by _Mbrtowc, etc.
    unsigned int _Page; // UINT
    unsigned int _Mbcurmax;
    int _Isclocale; // LCID == _CLOCALEHANDLE
    unsigned char _Isleadbyte[32]; // 256 bits
} _Cvtvec;

// FUNCTION DECLARATIONS
 _Collvec __cdecl _Getcoll(void);
 _Ctypevec __cdecl _Getctype(void);
 _Cvtvec __cdecl _Getcvt(void);



extern "C"
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"
     int __cdecl
    _Getdateorder(void);
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"







 int __cdecl _Mbrtowc(  wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*);
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"

 float __cdecl _Stof(const char*,     char**, long);
 double __cdecl _Stod(const char*,     char**, long);
 long double __cdecl _Stold(const char*,     char**, long);

 int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
 size_t __cdecl _Strxfrm( 
                                                            char* _String1,
      char* _End1, const char*, const char*, const _Collvec*);
 int __cdecl _Tolower(int, const _Ctypevec*);
 int __cdecl _Toupper(int, const _Ctypevec*);
 int __cdecl _Wcrtomb(  char*, wchar_t, mbstate_t*, const _Cvtvec*);
 int __cdecl _Wcscoll(
    const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
 size_t __cdecl _Wcsxfrm(   
                                                          wchar_t* _String1,
      wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec*);
 const wchar_t* __cdecl _Getwctypes(
    const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*);



}
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"

extern "C" {
    __declspec(dllimport) char* __cdecl _Getdays(void);

    __declspec(dllimport) char* __cdecl _Getmonths(void);

__declspec(dllimport) void* __cdecl _Gettnames(void);

  __declspec(dllimport) size_t __cdecl _Strftime(
      char*,   size_t _Maxsize,   const char*,   const struct tm*,   void*);

    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

__declspec(dllimport) void* __cdecl _W_Gettnames(void);

  __declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t*,   size_t _Maxsize,
      const wchar_t*,   const struct tm*,   void*);
}







 _locale_t __cdecl _GetLocaleForCP(unsigned int);
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"



#pragma warning(pop)
#pragma pack(pop)
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"
#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo.h"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// CLASS _Timevec
class __declspec(dllimport) _Timevec { // smart pointer to information used by _Strftime
public:
    explicit  _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr) { // construct from ptr
    }

     _Timevec(const _Timevec& _Right) : _Timeptr(nullptr) { // construct from _Right
        *this = _Right;
    }

     ~_Timevec() noexcept {
        :: free(_Timeptr);
    }

    _Timevec&  operator=(const _Timevec& _Right) { // transfer ownership of _Timeptr from _Right
        if (this != &_Right) {
            :: free(_Timeptr);
            _Timeptr                               = _Right._Timeptr;
            const_cast<_Timevec&>(_Right)._Timeptr = nullptr; // TRANSITION, should be movable-only
        }

        return *this;
    }

    void*  _Getptr() const { // return pointer to time information
        return _Timeptr;
    }

private:
    void* _Timeptr; // pointer to time information
};

// CLASS _Locinfo
class __declspec(dllimport) _Locinfo { // summary of all stuff specific to a locale used by standard facets
public:
    using _Collvec  = ::_Collvec;
    using _Ctypevec = ::_Ctypevec;
    using _Cvtvec   = ::_Cvtvec;
    using _Timevec  = ::std:: _Timevec;

    static  void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
    static  void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
    static  void __cdecl _Locinfo_dtor(_Locinfo*);
    static  _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);

     _Locinfo(const char* _Pch = "C")

        : _Lock(0)
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"

    { // construct from NTBS
        if (_Pch) {
            _Locinfo_ctor(this, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     _Locinfo(int _Cat, const char* _Pch)

        : _Lock(0)
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"

    { // construct from category mask and NTBS
        if (_Pch) {
            _Locinfo_ctor(this, _Cat, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     ~_Locinfo() noexcept {
        _Locinfo_dtor(this);
    }

    _Locinfo&  _Addcats(int _Cat, const char* _Pch) { // add facets matching category mask and NTBS
        if (_Pch) {
            return _Locinfo_Addcats(this, _Cat, _Pch);
        }

        _Xruntime_error("bad locale name");
    }

    const char*  _Getname() const { // return the new locale name
        return _Newlocname._C_str();
    }

    _Collvec  _Getcoll() const { // return collation stuff
        return ::_Getcoll();
    }

    _Ctypevec  _Getctype() const { // return ctype stuff
        return ::_Getctype();
    }

    _Cvtvec  _Getcvt() const { // return codecvt stuff
        return ::_Getcvt();
    }

    const lconv*  _Getlconv() const { // return localeconv stuff
        return localeconv();
    }

    _Timevec  _Gettnames() const { // return names used by _Strftime
        return _Timevec(::_Gettnames());
    }

    const char*  _Getdays() const { // return names for weekdays
        const char* _Ptr = ::_Getdays();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_Days = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Days._Empty() ? _Days._C_str()
                               : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                 ":Thu:Thursday:Fri:Friday:Sat:Saturday";
    }

    const char*  _Getmonths() const { // return names for months
        const char* _Ptr = ::_Getmonths();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_Months = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Months._Empty() ? _Months._C_str()
                                 : ":Jan:January:Feb:February:Mar:March"
                                   ":Apr:April:May:May:Jun:June"
                                   ":Jul:July:Aug:August:Sep:September"
                                   ":Oct:October:Nov:November:Dec:December";
    }

    const char*  _Getfalse() const { // return false name (no C source)
        return "false";
    }

    const char*  _Gettrue() const { // return true name (no C source)
        return "true";
    }

    int  _Getdateorder() const { // return date order
        return ::_Getdateorder();
    }

    _Timevec  _W_Gettnames() const { // return names used by _Wcsftime
        return _Timevec(::_W_Gettnames());
    }

    const unsigned short*  _W_Getdays() const { // return names for weekdays
        const wchar_t* _Ptr = ::_W_Getdays();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_W_Days = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Days._Empty()) {
            _Ret = L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
        } else {
            _Ret = _W_Days._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    const unsigned short*  _W_Getmonths() const { // return names for months
        const wchar_t* _Ptr = ::_W_Getmonths();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_W_Months = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Months._Empty()) {
            _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
                   L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
        } else {
            _Ret = _W_Months._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    _Locinfo(const _Locinfo&) = delete;
    _Locinfo& operator=(const _Locinfo&) = delete;

private:




    _Lockit _Lock; // thread lock, because global locale is altered
#line 218 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"

    _Yarn<char> _Days; // weekday names
    _Yarn<char> _Months; // month names
    _Yarn<wchar_t> _W_Days; // wide weekday names
    _Yarn<wchar_t> _W_Months; // wide month names
    _Yarn<char> _Oldlocname; // old locale name to revert to on destruction
    _Yarn<char> _Newlocname; // new locale name for this object
};

// FUNCTION TEMPLATE _LStrcoll
template <class _Elem>
int __cdecl _LStrcoll(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { // perform locale-specific comparison of _Elem sequences
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2) {
        if (*_First1 < *_First2) {
            return -1; // [_First1, _Last1) < [_First2, _Last2)
        } else if (*_First2 < *_First1) {
            return +1; // [_First1, _Last1) > [_First2, _Last2)
        }
    }

    return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
}

template <>
inline int __cdecl _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { // perform locale-specific comparison of char sequences
    return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline int __cdecl _LStrcoll(const wchar_t* _First1, const wchar_t* _Last1, const wchar_t* _First2,
    const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { // perform locale-specific comparison of wchar_t sequences
    return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
}

// FUNCTION TEMPLATE _LStrxfrm
template <class _Elem>
size_t __cdecl _LStrxfrm(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { // perform locale-specific transform of _Elems [_First1, _Last1)
    const ptrdiff_t _Count = _Last2 - _First2;
    if (_Count <= _Last1 - _First1) {
        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
    }

    return _Count;
}

template <>
inline size_t __cdecl _LStrxfrm(    char* _First1,
      char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { // perform locale-specific transform of chars [_First1, _Last1)
    return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline size_t __cdecl _LStrxfrm(    wchar_t* _First1,
      wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { // perform locale-specific transform of wchar_ts [_First1, _Last1)
    return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocinfo"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// CLASS TEMPLATE _Locbase
template <class _Dummy>
class _Locbase { // define templatized category constants, instantiate on demand
public:
     static const int collate  = ((1 << (1)) >> 1);
     static const int ctype    = ((1 << (2)) >> 1);
     static const int monetary = ((1 << (3)) >> 1);
     static const int numeric  = ((1 << (4)) >> 1);
     static const int time     = ((1 << (5)) >> 1);
     static const int messages = ((1 << (6)) >> 1);
     static const int all      = (((1 << ((6 + 1))) >> 1) - 1);
     static const int none     = 0;
};

template <class _Dummy>
const int _Locbase<_Dummy>::collate;
template <class _Dummy>
const int _Locbase<_Dummy>::ctype;
template <class _Dummy>
const int _Locbase<_Dummy>::monetary;
template <class _Dummy>
const int _Locbase<_Dummy>::numeric;
template <class _Dummy>
const int _Locbase<_Dummy>::time;
template <class _Dummy>
const int _Locbase<_Dummy>::messages;
template <class _Dummy>
const int _Locbase<_Dummy>::all;
template <class _Dummy>
const int _Locbase<_Dummy>::none;

// CLASS locale
template <class _Elem>
class collate;

struct __declspec(dllimport) _Crt_new_delete { // base class for marking allocations as CRT blocks

    void* __cdecl operator new(size_t _Size) { // replace operator new
        void* _Ptr = operator new(_Size, nothrow);
        if (!_Ptr) {
            _Xbad_alloc();
        }

        return _Ptr;
    }

    void* __cdecl operator new(size_t _Size, const nothrow_t&) noexcept { // replace nothrow operator new
        return _malloc_dbg(_Size > 0 ? _Size : 1, 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale", 69);
    }

    void __cdecl operator delete(void* _Ptr) noexcept { // replace operator delete
        :: free(_Ptr);
    }

    void __cdecl operator delete(void* _Ptr, const nothrow_t&) noexcept { // replace nothrow operator delete
        operator delete(_Ptr);
    }

    void* __cdecl operator new(size_t, void* _Ptr) noexcept { // imitate True Placement New
        return _Ptr;
    }

    void __cdecl operator delete(void*, void*) noexcept { // imitate True Placement Delete
    }
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
};

class locale : public _Locbase<int>, public _Crt_new_delete { // nonmutable collection of facets that describe a locale
public:
    using category = int;

    // CLASS id
    class __declspec(dllimport) id { // identifier stamp, unique for each distinct kind of facet
    public:
         id(size_t _Val = 0) : _Id(_Val) { // construct with specified stamp value
        }

        id(const id&) = delete;
        id& operator=(const id&) = delete;

         operator size_t() { // get stamp, with lazy allocation
            if (_Id == 0) { // still zero, allocate stamp
                { ::std:: _Lockit _Lock(0);
                if (_Id == 0) {
                    _Id = static_cast<size_t>(++_Id_cnt);
                }
                }
            }
            return _Id;
        }

    private:
        size_t _Id; // the identifier stamp

         static int _Id_cnt;
    };

    class _Locimp;

    // CLASS facet
    class __declspec(dllimport) facet : public _Facet_base, public _Crt_new_delete {
        // base class for all locale facets, performs reference counting
    private:
        friend struct _Facet_guard;

    public:
        static size_t __cdecl _Getcat(const facet** = nullptr, const locale* = nullptr) {
            // get category value, or -1 if no corresponding C category
            return static_cast<size_t>(-1);
        }

        virtual void  _Incref() noexcept override { // increment use count
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Myrefs));
        }

        virtual _Facet_base*  _Decref() noexcept override { // decrement use count
            if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Myrefs)) == 0) {
                return this;
            }

            return nullptr;
        }

    private:
        _Atomic_counter_t _Myrefs; // the reference count

    protected:
        explicit  facet(size_t _Initrefs = 0)
            : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization
        {} // construct with initial reference count

        virtual  ~facet() noexcept override { // ensure that derived classes can be destroyed properly
        }

    public:
         facet(const facet&) = delete;
        facet&  operator=(const facet&) = delete;
    };

    struct _Facet_guard {
        facet* _Target;
        ~_Facet_guard() {
            if (_Target) {
                delete _Target->_Decref();
            }
        }
    };

    // CLASS _Locimp
    class __declspec(dllimport) _Locimp : public facet { // reference-counted actual implementation of a locale
    protected:
         ~_Locimp() noexcept {
            _Locimp_dtor(this);
        }

    private:
        static  _Locimp* __cdecl _New_Locimp(bool _Transparent = false);
        static  _Locimp* __cdecl _New_Locimp(const _Locimp& _Right);

        static  void __cdecl _Locimp_dtor(_Locimp*);
        static  void __cdecl _Locimp_Addfac(_Locimp*, facet*, size_t); // add a facet
        static void __cdecl _Locimp_ctor(_Locimp*, const _Locimp&);

        friend locale;

         _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent),
              _Name("*") { // construct an empty _Locimp
        }

         _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
              _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) { // construct by copying
            _Locimp_ctor(this, _Right);
        }

        void  _Addfac(facet* _Pfacet, size_t _Id) { // add a facet
            _Locimp_Addfac(this, _Pfacet, _Id);
        }

        static _Locimp* __cdecl _Makeloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make essential facets

        static void __cdecl _Makewloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make wchar_t facets


        static void __cdecl _Makeushloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make ushort facets
#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

        static void __cdecl _Makexloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make remaining facets

        facet** _Facetvec; // pointer to vector of facets
        size_t _Facetcount; // size of vector of facets
        category _Catmask; // mask describing implemented categories
        bool _Xparent; // true if locale is transparent
        _Yarn<char> _Name; // locale name, or "*" if not known

         static _Locimp* _Clocptr;

    public:
        _Locimp&  operator=(const _Locimp&) = delete;
    };

    template <class _Elem, class _Traits, class _Alloc>
    bool operator()(
        const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
        // compare _Left and _Right strings using collate facet in locale
        const auto& _Coll_fac = ::std:: use_facet<::std:: collate<_Elem>>(*this);

        const _Elem* const _Left_data  = _Left.data();
        const _Elem* const _Right_data = _Right.data();
        return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
    }

    template <class _Facet>
    locale combine(const locale& _Loc) const { // combine two locales
        _Facet* _Facptr;

        try {
        _Facptr = const_cast<_Facet*>(::std:: addressof(::std:: use_facet<_Facet>(_Loc)));
        } catch (...) {
        _Xruntime_error("locale::combine facet missing");
        }

        _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
        _Newimp->_Addfac(_Facptr, _Facet::id);
        _Newimp->_Catmask = none;
        _Newimp->_Name    = "*";
        return locale(_Newimp);
    }

    template <class _Facet>
    locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct from _Loc, replacing facet with *_Facptr
        if (_Facptr) { // replace facet
            _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
            _Ptr->_Catmask = none;
            _Ptr->_Name    = "*";
        }
    }

    locale(_Uninitialized) {} // defer construction

    locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying
        _Ptr->_Incref();
    }

    locale() noexcept : _Ptr(_Init(true)) {} // construct from current locale


    locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct a locale by copying named facets
        if (_Cat != none) { // worth adding, do it
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj;
            _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
            _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
            _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
            _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
            _Ptr->_Name    = _Lobj._Getname();
            }
            _Guard._Target = nullptr;
        }
    }

private:
    void _Construct(const string& _Str, category _Cat) {
        // construct a locale with named facets
        bool _Bad = false;
        _Init();
        if (_Cat != none) { // worth adding, do it
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj(_Cat, _Str.c_str());
            if (_Badname(_Lobj)) {
                _Bad = true;
            } else { // name okay, build the locale
                _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                _Ptr->_Catmask = _Cat;
                _Ptr->_Name    = _Str.c_str();
            }
            }
            _Guard._Target = nullptr;
        }

        if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it
            delete _Ptr->_Decref();
            _Xruntime_error("bad locale name");
        }
    }

public:
    explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        // construct a locale with named facets
        // _Locname might have been returned from setlocale().
        // Therefore, _Construct() takes const string&.
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct a locale by copying, replacing named facets
        // _Locname might have been returned from setlocale().
        // Therefore, _Construct() takes const string&.
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        // construct a locale with named facets
        _Construct(_Str, _Cat);
    }

    locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct a locale by copying, replacing named facets
        _Construct(_Str, _Cat);
    }
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

    ~locale() noexcept {
        if (_Ptr) {
            delete _Ptr->_Decref();
        }
    }

    locale& operator=(const locale& _Right) noexcept { // assign a locale
        if (_Ptr != _Right._Ptr) { // different implementation, point at new one
            delete _Ptr->_Decref();
            _Ptr = _Right._Ptr;
            _Ptr->_Incref();
        }
        return *this;
    }

    string name() const { // return locale name
        return _Ptr ? _Ptr->_Name.c_str() : string();
    }

      const char* c_str() const { // return locale name as NTBS
        return _Ptr ? _Ptr->_Name.c_str() : "";
    }

    const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
        const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end
        if (_Facptr || !_Ptr->_Xparent) {
            return _Facptr; // found facet or not transparent
        }

        // look in current locale
        locale::_Locimp* _Ptr0 = _Getgloballocale();
        if (_Id < _Ptr0->_Facetcount) {
            return _Ptr0->_Facetvec[_Id]; // get from current locale
        }

        return nullptr; // no entry in current locale
    }

     bool operator==(const locale& _Loc) const { // compare locales for equality
        return _Ptr == _Loc._Ptr || (name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
    }

     bool operator!=(const locale& _Right) const { // test for locale inequality
        return !(*this == _Right);
    }

    static  const locale& __cdecl classic(); // classic "C" locale

    static  locale __cdecl global(const locale&); // current locale

    static  locale __cdecl empty(); // empty (transparent) locale

private:
    locale(_Locimp* _Ptrimp) : _Ptr(_Ptrimp) {} // construct from _Locimp pointer

    static  _Locimp* __cdecl _Init(bool _Do_incref = false); // initialize locale
    static  _Locimp* __cdecl _Getgloballocale();
    static  void __cdecl _Setgloballocale(void*);

    bool _Badname(const _Locinfo& _Lobj) { // test if name is "*"
        return :: strcmp(_Lobj._Getname(), "*") == 0;
    }

    _Locimp* _Ptr; // pointer to locale implementation object
};

// SUPPORT TEMPLATES
template <class _Facet>
struct _Facetptr { // store pointer to lazy facet for use_facet
     static const locale::facet* _Psave;
};

template <class _Facet>
 const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;

template <class _Facet>
const _Facet& __cdecl use_facet(const locale& _Loc) { // get facet reference from locale
    { ::std:: _Lockit _Lock(0); // the thread lock, make get atomic
    const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

    const size_t _Id         = _Facet::id;
    const locale::facet* _Pf = _Loc._Getfacet(_Id);

    if (!_Pf) {
        if (_Psave) {
            _Pf = _Psave; // lazy facet already allocated
        } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

            _Throw_bad_cast(); // lazy disallowed


#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
        } else { // queue up lazy facet for destruction
            auto _Pfmod = const_cast<locale::facet*>(_Psave);
            unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));



#line 450 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
            _Facet_Register(_Pfmod);
#line 452 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

            _Pfmod->_Incref();
            _Facetptr<_Facet>::_Psave = _Psave;
            _Pf                       = _Psave;

            (void) _Psave_guard.release();
        }
    }

    return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast
    }
} // end of use_facet body

// FUNCTION TEMPLATE _Getloctxt
template <class _Elem, class _InIt>
int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr) {
    // find field at _Ptr that matches longest in [_First, _Last)
    for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {
        if (_Ptr[_Off] == _Ptr[0]) {
            ++_Numfields; // add fields with leading mark to initial count
        }
    }

    string _Str(_Numfields, '\0'); // one column counter for each field

    int _Ans = -2; // no candidates so far
    for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { // test each element against all viable fields
        bool _Prefix  = false; // seen at least one valid prefix
        size_t _Off   = 0; // offset into fields
        size_t _Field = 0; // current field number

        for (; _Field < _Numfields; ++_Field) { // test element at _Column in field _Field
            while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { // find beginning of field
                ++_Off;
            }

            if (_Str[_Field] != '\0') {
                _Off += _Str[_Field]; // skip tested columns in field
            } else if (_Ptr[_Off += _Column] == _Ptr[0]
                       || _Ptr[_Off] == _Elem{}) { // matched all of field, save as possible answer
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); // save skip count if small enough
                _Ans         = static_cast<int>(_Field); // save answer
            } else if (_First == _Last || _Ptr[_Off] != *_First) {
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); // no match, just save skip count
            } else {
                _Prefix = true; // still a valid prefix
            }
        }

        if (!_Prefix || _First == _Last) {
            break; // no pending prefixes or no input, give up
        }
    }
    return _Ans; // return field number or negative value on failure
}

// FUNCTION TEMPLATE _Maklocbyte
template <class _Elem>
char __cdecl _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&) {
    // convert _Elem to char using _Cvtvec
    return static_cast<char>(static_cast<unsigned char>(_Char));
}

template <>
inline char __cdecl _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec& _Cvt) {
    // convert wchar_t to char using _Cvtvec
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
    return _Byte;
}


template <>
inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec& _Cvt) {
    // convert unsigned short to char using _Cvtvec
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, static_cast<wchar_t>(_Char), &_Mbst1, &_Cvt);
    return _Byte;
}
#line 534 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

// FUNCTION TEMPLATE _Maklocchr
template <class _Elem>
_Elem __cdecl _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {
    // convert char to _Elem using _Cvtvec
    return static_cast<_Elem>(static_cast<unsigned char>(_Byte));
}

template <>
inline wchar_t __cdecl _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert char to wchar_t using _Cvtvec
    wchar_t _Wc      = L'\0';
    mbstate_t _Mbst1 = {};
    _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}


template <>
inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert char to unsigned short using _Cvtvec
    unsigned short _Wc = 0;
    mbstate_t _Mbst1   = {};
    _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
#line 561 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

// FUNCTION TEMPLATE _Maklocstr
template <class _Elem>
_Elem* __cdecl _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {
    // convert C string to _Elem sequence using _Cvtvec
    size_t _Count = :: strlen(_Ptr) + 1;

    _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale", 568));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
        *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
    }

    return _Ptrdest;
}

template <>
inline wchar_t* __cdecl _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert C string to wchar_t sequence using _Cvtvec
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    wchar_t _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; // count terminating nul

    wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale", 601));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};

    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';

    return _Ptrdest;
}


template <>
inline unsigned short* __cdecl _Maklocstr(const char* _Ptr, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert C string to unsigned short sequence using _Cvtvec
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    unsigned short _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; // count terminating nul

    wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale", 642));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';
    return reinterpret_cast<unsigned short*>(_Ptrdest);
}
#line 660 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

// STRUCT codecvt_base
class __declspec(dllimport) codecvt_base : public locale::facet { // base class for codecvt
public:
    enum { // constants for different parse states
        ok,
        partial,
        error,
        noconv
    };
    using result = int;

     codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) {}

    bool  always_noconv() const noexcept {
        // return true if conversions never change input (from codecvt)
        return do_always_noconv();
    }

    int  max_length() const noexcept {
        // return maximum length required for a conversion (from codecvt)
        return do_max_length();
    }

    int  encoding() const noexcept { // return length of code sequence (from codecvt)
        return do_encoding();
    }

     ~codecvt_base() noexcept {}

protected:
    virtual bool  do_always_noconv() const noexcept {
        // return true if conversions never change input (from codecvt)
        return false;
    }

    virtual int  do_max_length() const noexcept {
        // return maximum length required for a conversion (from codecvt)
        return 1;
    }

    virtual int  do_encoding() const noexcept { // return length of code sequence (from codecvt)
        return 1; // -1 ==> state dependent, 0 ==> varying length
    }
};

// CLASS TEMPLATE codecvt
template <class _Elem, class _Byte, class _Statype>
class codecvt : public codecvt_base { // facet for converting between _Elem and _Byte sequences
public:
    // Explicitly specialized below:
    // codecvt<wchar_t, char, mbstate_t>
    // codecvt<unsigned short, char, mbstate_t> (extension)
    // codecvt<char16_t, char, mbstate_t>
    // codecvt<char32_t, char, mbstate_t>
    // codecvt<char16_t, char8_t, mbstate_t>
    // codecvt<char32_t, char8_t, mbstate_t>

    static_assert(!0 || is_same_v<codecvt, codecvt<char, char, mbstate_t>>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;

    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count _Elems
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id; // unique facet id

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { // construct from current locale
        _Init(_Locinfo());
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        // construct from specified locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo&) {} // initialize from _Locinfo object

    virtual bool  do_always_noconv() const noexcept override {
        // return true if conversions never change input (from codecvt)
        return is_same_v<_Byte, _Elem>;
    }

    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { // convert bytes [_First1, _Last1) to [_First2, _Last2)
        _Mid1 = _First1;
        _Mid2 = _First2;
        if
            constexpr(is_same_v<_Byte, _Elem>) {
                (void) _Last1;
                (void) _Last2;
                return noconv; // convert nothing
            }
        else {
            // types differ, copy one for one
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Elem>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { // convert [_First1, _Last1) to bytes [_First2, _Last2)
        _Mid1 = _First1;
        _Mid2 = _First2;
        if
            constexpr(is_same_v<_Byte, _Elem>) {
                (void) _Last1;
                (void) _Last2;
                return noconv; // convert nothing
            }
        else {
            // types differ, copy one for one
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Byte>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const {
        // generate bytes to return to default shift state
        _Mid2 = _First2;
        return noconv; // no termination required
    }

    virtual int  do_length(
        _Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count _Elems
        // assumes 1:1 conversion
        const auto _Dist = static_cast<size_t>(_Min_value(_Last1 - _First1, ptrdiff_t{2147483647}));
        return static_cast<int>(_Min_value(_Count, _Dist));
    }
};

// STATIC codecvt::id OBJECT





template <class _Elem, class _Byte, class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;





// FUNCTION TEMPLATE _Codecvt_do_length
template <class _CvtTy, class _Byte, class _Statype>
 int _Codecvt_do_length(
    const _CvtTy& _Cvt, _Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) {
    // return p - _First1, for the largest value p in [_First1, _Last1] such that _Cvt will successfully convert
    // [_First1, p) to at most _Count wide characters

#pragma warning(suppress : 4996) 
    using _Elem = typename _CvtTy::intern_type;

    _Adl_verify_range(_First1, _Last1);
    const auto _Old_first1 = _First1;

    while (_Count > 0 && _First1 != _Last1) { // convert another wide character
        const _Byte* _Mid1;
        _Elem* _Mid2;
        _Elem _Ch;

        // test result of single wide-char conversion

#pragma warning(suppress : 4996) 
        const auto _Result = _Cvt._CvtTy::do_in(_State, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
        if (_Result != codecvt_base::ok) {
            if (_Result == codecvt_base::noconv) {
                _First1 += _Min_value(static_cast<size_t>(_Last1 - _First1), _Count);
            }

            break; // error, noconv, or partial
        }

        if (_Mid2 == &_Ch + 1) {
            --_Count; // do_in converted an output character
        }

        _First1 = _Mid1;
    }

    return static_cast<int>(_Min_value(_First1 - _Old_first1, ptrdiff_t{2147483647}));
}

// ENUM _Codecvt_mode
enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2 };

// CLASS codecvt<char16_t, char, mbstate_t>
template <>
class __declspec(dllimport) 
    codecvt<char16_t, char, mbstate_t> : public codecvt_base {
    // facet for converting between char16_t and UTF-8 byte sequences
public:
    using intern_type = char16_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count UTF-16 code units
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) { // construct from specified locale
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        // construct from specified locale and parameters
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
#pragma warning(suppress : 4996) 
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo&) {} // initialize

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert a multibyte sequence
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;
            int _Nskip;

            if (*_Pstate > 1) {
                if (_By < 0x80 || 0xc0 <= _By) {
                    return codecvt::error; // not continuation byte
                }

                // deliver second half of two-word value
                ++_Mid1;
                *_Mid2++ = static_cast<char16_t>(*_Pstate | (_By & 0x3f));
                *_Pstate = 1;
                continue;
            }

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { // 0x80-0xbf not first byte
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            _Nskip  = _Nextra < 3 ? 0 : 1; // leave a byte for 2nd word
            _First1 = _Mid1; // roll back point

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip) {
                break; // not enough input
            } else {
                for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; // not continuation byte
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (0 < _Nskip) {
                _Ch <<= 6; // get last byte on next call
            }

            if ((_Maxcode < 0x10ffffu ? _Maxcode : 0x10ffffu) < _Ch) {
                return codecvt::error; // value too large
            }

            if (0xffffu < _Ch) { // deliver first half of two-word value, save second word
                unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

                *_Mid2++ = static_cast<char16_t>(_Ch0);
                *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
                continue;
            }

            if (_Nskip != 0) {
                if (_Mid1 == _Last1) { // not enough bytes, noncanonical value
                    _Mid1 = _First1;
                    break;
                }

                if ((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By) {
                    return codecvt::error; // not continuation byte
                }

                _Ch |= _By & 0x3f; // complete noncanonical value
            }

            if (*_Pstate == 0u) { // first time, maybe look for and consume header
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { // drop header and retry
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { // roll back header determination
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }

                    return _Ans;
                }
            }

            *_Mid2++ = static_cast<char16_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert and put a wide char
            unsigned long _Ch;
            const unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
            bool _Save                = false;

            if (1 < *_Pstate) { // get saved MS 11 bits from *_Pstate
                if (_Ch1 < 0xdc00u || 0xe000u <= _Ch1) {
                    return codecvt::error; // bad second word
                }

                _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
            } else if (0xd800u <= _Ch1 && _Ch1 < 0xdc00u) { // get new first word
                _Ch   = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                _Save = true; // put only first byte, rest with second word
            } else {
                _Ch = _Ch1; // not first word, just put it
            }

            char _By;
            int _Nextra;

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x10000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            }

            int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

            if (_Last2 - _Mid2 < _Nput) {
                break; // not enough room, even without header
            }

            if (*_Pstate == 0u && (_Mode & _Generate_header) != 0) {
                if (_Last2 - _Mid2 < 3 + _Nput) {
                    break; // not enough room for header + output
                }

                // prepend header
                *_Mid2++ = '\xef';
                *_Mid2++ = '\xbb';
                *_Mid2++ = '\xbf';
            }

            ++_Mid1;
            if (_Save || _Nextra < 3) { // put first byte of sequence, if not already put
                *_Mid2++ = _By;
                --_Nput;
            }

            for (; 0 < _Nput; --_Nput) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }

            *_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char*, char*& _Mid2) const {
        // generate bytes to return to default shift state
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid2                   = _First2;

        return 1u < *_Pstate ? codecvt::error : codecvt::ok; // fail if trailing first word
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    virtual bool  do_always_noconv() const noexcept override {
        // return true if conversions never change input
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        // return maximum length required for a conversion

        if ((_Mode & _Consume_header) != 0) {
            return 9; // header + max input
        }

        if ((_Mode & _Generate_header) != 0) {
            return 7; // header + max output
        }

        return 6; // 6-byte max input sequence, no 3-byte header
    }

    virtual int do_encoding() const noexcept override { // return length of code sequence (from codecvt)
        return 0; // 0 => varying length
    }

private:
    unsigned long _Maxcode; // default: 0x10ffff
    _Codecvt_mode _Mode; // default: _Consume_header
};

// CLASS codecvt<char32_t, char, mbstate_t>
template <>
class __declspec(dllimport) 
    codecvt<char32_t, char, mbstate_t> : public codecvt_base {
    // facet for converting between char32_t and UTF-8 byte sequences
public:
    using intern_type = char32_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count UTF-32 code units
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) { // construct from specified locale
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        // construct from specified locale and parameters
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
#pragma warning(suppress : 4996) 
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo&) {} // initialize

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert a multibyte sequence
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { // 0x80-0xbf not first byte
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1) {
                break; // not enough input
            } else {
                for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; // not continuation byte
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (*_Pstate == 0) { // first time, maybe look for and consume header
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { // drop header and retry
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { // roll back header determination
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }
                    return _Ans;
                }
            }

            if (_Maxcode < _Ch) {
                return codecvt::error; // code too large
            }

            *_Mid2++ = static_cast<char32_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert and put a wide char
            char _By;
            int _Nextra;
            unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

            if (_Maxcode < _Ch) {
                return codecvt::error;
            }

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x00010000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else if (_Ch < 0x00200000u) {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            } else if (_Ch < 0x04000000u) {
                _By     = static_cast<char>(0xf8 | _Ch >> 24);
                _Nextra = 4;
            } else {
                _By     = static_cast<char>(0xfc | (_Ch >> 30 & 0x03));
                _Nextra = 5;
            }

            if (*_Pstate == 0) { // first time, maybe generate header
                *_Pstate = 1;
                if ((_Mode & _Generate_header) != 0) {
                    if (_Last2 - _Mid2 < 3 + 1 + _Nextra) {
                        return codecvt::partial; // not enough room for both
                    }

                    // prepend header
                    *_Mid2++ = '\xef';
                    *_Mid2++ = '\xbb';
                    *_Mid2++ = '\xbf';
                }
            }

            if (_Last2 - _Mid2 < 1 + _Nextra) {
                break; // not enough room for output
            }

            ++_Mid1;
            for (*_Mid2++ = _By; 0 < _Nextra;) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }
        }
        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t&, char* _First2, char*, char*& _Mid2) const {
        // generate bytes to return to default shift state
        _Mid2 = _First2;
        return codecvt::noconv;
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    virtual bool  do_always_noconv() const noexcept override {
        // return true if conversions never change input
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        // return maximum length required for a conversion
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
    }

    virtual int  do_encoding() const noexcept override {
        // return length of code sequence (from codecvt)
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1
                                                                   : 0; // -1 => state dependent, 0 => varying length
    }

private:
    unsigned long _Maxcode; // default: 0xffffffff
    _Codecvt_mode _Mode; // default: _Consume_header
};






































































































































































































































































































































































































































































































































































#line 1978 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

// CLASS codecvt<wchar_t, char, mbstate_t>
template <>
class __declspec(dllimport) codecvt<wchar_t, char, mbstate_t> : public codecvt_base {
    // facet for converting between wchar_t and char (_Byte) sequences
public:
    using intern_type = wchar_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count wide characters
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        // construct from specified locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: // partial conversion
                return partial;

            case -1: // failed conversion
                return error;

            case 0: // converted NULL character, TRANSITION, VSO#654347
                _Bytes = 1;
                // [[fallthrough]];

            default: // converted some other character
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { // destination too small, convert into buffer
                char _Buf[5];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                } else if (_Last2 - _Mid2 < _Bytes) { // converted too many, roll back and return previous
                    _State = _Stsave;
                    break;
                } else { // copy converted bytes from buffer
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; // locale-specific wcrtomb failed
        } else if (_Last2 - _Mid2 < --_Bytes) { // converted too many, roll back and return
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { // copy converted bytes from buffer
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count wide characters
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { // partial or failed conversion
                break;
            }

            if (_Bytes == 0) { // converted NULL character, TRANSITION, VSO#654347
                _Bytes = 1;
            }

            // converted _Bytes bytes to a wide character
            _First1 += _Bytes;
        }

        return static_cast<int>(_Min_value(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    virtual bool  do_always_noconv() const noexcept override {
        // return true if conversions never change input
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        // return maximum length required for a conversion (from codecvt)
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    virtual int  do_encoding() const noexcept override {
        // return length of code sequence (from codecvt)
        return _Cvt._Mbcurmax == 1; // 0 => varying length, 1 => fixed length
    }

private:
    _Locinfo::_Cvtvec _Cvt; // locale info passed to _Mbrtowc, _Wcrtomb
};


// CLASS codecvt<unsigned short, char, mbstate_t>
template <>
class __declspec(dllimport) codecvt<unsigned short, char, mbstate_t> : public codecvt_base {
    // facet for converting between unsigned short and char sequences
public:
    using intern_type = unsigned short;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const unsigned short* _First1, const unsigned short* _Last1,
        const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count _Elems
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        // construct from specified locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~codecvt() noexcept {}

    void  _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(
                reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: // partial conversion
                return partial;

            case -1: // failed conversion
                return error;

            case 0: // converted NULL character, TRANSITION, VSO#654347
                _Bytes = 1;
                // [[fallthrough]];

            default: // converted some other character
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const unsigned short* _First1,
        const unsigned short* _Last1, const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { // destination too small, convert into buffer
                char _Buf[5];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                } else if (_Last2 - _Mid2 < _Bytes) { // converted too many, roll back and return previous
                    _State = _Stsave;
                    break;
                } else { // copy converted bytes from buffer
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; // locale-specific wcrtomb failed
        } else if (_Last2 - _Mid2 < --_Bytes) { // converted too many, roll back and return
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { // copy converted bytes from buffer
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }

        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count wide characters
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { // partial or failed conversion
                break;
            }

            if (_Bytes == 0) { // converted NULL character, TRANSITION, VSO#654347
                _Bytes = 1;
            }

            // converted _Bytes bytes to a wide character
            _First1 += _Bytes;
        }

        return static_cast<int>(_Min_value(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    virtual bool  do_always_noconv() const noexcept override {
        // return true if conversions never change input
        return false;
    }

    virtual int  do_max_length() const noexcept override {
        // return maximum length required for a conversion (from codecvt)
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    virtual int  do_encoding() const noexcept override {
        // return length of code sequence (from codecvt)
        return _Cvt._Mbcurmax == 1u; // 0 => varying length, 1 => fixed length
    }

private:
    _Locinfo::_Cvtvec _Cvt; // locale info passed to _Mbrtowc, _Wcrtomb
};
#line 2382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

// CLASS TEMPLATE codecvt_byname
template <class _Elem, class _Byte, class _Statype>
class codecvt_byname : public codecvt<_Elem, _Byte, _Statype> { // codecvt for named locale
public:
    static_assert(!0
                      || _Is_any_of_v<codecvt_byname,


#line 2392 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
                          codecvt_byname<char, char, mbstate_t>, codecvt_byname<wchar_t, char, mbstate_t>>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    explicit  codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs) {} // construct for named locale

    explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs) {} // construct for named locale

protected:
    virtual  ~codecvt_byname() noexcept {}
};

// STRUCT ctype_base
struct __declspec(dllimport) ctype_base : public locale::facet { // base for ctype
    enum { // constants for character classifications
        alnum  = 0x04 | 0x02 | 0x01 | 0x100,
        alpha  = 0x02 | 0x01 | 0x100,
        cntrl  = 0x20,
        digit  = 0x04,
        graph  = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
        lower  = 0x02,
        print  = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
        punct  = 0x10,
        space  = 0x08 | 0x40 | 0x000,
        upper  = 0x01,
        xdigit = 0x80,
        blank  = 0x08 | 0x40 | 0x000 | 0x000
    };
    using mask = short; // to match <ctype.h>

     ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

     ~ctype_base() noexcept {}
};

// CLASS TEMPLATE ctype
template <class _Elem>
class ctype : public ctype_base { // facet for classifying elements, converting cases
public:
    // ctype<char>, ctype<wchar_t>, and ctype<unsigned short> are explicitly specialized below.
    static_assert(!0 || _Always_false<_Elem>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { // construct from specified locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~ctype() noexcept {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (_Ctype._Table[static_cast<unsigned char>(narrow(_Ch))] & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(narrow(*_First))];
        }

        return _First;
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { // convert element to lower case
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Tolower(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { // convert *_First to lower case
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Tolower(_Byte, &_Ctype))));
            }
        }
        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { // convert element to upper case
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Toupper(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { // convert *_First to upper case
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Toupper(_Byte, &_Ctype))));
            }
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { // widen char
        return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        char _Byte;
        if (_Ch == _Elem{}) {
            return '\0';
        }

        if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0') {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // locale info passed to _Tolower, etc.
    _Locinfo::_Cvtvec _Cvt; // conversion information
};

// STATIC ctype::id OBJECT





template <class _Elem>
locale::id ctype<_Elem>::id;





// CLASS ctype<char>
template <>
class __declspec(dllimport) ctype<char> : public ctype_base { // facet for classifying char elements, converting cases
public:
    using _Elem     = char;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(*_First)];
        }

        return _First;
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    _Elem  tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const _Elem*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    _Elem  narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(const mask* _Table = nullptr, bool _Deletetable = false,
        size_t _Refs = 0)
        : ctype_base(_Refs) { // construct with specified table and delete flag for table
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }

        _Tidy(); // free existing table, as needed
        if (_Table) { // replace existing char to mask table
            _Ctype._Table = _Table;
            _Ctype._Delfl = _Deletetable ? -1 : 0;
        } else { // use classic table
            _Ctype._Table = classic_table();
            _Ctype._Delfl = 0;
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { // construct from current locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

    const mask*  table() const noexcept { // return address of char to mask table
        return _Ctype._Table;
    }

    static const mask* __cdecl
        classic_table() noexcept { // return address of char to mask table for "C" locale
        return ::std:: use_facet<ctype>(locale::classic()).table();
    }

     static const size_t table_size = 1 << 8; // size of ctype mapping table, typically 256

protected:
    virtual  ~ctype() noexcept {
        _Tidy();
    }

    void  _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
    }

    void  _Tidy() noexcept { // free any allocated storage
        if (0 < _Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        } else if (_Ctype._Delfl < 0) {
            delete[] _Ctype._Table;
        }

        :: free(_Ctype._LocaleName);
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { // convert element to lower case
        return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { // convert element to upper case
        return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { // widen char
        return _Byte;
    }

    virtual const _Elem*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

    virtual _Elem  do_narrow(_Elem _Ch, char) const { // narrow char
        return _Ch;
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // information
};

// CLASS ctype<wchar_t>
template <>
class __declspec(dllimport) ctype<wchar_t>
    : public ctype_base { // facet for classifying wchar_t elements, converting cases
public:
    using _Elem     = wchar_t;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { // construct from specified locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~ctype() noexcept {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        return :: _Getwctypes(_First, _Last, _Dest, &_Ctype);
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { // convert element to lower case
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { // convert element to upper case
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { // widen char
        mbstate_t _Mbst = {};
        wchar_t _Wc;
        return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(((wint_t)(0xFFFF))) : _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { // widen char
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // locale info passed to _Tolower, etc.
    _Locinfo::_Cvtvec _Cvt; // conversion information
};


// CLASS ctype<unsigned short>
template <>
class __declspec(dllimport) ctype<unsigned short>
    : public ctype_base { // facet for classifying unsigned short elements, converting cases
public:
    using _Elem     = unsigned short;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { // construct from specified locale
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }

        return 2;
    }

protected:
    virtual  ~ctype() noexcept {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        return reinterpret_cast<const _Elem*>(:: _Getwctypes(
            reinterpret_cast<const wchar_t*>(_First), reinterpret_cast<const wchar_t*>(_Last), _Dest, &_Ctype));
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { // convert element to lower case
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { // convert element to upper case
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { // widen char
        mbstate_t _Mbst = {};
        unsigned short _Wc;

        if (_Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst, &_Cvt) < 0) {
            return static_cast<unsigned short>(((wint_t)(0xFFFF)));
        }

        return _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { // widen char
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // locale info passed to _Tolower, etc.
    _Locinfo::_Cvtvec _Cvt; // conversion information
};
#line 3272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

// CLASS TEMPLATE ctype_byname
template <class _Elem>
class ctype_byname : public ctype<_Elem> { // ctype for named locale
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    explicit  ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Locname), _Refs) { // construct for named locale
    }

    explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs) { // construct for named locale
    }

protected:
    virtual  ~ctype_byname() noexcept {}
};



template class __declspec(dllimport) codecvt<char, char, mbstate_t>;
#line 3295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
#line 3296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
}


#pragma warning(pop)
#pragma pack(pop)
#line 3302 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"
#line 3303 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocale"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// CLASS TEMPLATE _Iosb
template <class _Dummy>
class _Iosb { // define templatized bitmask/enumerated types, instantiate on demand
public:
    enum _Dummy_enum { _Dummy_enum_val = 1 }; // don't ask, TRANSITION, ABI
    enum _Fmtflags { // constants for formatting options
        _Fmtmask = 0xffff,
        _Fmtzero = 0
    };

    static constexpr _Fmtflags skipws     = static_cast<_Fmtflags>(0x0001);
    static constexpr _Fmtflags unitbuf    = static_cast<_Fmtflags>(0x0002);
    static constexpr _Fmtflags uppercase  = static_cast<_Fmtflags>(0x0004);
    static constexpr _Fmtflags showbase   = static_cast<_Fmtflags>(0x0008);
    static constexpr _Fmtflags showpoint  = static_cast<_Fmtflags>(0x0010);
    static constexpr _Fmtflags showpos    = static_cast<_Fmtflags>(0x0020);
    static constexpr _Fmtflags left       = static_cast<_Fmtflags>(0x0040);
    static constexpr _Fmtflags right      = static_cast<_Fmtflags>(0x0080);
    static constexpr _Fmtflags internal   = static_cast<_Fmtflags>(0x0100);
    static constexpr _Fmtflags dec        = static_cast<_Fmtflags>(0x0200);
    static constexpr _Fmtflags oct        = static_cast<_Fmtflags>(0x0400);
    static constexpr _Fmtflags hex        = static_cast<_Fmtflags>(0x0800);
    static constexpr _Fmtflags scientific = static_cast<_Fmtflags>(0x1000);
    static constexpr _Fmtflags fixed      = static_cast<_Fmtflags>(0x2000);

    static constexpr _Fmtflags hexfloat = static_cast<_Fmtflags>(0x3000); // added with TR1 (not in C++11)

    static constexpr _Fmtflags boolalpha   = static_cast<_Fmtflags>(0x4000);
    static constexpr _Fmtflags _Stdio      = static_cast<_Fmtflags>(0x8000);
    static constexpr _Fmtflags adjustfield = static_cast<_Fmtflags>(0x01C0); // left | right | internal
    static constexpr _Fmtflags basefield   = static_cast<_Fmtflags>(0x0E00); // dec | oct | hex
    static constexpr _Fmtflags floatfield  = static_cast<_Fmtflags>(0x3000); // scientific | fixed

    enum _Iostate { // constants for stream states
        _Statmask = 0x17
    };

    static constexpr _Iostate goodbit = static_cast<_Iostate>(0x0);
    static constexpr _Iostate eofbit  = static_cast<_Iostate>(0x1);
    static constexpr _Iostate failbit = static_cast<_Iostate>(0x2);
    static constexpr _Iostate badbit  = static_cast<_Iostate>(0x4);

    enum _Openmode { // constants for file opening options
        _Openmask = 0xff
    };

    static constexpr _Openmode in         = static_cast<_Openmode>(0x01);
    static constexpr _Openmode out        = static_cast<_Openmode>(0x02);
    static constexpr _Openmode ate        = static_cast<_Openmode>(0x04);
    static constexpr _Openmode app        = static_cast<_Openmode>(0x08);
    static constexpr _Openmode trunc      = static_cast<_Openmode>(0x10);
    static constexpr _Openmode _Nocreate  = static_cast<_Openmode>(0x40);
    static constexpr _Openmode _Noreplace = static_cast<_Openmode>(0x80);
    static constexpr _Openmode binary     = static_cast<_Openmode>(0x20);

    enum _Seekdir { // constants for file positioning options
        _Seekbeg,
        _Seekcur,
        _Seekend
    };

    static constexpr _Seekdir beg = _Seekbeg;
    static constexpr _Seekdir cur = _Seekcur;
    static constexpr _Seekdir end = _Seekend;

    enum { // TRANSITION, ABI
        _Openprot = 0x40
    };

    static constexpr int _Default_open_prot = 0x40; // constant for default file opening protection
};

template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hexfloat; // added with TR1 (not in C++11)

template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

// CLASS ios_base
class __declspec(dllimport) ios_base : public _Iosb<int> { // base class for ios
public:
    using fmtflags = int;
    using iostate  = int;
    using openmode = int;
    using seekdir  = int;


    using streamoff = ::std:: streamoff;
    using streampos = ::std:: streampos;
#line 179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

    enum event { // constants for ios events
        erase_event,
        imbue_event,
        copyfmt_event
    };

    using event_callback = void(__cdecl*)(event, ios_base&, int);


    using io_state  = unsigned int;
    using open_mode = unsigned int;
    using seek_dir  = unsigned int;
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

    // CLASS failure
    class failure : public system_error { // base of all iostreams exceptions
    public:
        explicit failure(const string& _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) { // construct with message
        }

        explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) { // construct with message
        }








#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"
    };

    // CLASS Init
    class __declspec(dllimport) Init { // controller for standard-stream initialization
    public:
         Init() { // initialize standard streams on first construction
            _Init_ctor(this);
        }

         ~Init() noexcept { // flush standard streams on last destruction
            _Init_dtor(this);
        }

    private:
        static  void __cdecl _Init_ctor(Init*);
        static  void __cdecl _Init_dtor(Init*);

         static int _Init_cnt; // net ctor count

        static  int& __cdecl _Init_cnt_func();
    };

    explicit  operator bool() const { // test if no stream operation has failed
        return !fail();
    }

     bool  operator!() const { // test if any stream operation has failed
        return fail();
    }

    void  clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception
        _State &= _Statmask;
        _Mystate             = _State;
        const auto _Filtered = _State & _Except;
        if (_Filtered) {
            if (_Reraise) {
                throw;
            }

            const char* _Msg;
            if (_Filtered & ios_base::badbit) {
                _Msg = "ios_base::badbit set";
            } else if (_Filtered & ios_base::failbit) {
                _Msg = "ios_base::failbit set";
            } else {
                _Msg = "ios_base::eofbit set";
            }

            throw failure(_Msg);
        }
    }

    void  clear(iostate _State = goodbit) { // set state to argument
        clear(_State, false);
    }


    void  clear(io_state _State) { // set state to argument, old-style
        clear(static_cast<iostate>(_State));
    }
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

     iostate  rdstate() const { // return stream state
        return _Mystate;
    }

    void  setstate(
        iostate _State, bool _Exreraise) { // merge in state argument, possibly reraise exception
        clear(rdstate() | _State, _Exreraise);
    }

    void  setstate(iostate _State) { // merge in state argument
        clear(rdstate() | _State, false);
    }


    void  setstate(io_state _State) { // merge in state argument, old style
        setstate(static_cast<iostate>(_State));
    }
#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

     bool  good() const { // test if no state bits are set
        return rdstate() == ios_base::goodbit;
    }

     bool  eof() const { // test if eofbit is set in stream state
        return rdstate() & ios_base::eofbit;
    }

     bool  fail() const { // test if badbit or failbit is set in stream state
        return rdstate() & (ios_base::badbit | ios_base::failbit);
    }

     bool  bad() const { // test if badbit is set in stream state
        return rdstate() & ios_base::badbit;
    }

     iostate  exceptions() const { // return exception mask
        return _Except;
    }

    void  exceptions(iostate _Newexcept) { // set exception mask to argument
        _Except = _Newexcept & _Statmask;
        clear(rdstate());
    }


    void  exceptions(io_state _State) { // set exception mask to argument, old style
        exceptions(static_cast<iostate>(_State));
    }
#line 324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

     fmtflags  flags() const { // return format flags
        return _Fmtfl;
    }

    fmtflags  flags(fmtflags _Newfmtflags) { // set format flags to argument
        const fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                      = _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(fmtflags _Newfmtflags) { // merge in format flags argument
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl |= _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(
        fmtflags _Newfmtflags, fmtflags _Mask) { // merge in format flags argument under mask argument
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                                = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
        return _Oldfmtflags;
    }

    void  unsetf(fmtflags _Mask) { // clear format flags under mask argument
        _Fmtfl &= ~_Mask;
    }

     streamsize  precision() const { // return precision
        return _Prec;
    }

    streamsize  precision(streamsize _Newprecision) { // set precision to argument
        const streamsize _Oldprecision = _Prec;
        _Prec                          = _Newprecision;
        return _Oldprecision;
    }

     streamsize  width() const { // return width
        return _Wide;
    }

    streamsize  width(streamsize _Newwidth) { // set width to argument
        const streamsize _Oldwidth = _Wide;
        _Wide                      = _Newwidth;
        return _Oldwidth;
    }

     locale  getloc() const { // get locale
        return *_Ploc;
    }

    locale  imbue(const locale& _Loc) { // set locale to argument
        locale _Oldlocale = *_Ploc;
        *_Ploc            = _Loc;
        _Callfns(imbue_event);
        return _Oldlocale;
    }

     static int __cdecl xalloc() { // allocate new iword/pword index
        { ::std:: _Lockit _Lock(2); // lock thread to ensure atomicity
        return _Index++;
        }
    }

     long&  iword(int _Idx) { // return reference to long element
        return _Findarr(_Idx)._Lo;
    }

     void*&  pword(int _Idx) { // return reference to pointer element
        return _Findarr(_Idx)._Vp;
    }

    void  register_callback(event_callback _Pfn,
        int _Idx) { // register event handler
        _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
    }

    ios_base&  copyfmt(const ios_base& _Other) { // copy format stuff
        if (this != ::std:: addressof(_Other)) { // copy all but _Mystate
            _Tidy();
            *_Ploc          = *_Other._Ploc;
            _Fmtfl          = _Other._Fmtfl;
            _Prec           = _Other._Prec;
            _Wide           = _Other._Wide;
            _Iosarray* _Ptr = _Other._Arr;

            for (_Arr = nullptr; _Ptr; _Ptr = _Ptr->_Next) {
                if (_Ptr->_Lo != 0 || _Ptr->_Vp) { // copy over nonzero array values
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                }
            }

            for (_Fnarray* _Pfa = _Other._Calls; _Pfa; _Pfa = _Pfa->_Next) {
                register_callback(_Pfa->_Pfn, _Pfa->_Index);
            }

            _Callfns(copyfmt_event); // call callbacks
            exceptions(_Other._Except); // cause any throw at end
        }
        return *this;
    }

    static bool __cdecl sync_with_stdio(
        bool _Newsync = true) { // set C/C++ synchronization flag from argument
        { ::std:: _Lockit _Lock(2); // lock thread to ensure atomicity
        const bool _Oldsync = _Sync;
        _Sync               = _Newsync;
        return _Oldsync;
        }
    }

    void  swap(ios_base& _Right) { // swap with _Right
        if (this != ::std:: addressof(_Right)) { // different, do the move
            ::std:: swap(_Mystate, _Right._Mystate);
            ::std:: swap(_Except, _Right._Except);
            ::std:: swap(_Fmtfl, _Right._Fmtfl);
            ::std:: swap(_Prec, _Right._Prec);
            ::std:: swap(_Wide, _Right._Wide);

            ::std:: swap(_Arr, _Right._Arr);
            ::std:: swap(_Calls, _Right._Calls);
            ::std:: swap(_Ploc, _Right._Ploc);
        }
    }

    virtual  ~ios_base() noexcept {
        _Ios_base_dtor(this);
    }

    static  void __cdecl _Addstd(ios_base*); // add standard stream

    size_t _Stdstr; // if > 0 index of standard stream to suppress destruction

protected:
     ios_base() {}

    void  _Init() { // initialize a new ios_base
        _Ploc   = nullptr;
        _Stdstr = 0;
        _Except = goodbit;
        _Fmtfl  = skipws | dec;
        _Prec   = 6;
        _Wide   = 0;
        _Arr    = nullptr;
        _Calls  = nullptr;
        clear(goodbit);
        _Ploc = new locale;
    }

private:
    // STRUCT _Iosarray
    struct _Iosarray : public _Crt_new_delete { // list element for open-ended sparse array of longs/pointers
    public:
         _Iosarray(int _Idx, _Iosarray* _Link)
            : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) { // construct node for index _Idx and link it in
        }

        _Iosarray* _Next; // pointer to next node
        int _Index; // index of this node
        long _Lo; // stored long value
        void* _Vp; // stored pointer value
    };

    // STRUCT _Fnarray
    struct _Fnarray : public _Crt_new_delete { // list element for open-ended sparse array of event handlers
         _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
            : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) { // construct node for index _Idx and link it in
        }

        _Fnarray* _Next; // pointer to next node
        int _Index; // index of this node
        event_callback _Pfn; // pointer to event handler
    };

    void  _Callfns(event _Ev) { // call all event handlers, reporting event
        for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
            (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
        }
    }

    _Iosarray&  _Findarr(int _Idx) { // locate or make a variable array element
        _Iosarray *_Ptr1, *_Ptr2;

        for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
            if (_Ptr1->_Index == _Idx) {
                return *_Ptr1; // found element, return it
            } else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
                _Ptr2 = _Ptr1; // found recycling candidate
            }
        }

        if (_Ptr2) { // recycle existing element
            _Ptr2->_Index = _Idx;
            return *_Ptr2;
        }

        _Arr = new _Iosarray(_Idx, _Arr); // make a new element
        return *_Arr;
    }

    void  _Tidy() noexcept { // discard storage for an ios_base
        _Callfns(erase_event);
        _Iosarray *_Ptr1, *_Ptr2;

        for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { // delete array element
            _Ptr2 = _Ptr1->_Next;
            delete _Ptr1;
        }
        _Arr = nullptr;

        _Fnarray *_Pfa1, *_Pfa2;
        for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { // delete callback element
            _Pfa2 = _Pfa1->_Next;
            delete _Pfa1;
        }
        _Calls = nullptr;
    }

    iostate _Mystate; // stream state
    iostate _Except; // exception mask
    fmtflags _Fmtfl; // format flags
    streamsize _Prec; // field precision
    streamsize _Wide; // field width
    _Iosarray* _Arr; // pointer to first node of long/pointer array
    _Fnarray* _Calls; // pointer to first node of call list
    locale* _Ploc; // pointer to locale

     static int _Index;
     static bool _Sync;

    static  void __cdecl _Ios_base_dtor(ios_base*);

public:
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"
#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xiosbase"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// CLASS TEMPLATE basic_streambuf
template <class _Elem, class _Traits>
class basic_streambuf { // control read/write buffers
protected:
     basic_streambuf() : _Plocale(new locale) { // construct with no buffers
        _Init();
    }

     basic_streambuf(_Uninitialized) { // construct uninitialized
    }

     basic_streambuf(const basic_streambuf& _Right)
        : _Plocale(new locale(_Right.getloc())) { // construct by copying _Right
        _Init();
        setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
        setg(_Right.eback(), _Right.gptr(), _Right.egptr());
    }

    basic_streambuf&  operator=(const basic_streambuf& _Right) { // assign from _Right
        if (this != ::std:: addressof(_Right)) { // different, worth copying
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            pubimbue(_Right.getloc());
        }
        return *this;
    }

    void  swap(basic_streambuf& _Right) { // swap with _Right
        if (this != ::std:: addressof(_Right)) { // different, worth swapping
            _Elem* _Pfirst0 = pbase();
            _Elem* _Pnext0  = pptr();
            _Elem* _Pend    = epptr();
            _Elem* _Gfirst0 = eback();
            _Elem* _Gnext0  = gptr();
            _Elem* _Gend    = egptr();

            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            _Right.setp(_Pfirst0, _Pnext0, _Pend);

            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            _Right.setg(_Gfirst0, _Gnext0, _Gend);

            ::std:: swap(_Plocale, _Right._Plocale);
        }
    }

public:
    using char_type   = _Elem;
    using traits_type = _Traits;

    virtual  ~basic_streambuf() noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    pos_type  pubseekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position by _Off, according to _Way, _Mode
        return seekoff(_Off, _Way, _Mode);
    }


    pos_type  pubseekoff(off_type _Off, ios_base::seek_dir _Way,
        ios_base::open_mode _Mode) { // change position by _Off, according to _Way, _Mode (old style)
        return pubseekoff(_Off, static_cast<ios_base::seekdir>(_Way), static_cast<ios_base::openmode>(_Mode));
    }
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

    pos_type  pubseekpos(pos_type _Pos,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position to _Pos, according to _Mode
        return seekpos(_Pos, _Mode);
    }


    pos_type  pubseekpos(pos_type _Pos,
        ios_base::open_mode _Mode) { // change position to _Pos, according to _Mode (old style)
        return seekpos(_Pos, static_cast<ios_base::openmode>(_Mode));
    }
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

    basic_streambuf*  pubsetbuf(_Elem* _Buffer,
        streamsize _Count) { // offer _Buffer to external agent
        return setbuf(_Buffer, _Count);
    }

    locale  pubimbue(const locale& _Newlocale) { // set locale to argument
        locale _Oldlocale = *_Plocale;
        imbue(_Newlocale);
        *_Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale  getloc() const { // get locale
        return *_Plocale;
    }

    streamsize  in_avail() { // return count of buffered input characters
        streamsize _Res = _Gnavail();
        return 0 < _Res ? _Res : showmanyc();
    }

    int  pubsync() { // synchronize with external agent
        return sync();
    }

    int_type  sbumpc() { // get a character and point past it
        return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
    }

    int_type  sgetc() { // get a character and don't point past it
        return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
    }

    streamsize  sgetn(_Elem* _Ptr,
        streamsize _Count) { // get up to _Count characters into array beginning at _Ptr
        return xsgetn(_Ptr, _Count);
    }

    int_type  snextc() { // point to next character and return it
        return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())
                              : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof() : sgetc();
    }

    int_type  sputbackc(_Elem _Ch) { // put back _Ch
        if (gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])) {
            return _Traits::to_int_type(*_Gndec());
        }

        return pbackfail(_Traits::to_int_type(_Ch));
    }


    void  stossc() { // point past a character
        if (0 < _Gnavail()) {
            _Gninc();
        } else {
            uflow();
        }
    }
#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

    int_type  sungetc() { // back up one position
        return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
    }

    int_type  sputc(_Elem _Ch) { // put a character
        return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
    }

    streamsize  sputn(const _Elem* _Ptr,
        streamsize _Count) { // put _Count characters from array beginning at _Ptr
        return xsputn(_Ptr, _Count);
    }

    virtual void  _Lock() { // set the thread lock (overridden by basic_filebuf)
    }

    virtual void  _Unlock() { // clear the thread lock (overridden by basic_filebuf)
    }

protected:
    _Elem*  eback() const { // return beginning of read buffer
        return *_IGfirst;
    }

    _Elem*  gptr() const { // return current position in read buffer
        return *_IGnext;
    }

    _Elem*  pbase() const { // return beginning of write buffer
        return *_IPfirst;
    }

    _Elem*  pptr() const { // return current position in write buffer
        return *_IPnext;
    }

    _Elem*  egptr() const { // return end of read buffer
        return *_IGnext + *_IGcount;
    }

    void  gbump(int _Off) { // alter current position in read buffer by _Off
        *_IGcount -= _Off;
        *_IGnext += _Off;
    }

    void  setg(_Elem* _First, _Elem* _Next, _Elem* _Last) { // set pointers for read buffer
        *_IGfirst = _First;
        *_IGnext  = _Next;
        *_IGcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  epptr() const { // return end of write buffer
        return *_IPnext + *_IPcount;
    }

    _Elem*  _Gndec() { // decrement current position in read buffer
        ++*_IGcount;
        return --*_IGnext;
    }

    _Elem*  _Gninc() { // increment current position in read buffer
        --*_IGcount;
        return (*_IGnext)++;
    }

    _Elem*  _Gnpreinc() { // preincrement current position in read buffer
        --*_IGcount;
        return ++(*_IGnext);
    }

    streamsize  _Gnavail() const { // count number of available elements in read buffer
        return *_IGnext ? *_IGcount : 0;
    }

    void  pbump(int _Off) { // alter current position in write buffer by _Off
        *_IPcount -= _Off;
        *_IPnext += _Off;
    }

    void  setp(_Elem* _First, _Elem* _Last) { // set pointers for write buffer
        *_IPfirst = _First;
        *_IPnext  = _First;
        *_IPcount = static_cast<int>(_Last - _First);
    }

    void  setp(
        _Elem* _First, _Elem* _Next, _Elem* _Last) { // set pointers for write buffer, extended version
        *_IPfirst = _First;
        *_IPnext  = _Next;
        *_IPcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  _Pninc() { // increment current position in write buffer
        --*_IPcount;
        return (*_IPnext)++;
    }

    streamsize  _Pnavail() const { // count number of available positions in write buffer
        return *_IPnext ? *_IPcount : 0;
    }

    void  _Init() { // initialize buffer parameters for no buffers
        _IGfirst = &_Gfirst;
        _IPfirst = &_Pfirst;
        _IGnext  = &_Gnext;
        _IPnext  = &_Pnext;
        _IGcount = &_Gcount;
        _IPcount = &_Pcount;
        setp(nullptr, nullptr);
        setg(nullptr, nullptr, nullptr);
    }

    void  _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn,
        int* _Pc) { // initialize buffer parameters as specified
        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext  = _Gn;
        _IPnext  = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type  overflow(int_type = _Traits::eof()) { // put a character to stream (always fail)
        return _Traits::eof();
    }

    virtual int_type  pbackfail(
        int_type = _Traits::eof()) { // put a character back to stream (always fail)
        return _Traits::eof();
    }

    virtual streamsize  showmanyc() { // return count of input characters
        return 0;
    }

    virtual int_type  underflow() { // get a character from stream, but don't point past it
        return _Traits::eof();
    }

    virtual int_type  uflow() { // get a character from stream, point past it
        return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
    }

    virtual streamsize  xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream
        const streamsize _Start_count = _Count;

        while (0 < _Count) {
            streamsize _Size = _Gnavail();
            if (0 < _Size) { // copy from read buffer
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                gbump(static_cast<int>(_Size));
            } else {
                const int_type _Meta = uflow();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; // end of file, quit
                }

                // get a single character
                *_Ptr++ = _Traits::to_char_type(_Meta);
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize  xsputn(
        const _Elem* _Ptr, streamsize _Count) { // put _Count characters to stream
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Pnavail();
            if (0 < _Size) { // copy to write buffer
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                pbump(static_cast<int>(_Size));
            } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
                break; // single character put failed, quit
            } else { // count character successfully put
                ++_Ptr;
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type  seekoff(off_type, ios_base::seekdir,
        ios_base::openmode = ios_base::in | ios_base::out) { // change position by offset, according to way and mode
        return streampos(-1);
    }

    virtual pos_type  seekpos(pos_type,
        ios_base::openmode = ios_base::in | ios_base::out) { // change to specified position, according to mode
        return streampos(-1);
    }

    virtual basic_streambuf*  setbuf(
        _Elem*, streamsize) { // offer buffer to external agent (do nothing)
        return this;
    }

    virtual int  sync() { // synchronize with external agent (do nothing)
        return 0;
    }

    virtual void  imbue(const locale&) { // set locale to argument (do nothing)
    }

private:
    _Elem* _Gfirst; // beginning of read buffer
    _Elem* _Pfirst; // beginning of write buffer
    _Elem** _IGfirst; // pointer to beginning of read buffer
    _Elem** _IPfirst; // pointer to beginning of write buffer
    _Elem* _Gnext; // current position in read buffer
    _Elem* _Pnext; // current position in write buffer
    _Elem** _IGnext; // pointer to current position in read buffer
    _Elem** _IPnext; // pointer to current position in write buffer

    int _Gcount; // length of read buffer
    int _Pcount; // length of write buffer
    int* _IGcount; // pointer to length of read buffer
    int* _IPcount; // pointer to length of write buffer

protected:
    locale* _Plocale; // pointer to imbued locale object
};




template class __declspec(dllimport) basic_streambuf<char, char_traits<char>>;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t>>;
#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"




#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

// CLASS TEMPLATE istreambuf_iterator
template <class _Elem, class _Traits>
class istreambuf_iterator { // wrap stream buffer as input iterator
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Elem;
    using difference_type   = typename _Traits::off_type;
    using pointer           = const _Elem*;
    using reference         = _Elem;

    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using istream_type   = basic_istream<_Elem, _Traits>;

    using int_type = typename traits_type::int_type;

    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

    istreambuf_iterator(streambuf_type* _Sb) noexcept
        : _Strbuf(_Sb), _Got(!_Sb), _Val() { // construct from stream buffer _Sb
    }

    istreambuf_iterator(istream_type& _Istr) noexcept
        : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() { // construct from stream buffer in istream _Istr
    }

private:
    class _Istreambuf_proxy {
    public:
         _Elem operator*() const {
            return _Keep;
        }

    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) : _Strbuf(_Strbuf_), _Keep(_Keep_) {}

        streambuf_type* _Strbuf;
        _Elem _Keep;
    };

public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept
        : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val() { // construct from proxy
    }

     _Elem operator*() const {
        if (!_Got) {
            _Peek();
        }


        do { if (_Strbuf) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf", 463, 0, "%s", "istreambuf_iterator is not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not dereferencable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf", 463, 0); } while (false); } ; } while (false);
#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

        return _Val;
    }

    istreambuf_iterator& operator++() {

        do { if (_Strbuf) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf", 471, 0, "%s", "istreambuf_iterator is not incrementable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not incrementable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf", 471, 0); } while (false); } ; } while (false);
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

        _Inc();
        return *this;
    }

    _Istreambuf_proxy operator++(int) {
        if (!_Got) {
            _Peek();
        }

        _Istreambuf_proxy _Tmp{_Strbuf, _Val};
        ++*this;
        return _Tmp;
    }

     bool equal(const istreambuf_iterator& _Right) const { // test for equality
        if (!_Got) {
            _Peek();
        }

        if (!_Right._Got) {
            _Right._Peek();
        }

        return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
    }

private:
    void _Inc() { // skip to next input element
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got    = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek() const { // peek at next input element
        int_type _Meta;
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type::to_char_type(_Meta);
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type* _Strbuf; // the wrapped stream buffer
    mutable bool _Got; // true if _Val is valid
    mutable _Elem _Val; // next element to deliver
};

template <class _Elem, class _Traits>
 bool operator==(const istreambuf_iterator<_Elem, _Traits>& _Left,
    const istreambuf_iterator<_Elem, _Traits>& _Right) { // test for istreambuf_iterator equality
    return _Left.equal(_Right);
}

template <class _Elem, class _Traits>
 bool operator!=(const istreambuf_iterator<_Elem, _Traits>& _Left,
    const istreambuf_iterator<_Elem, _Traits>& _Right) { // test for istreambuf_iterator inequality
    return !(_Left == _Right);
}

// CLASS TEMPLATE ostreambuf_iterator
template <class _Elem, class _Traits>
class ostreambuf_iterator { // wrap stream buffer as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;

    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type   = basic_ostream<_Elem, _Traits>;

    ostreambuf_iterator(streambuf_type* _Sb) noexcept
        : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb
    }

    ostreambuf_iterator(ostream_type& _Ostr) noexcept
        : _Failed(false), _Strbuf(_Ostr.rdbuf()) { // construct from stream buffer in _Ostr
    }

    ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment
        if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }

        return *this;
    }

     ostreambuf_iterator& operator*() { // pretend to get designated element
        return *this;
    }

    ostreambuf_iterator& operator++() { // pretend to preincrement
        return *this;
    }

    ostreambuf_iterator& operator++(int) { // pretend to postincrement
        return *this;
    }

     bool failed() const noexcept { // return true if any stores failed
        return _Failed;
    }

private:
    bool _Failed; // true if any stores have failed
    streambuf_type* _Strbuf; // the wrapped stream buffer
};
}



#pragma warning(pop)
#pragma pack(pop)
#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"
#line 598 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\streambuf"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




// TEXT-TO-NUMERIC CONVERSION FUNCTIONS


extern "C" {
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"

extern  float __cdecl _Stofx(
    const char*,     char**, long, int*);
extern  double __cdecl _Stodx(
    const char*,     char**, long, int*);
extern  long double __cdecl _Stoldx(
    const char*,     char**, long, int*);
extern  long __cdecl _Stolx(
    const char*,     char**, int, int*);
extern  unsigned long __cdecl _Stoulx(
    const char*,     char**, int, int*);
extern  long long __cdecl _Stollx(
    const char*,     char**, int, int*);
extern  unsigned long long __cdecl _Stoullx(
    const char*,     char**, int, int*);


}
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"

namespace std {

// FUNCTION _Stodx_v2
inline double _Stodx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { // convert string to double
    int& _Errno_ref = (*_errno()); // Nonzero cost, pay it once
    const int _Orig = _Errno_ref;

    _Errno_ref  = 0;
    double _Val = :: strtod(_Str, _Endptr);
    *_Perr      = _Errno_ref;
    _Errno_ref  = _Orig;

    if (_Pten != 0) {
        _Val *= :: pow(10.0, static_cast<double>(_Pten));
    }

    return _Val;
}

// FUNCTION _Stofx_v2
inline float _Stofx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { // convert string to float
    int& _Errno_ref = (*_errno()); // Nonzero cost, pay it once
    const int _Orig = _Errno_ref;

    _Errno_ref = 0;
    float _Val = :: strtof(_Str, _Endptr);
    *_Perr     = _Errno_ref;
    _Errno_ref = _Orig;

    if (_Pten != 0) {
        _Val *= :: powf(10.0f, static_cast<float>(_Pten));
    }

    return _Val;
}

// FUNCTION TEMPLATE _Find_elem
template <class _Elem, size_t _Base_size>
size_t _Find_elem(const _Elem (&_Base)[_Base_size],
    const _Elem _Ch) { // lookup _Ch in array storing NUL-terminated string _Base
                       // pre: _Base contains no nulls except for _Base[_Base_size - 1]
    return static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
}

inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage
    const size_t _Count = :: wcslen(_Ptr) + 1;

    wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum", 92));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    :: wmemcpy(_Ptrdest, _Ptr, _Count);
    return _Ptrdest;
}

// CLASS TEMPLATE numpunct
template <class _Elem>
class numpunct : public locale::facet { // facet for defining numeric punctuation text
private:
    friend _Tidy_guard<numpunct>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
    using char_type   = _Elem;

     __declspec(dllimport) static locale::id id; // unique facet id

    _Elem decimal_point() const { // return decimal point
        return do_decimal_point();
    }

    _Elem thousands_sep() const { // return thousands separator
        return do_thousands_sep();
    }

    string grouping() const { // return grouping string
        return do_grouping();
    }

    string_type falsename() const { // return name for false
        return do_falsename();
    }

    string_type truename() const { // return name for true
        return do_truename();
    }

    explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        if (_Kseparator == 0) {
            _Kseparator = // NB: differs from "C" locale
                _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
        }
        }
    }

    numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
        : locale::facet(_Refs) { // construct from specified locale
        _Init(_Lobj, _Isdef);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);
        }
        return 4;
    }

protected:
    virtual  ~numpunct() noexcept {
        _Tidy();
    }

    numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false)
        : locale::facet(_Refs) { // construct from specified locale
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj, _Isdef);
        }
    }

    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { // get values
        _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }

    void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec) { // get values
        _Dp         = static_cast<_Elem>(_Ptr->_W_decimal_point[0]);
        _Kseparator = static_cast<_Elem>(_Ptr->_W_thousands_sep[0]);
    }

    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj
        const lconv* _Ptr      = _Lobj._Getlconv();
        _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); // conversion information

        _Grouping  = nullptr;
        _Falsename = nullptr;
        _Truename  = nullptr;

        _Tidy_guard<numpunct> _Guard{this};
        _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
        _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
        _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
        _Guard._Target = nullptr;

        if (_Isdef) { // apply defaults for required facets
            // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
            _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
        } else {
            _Getvals(_Elem{}, _Ptr, _Cvt);
        }
    }

    virtual _Elem  do_decimal_point() const { // return decimal point
        return _Dp;
    }

    virtual _Elem  do_thousands_sep() const { // return thousands separator
        return _Kseparator;
    }

    virtual string  do_grouping() const { // return grouping string
        return string(_Grouping);
    }

    virtual string_type  do_falsename() const { // return name for false
        return string_type(_Falsename);
    }

    virtual string_type  do_truename() const { // return name for true
        return string_type(_Truename);
    }

private:
    void _Tidy() noexcept { // free all storage
        :: free(const_cast<char*>(_Grouping));
        :: free(const_cast<_Elem*>(_Falsename));
        :: free(const_cast<_Elem*>(_Truename));
    }

    const char* _Grouping; // grouping string, "" for "C" locale
    _Elem _Dp; // decimal point, '.' for "C" locale
    _Elem _Kseparator; // thousands separator, '\0' for "C" locale
    const _Elem* _Falsename; // name for false, "false" for "C" locale
    const _Elem* _Truename; // name for true, "true" for "C" locale
};

// CLASS TEMPLATE numpunct_byname
template <class _Elem>
class numpunct_byname : public numpunct<_Elem> { // numpunct for named locale
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    explicit numpunct_byname(const char* _Locname, size_t _Refs = 0)
        : numpunct<_Elem>(_Locname, _Refs) { // construct for named locale
    }

    explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
        : numpunct<_Elem>(_Str.c_str(), _Refs) { // construct for named locale
    }

protected:
    virtual  ~numpunct_byname() noexcept {}
};

// STATIC numpunct::id OBJECT






template <class _Elem>
 locale::id numpunct<_Elem>::id;




#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"

// CLASS TEMPLATE num_get
template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_get : public locale::facet { // facet for converting text to encoded numbers
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->c_str()));
        }

        return 4;
    }

     static locale::id id; // unique facet id

protected:
    virtual  ~num_get() noexcept {}

    void _Init(const _Locinfo&) { // initialize from _Locinfo object
    }

public:
    explicit  num_get(size_t _Refs = 0) : locale::facet(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
        : locale::facet(_Refs) { // construct from specified locale
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { // get bool from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { // get unsigned short from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { // get unsigned int from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { // get long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { // get unsigned long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { // get long long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { // get unsigned long long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { // get float from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { // get double from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { // get long double from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { // get void pointer from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

protected:
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { // get bool from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        if (_Iosbase.flags() & ios_base::boolalpha) { // get false name or true name
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
            _Str += _Punct_fac.falsename();
            _Str.push_back(_Elem{});
            _Str += _Punct_fac.truename(); // construct "\0false\0true"
            switch (_Getloctxt(_First, _Last, 2, _Str.c_str())) {
            case 0:
                _Val = false;
                break;
            case 1:
                _Val = true;
                break;
            default:
                _Val   = false;
                _State = ios_base::failbit;
                break;
            }
        } else { // get long value
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
            if (_Ac[0] == '\0') { // Handle N4727 [facet.num.get.virtuals]/3.6:
                                  //  "zero, if the conversion function does not convert the entire field."
                                  // We should still do numeric conversion with bad digit separators, instead of
                                  // setting 0, but we can't distinguish that from _Getifld's interface, and _Getifld's
                                  // interface can't be changed as it is an exported function. Fixing that when ABI
                                  // allows is tracked by VSO#591516.
                _Val   = false;
                _State = ios_base::failbit;
            } else {
                char* _Ep;
                int _Errno;
                const long _Ans = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); // convert
                if (_Ep == _Ac || _Errno != 0) {
                    _Val   = true;
                    _State = ios_base::failbit;
                } else {
                    _Val = _Ans != 0;
                    if (_Ans != 0 && _Ans != 1) {
                        _State = ios_base::failbit;
                    }
                }
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { // get unsigned short from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            const bool _Minus   = _Ac[0] == '-';
            const char* _Digits = _Ac;
            // C11 7.22.1.4/5: the sequence of characters starting with the first digit
            // is interpreted as an integer constant according to the rules of 6.4.4.1
            if (_Minus) { // skip over minus to start with the first digit
                ++_Digits;
            }

            char* _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx(_Digits, &_Ep, _Base, &_Errno); // convert
            _Val                     = static_cast<unsigned short>(_Tmp);
            if (_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff) {
                _State = ios_base::failbit;
                _Val   = 0xffff;
            } else if (_Minus) { // C11 7.22.1.4/5:  If the subject sequence begins with a minus sign,
                                 // the value resulting from the conversion is negated (in the return type).
                _Val = static_cast<unsigned short>(0 - _Val);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { // get unsigned int from [_First, _Last) into _Val
        static_assert(sizeof(unsigned int) == sizeof(unsigned long),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
        unsigned long _Tmp;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf
        _Val   = _Tmp;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { // get long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { // get unsigned long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stoulx(_Ac, &_Ep, _Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { // get long long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stollx(_Ac, &_Ep, _Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { // get unsigned long long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = :: _Stoullx(_Ac, &_Ep, _Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

// Sentinel value used by num_get::do_get() to enable correct "V2" behavior in _Getffld() and _Getffldx()


// Size of char buffer used by num_get::do_get() for float/double/long double


    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { // get float from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        int _Hexexp     = 1000000000;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); // gather field
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0.0f;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0f;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexpf(_Val, 4 * _Hexexp);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { // get double from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        int _Hexexp     = 1000000000;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); // gather field
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = 0.0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexp(_Val, 4 * _Hexexp);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }


    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { // get long double from [_First, _Last) into _Val
        static_assert(sizeof(double) == sizeof(long double), "Bad assumption: sizeof(double) == sizeof(long double).");
        double _Result;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf
        _Val   = _Result;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { // get void pointer from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); // gather field
        if (_Ac[0] == '\0') { // ditto "fails to convert the entire field" / VSO#591516
            _State = ios_base::failbit;
            _Val   = nullptr;
        } else {
            int _Errno;
            char* _Ep;



            _Val = reinterpret_cast<void*>(:: _Stoulx(_Ac, &_Ep, _Base, &_Errno));
#line 654 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = nullptr;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

private:
    int __cdecl _Getifld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
        const locale& _Loc) const { // get integer field from [_First, _Last) into _Ac
        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();

        constexpr int _Numget_signoff             = 22;
        constexpr int _Numget_xoff                = 24;
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

        char* _Ptr = _Ac;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign
                *_Ptr++ = '-';
                ++_First;
            }
        }

        _Basefield &= ios_base::basefield;

        int _Base;
        if (_Basefield == ios_base::oct) {
            _Base = 8;
        } else if (_Basefield == ios_base::hex) {
            _Base = 16;
        } else if (_Basefield == ios_base::_Fmtzero) {
            _Base = 0;
        } else {
            _Base = 10;
        }

        bool _Seendigit = false; // seen a digit in input
        bool _Nonzero   = false; // seen a nonzero digit in input

        if (_First != _Last && *_First == _Atoms[0]) { // leading zero, look for 0x, 0X
            _Seendigit = true;
            ++_First;
            if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                && (_Base == 0 || _Base == 16)) {
                _Base      = 16;
                _Seendigit = false;
                ++_First;
            } else if (_Base == 0) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
        string _Groups(1, static_cast<char>(_Seendigit));
        size_t _Group = 0;

        for (char* const _Pe = &_Ac[32 - 1]; _First != _Last; ++_First) { // look for digits and separators
            size_t _Idx = _Find_elem(_Atoms, *_First);
            if (_Idx < _Dlen) { // got a digit, characterize it and add to group size
                *_Ptr = _Src[_Idx];
                if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {
                    ++_Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if (_Groups[_Group] != 127) {
                    ++_Groups[_Group];
                }
            } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                break; // not a group separator, done
            } else { // add a new group to _Groups string
                _Groups.push_back('\0');
                ++_Group;
            }
        }

        if (_Group != 0) {
            if ('\0' < _Groups[_Group]) {
                ++_Group; // add trailing group to group count
            } else {
                _Seendigit = false; // trailing separator, fail
            }
        }

        for (const char* _Pg = &_Grouping[0]; _Seendigit && 0 < _Group;) {
            if (*_Pg == 127) {
                break; // end of grouping constraints to check
            } else if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                _Seendigit = false; // bad group size, fail
            } else if ('\0' < _Pg[1]) {
                ++_Pg; // group size okay, advance to next test
            }
        }

        if (_Seendigit && !_Nonzero) {
            *_Ptr++ = '0'; // zero field, replace stripped zero(s)
        } else if (!_Seendigit) {
            _Ptr = _Ac; // roll back pointer to indicate failure
        }

        *_Ptr = '\0';
        return _Base;
    }

    int __cdecl _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { // get floating-point field from [_First, _Last) into _Ac
        if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat) {
            return _Getffldx(_Ac, _First, _Last, _Iosbase, _Phexexp); // hex format
        }

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        char* _Ptr             = _Ac;
        bool _Bad              = false;
        bool _Sticky           = false;

        constexpr int _Numget_signoff             = 10;
        constexpr int _Numget_eoff                = 12;
        static constexpr char _Src[] = "0123456789-+Ee";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign
                *_Ptr++ = '-';
                ++_First;
            }
        }

        char* _Leading = _Ptr; // remember backstop
        *_Ptr++        = '0'; // backstop carries from sticky bit

        bool _Seendigit  = false; // seen a digit in input
        int _Significant = 0; // number of significant digits
        int _Pten        = 0; // power of 10 multiplier
        size_t _Idx;

        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) { // enough digits, scale by 10 and update _Sticky
                    ++_Pten;
                    if (0 < _Idx) {
                        _Sticky = true;
                    }
                } else if (_Idx != 0 || _Significant != 0) { // save a significant digit
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { // grouping specified, gather digits and group sizes
            const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();
            string _Groups(1, '\0');
            size_t _Group = 0;

            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < 10) { // got a digit, add to group size
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) { // enough digits, scale by 10 and update _Sticky
                        ++_Pten;
                        if (0 < _Idx) {
                            _Sticky = true;
                        }
                    } else if (_Idx != 0 || _Significant != 0) { // save a significant digit
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Group] != 127) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                    break; // not a group separator, done
                } else { // add a new group to _Groups string
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; // add trailing group to group count
                } else {
                    _Bad = true; // trailing separator, fail
                }
            }

            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127) {
                    break; // end of grouping constraints to check
                }

                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; // bad group size, fail
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; // group size okay, advance to next test
                }
            }
        }

        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { // add .
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }

        if (*_Phexexp != 1000000000 && _Significant == 0) { // 0000. so far
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Pten; // just count leading fraction zeros
            }

            if (_Pten < 0) { // put one back
                *_Ptr++ = '0';
                ++_Pten;
            }
        }

        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { // save a significant fraction digit
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            } else if (0 < _Idx) {
                _Sticky = true; // just update _Sticky
            }
        }

        if (_Sticky) { // increment ls digit in memory of those lost
            char* _Px = _Ptr;
            while (--_Px != _Leading) { // add in carry
                if (*_Px != localeconv()->decimal_point[0]) { // non decimal point
                    if (*_Px != '9') { // carry stops here
                        ++*_Px;
                        break;
                    }

                    *_Px = '0'; // propagate carry
                }
            }

            if (_Px == _Leading) { // change "999..." to "1000..." and scale _Pten
                *_Px = '1';
                ++_Pten;
            }
        }

        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_eoff + 1]
                || *_First == _Atoms[_Numget_eoff])) { // 'e' or 'E', collect exponent
            *_Ptr++ = 'e';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { // strip leading zeros
                _Seendigit = true;
            }

            if (_Seendigit) {
                *_Ptr++ = '0'; // put one back
            }

            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Significant < 8) { // save a significant exponent digit
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }

        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; // roll back pointer to indicate failure
        }

        *_Ptr = '\0';
        return _Pten;
    }

    int __cdecl _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { // get hex floating-point field from [_First, _Last) into _Ac
        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();

        constexpr int _Numget_signoff             = 22;
        constexpr int _Numget_xoff                = 24;
        constexpr int _Numget_poff                = 26;
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

        char* _Ptr = _Ac;
        bool _Bad  = false;
        size_t _Idx;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign
                *_Ptr++ = '-';
                ++_First;
            }
        }

        *_Ptr++ = '0';
        *_Ptr++ = 'x';

        bool _Seendigit  = false; // seen a digit in input
        int _Significant = 0; // number of significant digits
        int _Phex        = 0; // power of 10 multiplier

        if (_First != _Last && *_First == _Atoms[0]) {
            if (++_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])) {
                ++_First; // discard any 0x or 0X
            } else {
                _Seendigit = true; // '0' not followed by 'x' or 'X'
            }
        }

        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) {
                    ++_Phex; // just scale by 10
                } else if (_Idx != 0 || _Significant != 0) { // save a significant digit
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { // grouping specified, gather digits and group sizes
            const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();
            string _Groups(1, '\0');
            size_t _Group = 0;

            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff) { // got a digit, add to group size
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) {
                        ++_Phex; // just scale by 10
                    } else if (_Idx != 0 || _Significant != 0) { // save a significant digit
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Group] != 127) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                    break; // not a group separator, done
                } else { // add a new group to _Groups string
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; // add trailing group to group count
                } else {
                    _Bad = true; // trailing separator, fail
                }
            }

            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127) {
                    break; // end of grouping constraints to check
                }

                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; // bad group size, fail
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; // group size okay, advance to next test
                }
            }
        }

        if (_Seendigit && _Significant == 0) {
            *_Ptr++ = '0'; // save at least one leading digit
        }

        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { // add .
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }

        if (_Significant == 0) { // 0000. so far
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Phex; // just count leading fraction zeros
            }

            if (_Phex < 0) { // put one back
                *_Ptr++ = '0';
                ++_Phex;
            }
        }

        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
             _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { // save a significant fraction digit
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            }
        }

        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_poff + 1]
                || *_First == _Atoms[_Numget_poff])) { // 'p' or 'P', collect exponent
            *_Ptr++ = 'p';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { // strip leading zeros
                _Seendigit = true;
            }

            if (_Seendigit) {
                *_Ptr++ = '0'; // put one back
            }

            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Significant < 8) { // save a significant exponent digit
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }

        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; // roll back pointer to indicate failure
        }

        *_Ptr     = '\0';
        *_Phexexp = _Phex; // power of 16 multiplier
        return 0; // power of 10 multiplier
    }


};

// STATIC num_get::id OBJECT





template <class _Elem, class _InIt>
 locale::id num_get<_Elem, _InIt>::id;





// CLASS TEMPLATE num_put
template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_put : public locale::facet { // facet for converting encoded numbers to text
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this diagnostic.");

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
        }

        return 4;
    }

     static locale::id id; // unique facet id

protected:
    virtual  ~num_put() noexcept {}

    void  _Init(const _Locinfo&) { // initialize from _Locinfo object
    }

public:
    explicit  num_put(size_t _Refs = 0) : locale::facet(_Refs) { // construct from current locale
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
        : locale::facet(_Refs) { // construct from specified locale
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { // put formatted unsigned long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { // put formatted unsigned long long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

protected:
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest
        if (!(_Iosbase.flags() & ios_base::boolalpha)) {
            return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));
        } else { // put "false" or "true"
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str;
            if (_Val) {
                _Str.assign(_Punct_fac.truename());
            } else {
                _Str.assign(_Punct_fac.falsename());
            }

            size_t _Fillcount;
            if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {
                _Fillcount = 0;
            } else {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();
            }

            if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill
                _Dest      = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774) 
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest
        char _Buf[2 * 32], _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { // put formatted unsigned long to _Dest
        char _Buf[2 * 32], _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest
        char _Buf[2 * 32], _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { // put formatted unsigned long long to _Dest
        char _Buf[2 * 32], _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest
        string _Buf;
        char _Fmt[8];
        bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;
        streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision
        size_t _Bufsize       = static_cast<size_t>(_Precision);
        if (_Isfixed && 1e10 < :: fabs(_Val)) { // f or F format
            int _Ptwo;
            (void) :: frexp(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); // add fudge factor
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest
        string _Buf;
        char _Fmt[8];
        bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;
        streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision
        size_t _Bufsize       = static_cast<size_t>(_Precision);
        if (_Isfixed && 1e10 < :: fabsl(_Val)) { // f or F format
            int _Ptwo;
            (void) :: frexpl(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); // add fudge factor
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }
#pragma warning(pop)

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest
        char _Buf[2 * 32];

        return _Iput(
            _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
    }

private:
    char* __cdecl _Ffmt(
        char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showpoint) {
            *_Ptr++ = '#';
        }

        *_Ptr++ = '.';
        *_Ptr++ = '*'; // for precision argument
        if (_Spec != '\0') {
            *_Ptr++ = _Spec; // 'L' qualifier for long double only
        }

        char _Ch; // specifier
        ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
        if (_Flags & ios_base::uppercase) {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'A'; // added with TR1
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'E';
            } else {
                _Ch = 'G';
            }
        } else {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'a'; // added with TR1
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'e';
            } else {
                _Ch = 'g';
            }
        }
        *_Ptr++ = _Ch;

        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf,
        size_t _Count) const { // put formatted floating-point to _Dest
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        const char* _Exps;
        if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {
            _Exps = "eE";
        } else { // correct for hexadecimal floating-point
            _Exps = "pP";
            if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
                && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn(&_Buf[0], _Exps); // find exponent
        char _Dp[2]        = {"."};
        _Dp[0]             = :: localeconv()->decimal_point[0];
        const size_t _Poff = :: strcspn(&_Buf[0], &_Dp[0]); // find decimal point

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space
        _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Punct_fac.thousands_sep();

        if (_Poff != _Count) {
            _Groupstring[_Poff] = _Punct_fac.decimal_point();
        }

        size_t _Off     = _Poff == _Count ? _Eoff : _Poff;
        const char* _Pg = &_Grouping[0];
        while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {
            // add thousands separator
            _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);
            if ('\0' < _Pg[1]) {
                ++_Pg; // not last group, advance
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { // put internal fill
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill
    }

    char* __cdecl _Ifmt(
        char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for integer
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showbase) {
            *_Ptr++ = '#';
        }

        if (_Spec[0] != 'L') {
            *_Ptr++ = _Spec[0]; // qualifier
        } else { // change L to I64
            *_Ptr++ = 'I';
            *_Ptr++ = '6';
            *_Ptr++ = '4';
        }

        ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
        *_Ptr++                       = _Basefield == ios_base::oct ? 'o'
                                              : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
                                                                            : _Flags & ios_base::uppercase ? 'X' : 'x';
        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf,
        size_t _Count) const { // put formatted integer to _Dest
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
            && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
            _Prefix += 2;
        }

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space
        _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const char* _Pg        = &_Grouping[0];
        if (*_Pg != 127 && '\0' < *_Pg) { // grouping specified, add thousands separators
            const _Elem _Kseparator = _Punct_fac.thousands_sep();
            while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {
                // insert thousands separator
                _Count -= *_Pg;
                _Groupstring.insert(_Count, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; // not last group, advance
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { // put internal fill
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill
    }

    _OutIt __cdecl _Put(
        _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {
            *_Dest = *_Ptr;
        }

        return _Dest;
    }

    _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }

        return _Dest;
    }
};

// STATIC num_put::id OBJECT





template <class _Elem, class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;




template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char, istreambuf_iterator<char, char_traits<char>>>;
template class __declspec(dllimport) num_put<char, ostreambuf_iterator<char, char_traits<char>>>;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
template class __declspec(dllimport) num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
#line 1583 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"








#line 1592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"




}


#pragma warning(pop)
#pragma pack(pop)
#line 1602 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"
#line 1603 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\xlocnum"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
// CLASS TEMPLATE basic_ios
template <class _Elem, class _Traits>
class basic_ios : public ios_base { // base class for basic_istream/basic_ostream
public:
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Mysb       = basic_streambuf<_Elem, _Traits>;
    using _Ctype      = ctype<_Elem>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_ios(_Mysb* _Strbuf) { // construct from stream buffer pointer
        init(_Strbuf);
    }

    virtual  ~basic_ios() noexcept {}

    void  clear(iostate _State = goodbit, bool _Reraise = false) {
        // set state, possibly reraise exception
        ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);
    }


    void  clear(io_state _State) { // set state to _State
        clear(static_cast<iostate>(_State));
    }
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"

    void  setstate(
        iostate _State, bool _Reraise = false) { // merge _State into state, possibly reraise exception
        clear(rdstate() | _State, _Reraise);
    }


    void  setstate(io_state _State) { // merge _State into state
        setstate(static_cast<iostate>(_State));
    }
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"

    basic_ios&  copyfmt(const basic_ios& _Right) { // copy format parameters
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }

    _Myos*  tie() const { // return tie pointer
        return _Tiestr;
    }

    _Myos*  tie(_Myos* _Newtie) { // set tie pointer
        _Myos* _Oldtie = _Tiestr;
        _Tiestr        = _Newtie;
        return _Oldtie;
    }

     _Mysb*  rdbuf() const { // return stream buffer pointer
        return _Mystrbuf;
    }

    _Mysb*  rdbuf(_Mysb* _Strbuf) { // set stream buffer pointer
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        clear();
        return _Oldstrbuf;
    }

    locale  imbue(const locale& _Loc) { // set locale to argument
        locale _Oldlocale = ios_base::imbue(_Loc);
        const auto _Rdbuf = rdbuf();
        if (_Rdbuf) {
            _Rdbuf->pubimbue(_Loc);
        }

        return _Oldlocale;
    }

    _Elem  fill() const { // return fill character
        return _Fillch;
    }

    _Elem  fill(_Elem _Newfill) { // set fill character
        _Elem _Oldfill = _Fillch;
        _Fillch        = _Newfill;
        return _Oldfill;
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { // convert _Ch to byte using imbued locale
        return ::std:: use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }

    _Elem  widen(char _Byte) const { // convert _Byte to character using imbued locale
        return ::std:: use_facet<_Ctype>(getloc()).widen(_Byte);
    }

    void  move(basic_ios& _Right) { // assign by moving _Right
        if (this != ::std:: addressof(_Right)) { // different, do the move
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  move(basic_ios&& _Right) { // assign by moving _Right
        if (this != ::std:: addressof(_Right)) { // different, do the move
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  swap(basic_ios& _Right) noexcept { // swap all but rdbuf() with right
        ios_base::swap(_Right);
        ::std:: swap(_Fillch, _Right._Fillch);
        ::std:: swap(_Tiestr, _Right._Tiestr);
    }

    void  set_rdbuf(_Mysb* _Strbuf) { // set stream buffer pointer without changing state
        _Mystrbuf = _Strbuf;
    }

protected:
    void  init(_Mysb* _Strbuf = nullptr,
        bool _Isstd                             = false) { // initialize with stream buffer pointer
        _Init(); // initialize ios_base
        _Mystrbuf = _Strbuf;
        _Tiestr   = nullptr;
        _Fillch   = widen(' ');

        if (!_Mystrbuf) {
            setstate(badbit);
        }

        if (_Isstd) {
            _Addstd(this); // special handling for standard streams
        }
    }

     basic_ios() {}

private:
    _Mysb* _Mystrbuf; // pointer to stream buffer
    _Myos* _Tiestr; // pointer to tied output stream
    _Elem _Fillch; // the fill character

public:
     basic_ios(const basic_ios&) = delete;
    basic_ios&  operator=(const basic_ios&) = delete;
};




template class __declspec(dllimport) basic_ios<char, char_traits<char>>;
template class __declspec(dllimport) basic_ios<wchar_t, char_traits<wchar_t>>;
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"




#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"

// MANIPULATORS
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase) { // set boolalpha
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}

inline ios_base& __cdecl dec(ios_base& _Iosbase) { // set basefield to dec
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase) { // clear floatfield
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl fixed(ios_base& _Iosbase) { // set floatfield to fixed
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl hex(ios_base& _Iosbase) { // set basefield to hex
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase) { // set floatfield to hexfloat
    _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl internal(ios_base& _Iosbase) { // set adjustfield to internal
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __cdecl left(ios_base& _Iosbase) { // set adjustfield to left
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase) { // clear boolalpha
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase) { // clear showbase
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase) { // clear showpoint
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase) { // clear showpos
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase) { // clear skipws
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase) { // clear unitbuf
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase) { // clear uppercase
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}

inline ios_base& __cdecl oct(ios_base& _Iosbase) { // set oct in basefield
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __cdecl right(ios_base& _Iosbase) { // set right in adjustfield
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __cdecl scientific(ios_base& _Iosbase) { // set scientific in floatfield
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __cdecl showbase(ios_base& _Iosbase) { // set showbase
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase) { // set showpoint
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}

inline ios_base& __cdecl showpos(ios_base& _Iosbase) { // set showpos
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}

inline ios_base& __cdecl skipws(ios_base& _Iosbase) { // set skipws
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase) { // set unitbuf
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase) { // set uppercase
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: hexfloat;
}
#line 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"

}



#pragma warning(pop)
#pragma pack(pop)
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ios"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
#pragma vtordisp(push, 2) 

// CLASS TEMPLATE basic_ostream
template <class _Elem, class _Traits>
class basic_ostream : virtual public basic_ios<_Elem, _Traits> { // control insertions into a stream buffer
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = ostreambuf_iterator<_Elem, _Traits>;
    using _Nput  = num_put<_Elem, _Iter>;

    explicit  basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf,

        bool _Isstd = false) { // construct from a stream buffer pointer
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_ostream(_Uninitialized, bool _Addit = true) { // construct uninitialized
        if (_Addit) {
            this->_Addstd(this); // suppress for basic_iostream
        }
    }

protected:
     basic_ostream(basic_ostream&& _Right) { // construct by moving _Right
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_ostream&  operator=(basic_ostream&& _Right) { // move from _Right
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_ostream& _Right) { // swap with _Right
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_ostream(const basic_ostream&) = delete;
    basic_ostream&  operator=(const basic_ostream&) = delete;

    virtual  ~basic_ostream() noexcept {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base { // stores thread lock and reference to output stream
    public:
         _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept { // destroy after unlocking
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_ostream& _Myostr; // the output stream, for _Unlock call at destruction

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base { // stores thread lock and state of stream
    public:
        explicit  sentry(basic_ostream& _Ostr)
            : _Sentry_base(_Ostr) { // construct locking and testing stream
            if (!_Ostr.good()) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr.tie();
            if (!_Tied || _Tied == &_Ostr) {
                _Ok = true;
                return;
            }


            _Tied->flush();
            _Ok = _Ostr.good(); // store test only after flushing tie
        }





#pragma warning(push)
#pragma warning(disable : 4996) 
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"
         ~sentry() noexcept {

            if (!::std:: uncaught_exception()) { // TRANSITION, OS#15518458
                this->_Myostr._Osfx();
            }


#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"
        }



#pragma warning(pop)
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"

        explicit  operator bool() const { // test if stream state okay
            return _Ok;
        }

         sentry(const sentry&) = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; // true if stream state okay at construction
    };

    bool  opfx() { // test stream state and flush tie stream as needed (retained)
        if (!this->good()) {
            return false;
        }

        const auto _Tied = _Myios::tie();
        if (!_Tied || _Myios::tie() == this) {
            return true;
        }

        _Tied->flush();
        return this->good();
    }

    void  osfx() { // perform any wrapup (retained)
        _Osfx();
    }

    void  _Osfx() { // perform any wrapup
        try {
        if (this->good() && this->flags() & ios_base::unitbuf) {
            if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed
                _Myios::setstate(ios_base::badbit);
            }
        }
        } catch (...) {
        }
    }


















    basic_ostream&  operator<<(
        basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) { // call basic_ostream manipulator
        return _Pfn(*this);
    }

    basic_ostream&  operator<<(_Myios&(__cdecl* _Pfn)(_Myios&) ) { // call basic_ios manipulator
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(ios_base&(__cdecl* _Pfn)(ios_base&) ) { // call ios_base manipulator
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(bool _Val) { // insert a boolean
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(short _Val) { // insert a short
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned short>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    // NOTE:
    // If you are not using native wchar_t, the unsigned short inserter
    // is masked by an explicit specialization that treats an unsigned
    // short as a wide character.

    // To read or write unsigned shorts as integers with wchar_t streams,
    // make wchar_t a native type with the command line option /Zc:wchar_t.

    basic_ostream&  operator<<(unsigned short _Val) { // insert an unsigned short
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(int _Val) { // insert an int
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned int _Val) { // insert an unsigned int
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long _Val) { // insert a long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long _Val) { // insert an unsigned long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long long _Val) { // insert a long long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long long _Val) { // insert an unsigned long long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(float _Val) { // insert a float
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(double _Val) { // insert a double
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long double _Val) { // insert a long double
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(const void* _Val) { // insert a void pointer
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }






#line 468 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"

    basic_ostream&  operator<<(_Mysb* _Strbuf) { // insert until end-of-file from a stream buffer
        ios_base::iostate _State = ios_base::goodbit;
        bool _Copied             = false;
        const sentry _Ok(*this);

        if (_Ok && _Strbuf) {
            for (int_type _Meta = _Traits::eof();; _Copied = true) { // extract another character from stream buffer
                try {
                _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                } catch (...) {
                _Myios::setstate(ios_base::failbit);
                throw;
                }

                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; // end of file, quit
                }

                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta)))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            }
        }

        this->width(0);
        int _Setstate_with;
        if (_Strbuf) {
            if (_Copied) {
                _Setstate_with = _State;
            } else {
                _Setstate_with = _State | ios_base::failbit;
            }
        } else {
            _Setstate_with = ios_base::badbit;
        }

        _Myios::setstate(_Setstate_with);
        return *this;
    }

    basic_ostream&  put(_Elem _Ch) { // insert a character
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else { // state okay, insert character
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  write(const _Elem* _Str,
        streamsize _Count) { // insert _Count characters from array _Str
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else if (0 < _Count) { // state okay, insert characters
            try {
            if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  flush() { // flush output stream
        const auto _Rdbuf = _Myios::rdbuf();
        if (_Rdbuf) { // buffer exists, flush it
            const sentry _Ok(*this);

            if (_Ok && _Rdbuf->pubsync() == -1) {
                _Myios::setstate(ios_base::badbit); // sync failed
            }
        }
        return *this;
    }

    basic_ostream&  seekp(pos_type _Pos) { // set output stream position to _Pos
        const sentry _Ok(*this);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)) == -1) {
            _Myios::setstate(ios_base::failbit);
        }

        return *this;
    }

    basic_ostream&  seekp(
        off_type _Off, ios_base::seekdir _Way) { // change output stream position by _Off, according to _Way
        const sentry _Ok(*this);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)) == -1) {
            _Myios::setstate(ios_base::failbit);
        }

        return *this;
    }

    pos_type  tellp() { // return output stream position
        const sentry _Ok(*this);

        if (!this->fail()) {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        } else {
            return pos_type(-1);
        }
    }
};

#pragma vtordisp(pop) 



















































template class __declspec(dllimport) basic_ostream<char, char_traits<char>>;
template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t>>;
#line 648 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"




#line 653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"

// INSERTERS

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { // insert NTBS
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(:: strlen(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { // state okay, insert characters
        try {
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {
                _State |= ios_base::badbit;
            }
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch) { // insert a character
    ios_base::iostate _State = ios_base::goodbit;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (_Ok) { // state okay, insert
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        streamsize _Pad                = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit
            && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch)))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr,
    const char* _Val) { // insert NTBS into char stream
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { // state okay, insert
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, char _Ch) { // insert a char into char stream
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { // state okay, insert
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { // insert NTCS
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { // state okay, insert
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch) { // insert a character
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { // state okay, insert
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, const signed char* _Val) { // insert a signed char NTBS
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, signed char _Ch) { // insert a signed char
    return _Ostr << static_cast<char>(_Ch);
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val) { // insert an unsigned char NTBS
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

template <class _Traits>
basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch) { // insert an unsigned char
    return _Ostr << static_cast<char>(_Ch);
}









#line 930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"

template <class _Ostr, class _Ty, class = void>
struct _Can_stream_out : false_type {};

template <class _Ostr, class _Ty>
struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std:: declval<_Ostr&>() << ::std:: declval<const _Ty&>())>> : true_type {
};

template <class _Ostr, class _Ty,
    enable_if_t<conjunction_v< // prevent infinite recursion
                    negation<is_lvalue_reference<_Ostr>>, is_base_of<ios_base, _Ostr>, _Can_stream_out<_Ostr, _Ty>>,
        int> = 0>
_Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val) { // insert to rvalue stream
    _Os << _Val;
    return ::std:: move(_Os);
}

// MANIPULATORS
template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl endl(
    basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream
    _Ostr.put(_Ostr.widen('\n'));
    _Ostr.flush();
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr) { // insert null character
    _Ostr.put(_Elem());
    return _Ostr;
}

template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr) { // flush stream
    _Ostr.flush();
    return _Ostr;
}

// INSERTER FOR error_category
template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const error_code& _Errcode) { // display error code
    return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 981 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"
#line 982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\ostream"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )




namespace std {
#pragma vtordisp(push, 2) 

// CLASS TEMPLATE basic_istream
template <class _Elem, class _Traits>
class basic_istream : virtual public basic_ios<_Elem, _Traits> { // control extractions from a stream buffer
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = istreambuf_iterator<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using _Nget  = num_get<_Elem, _Iter>;








#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"

    explicit  basic_istream(_Mysb* _Strbuf,
        bool _Isstd = false)

        : _Chcount(0) { // construct from stream buffer pointer
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_istream(_Uninitialized) { // construct uninitialized
        this->_Addstd(this);
    }

protected:
     basic_istream(basic_istream&& _Right) : _Chcount(_Right._Chcount) { // construct by moving _Right
        _Myios::init();
        _Myios::move(::std:: move(_Right));
        _Right._Chcount = 0;
    }

    basic_istream&  operator=(basic_istream&& _Right) { // move from _Right
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_istream& _Right) { // swap with _Right
        _Myios::swap(_Right);
        ::std:: swap(_Chcount, _Right._Chcount);
    }

public:
     basic_istream(const basic_istream&) = delete;
    basic_istream&  operator=(const basic_istream&) = delete;

    virtual  ~basic_istream() noexcept {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    // CLASS TEMPLATE sentry
    class _Sentry_base { // stores thread lock and reference to input stream
    public:
         _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) { // lock the stream buffer, if there
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept { // destroy after unlocking
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_istream& _Myistr; // the input stream, for _Unlock call at destruction

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base { // stores thread lock and result of _Ipfx call
    public:
        explicit  sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr) { // construct locking and calling _Ipfx
            _Ok = this->_Myistr._Ipfx(_Noskip);
        }

        explicit  operator bool() const { // test if _Ipfx succeeded
            return _Ok;
        }

         sentry(const sentry&) = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; // true if _Ipfx succeeded at construction
    };

    bool  _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed
        if (!this->good()) {
            _Myios::setstate(ios_base::failbit);
            return false;
        }

        // state okay, flush tied stream and skip whitespace
        const auto _Tied = _Myios::tie();
        if (_Tied) {
            _Tied->flush();
        }

        bool _Eof = false;
        if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace
            const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(this->getloc());

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _Eof = true;
                    break;
                } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                    break; // not whitespace, quit
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Eof) {
            _Myios::setstate(ios_base::eofbit | ios_base::failbit);
        }

        return this->good();
    }

    bool  ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed (retained)
        return _Ipfx(_Noskip);
    }

    void  isfx() { // perform any wrapup (retained)
    }


















    basic_istream&  operator>>(
        basic_istream&(__cdecl* _Pfn)(basic_istream&) ) { // call basic_istream manipulator
        return _Pfn(*this);
    }

    basic_istream&  operator>>(_Myios&(__cdecl* _Pfn)(_Myios&) ) { // call basic_ios manipulator
        _Pfn(*this);
        return *this;
    }

    basic_istream&  operator>>(ios_base&(__cdecl* _Pfn)(ios_base&) ) { // call ios_base manipulator
        _Pfn(*this);
        return *this;
    }

private:
    template <class _Ty>
    basic_istream& _Common_extract_with_num_get(_Ty& _Val) { // formatted extract with num_get
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to extract
            try {
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

public:
    basic_istream&  operator>>(bool& _Val) { // extract a boolean
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(short& _Val) { // extract a short
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to extract
            try {
            long _Lval;
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
            if (_Lval < (-32768)) {
                _Err |= ios_base::failbit;
                _Val = (-32768);
            } else if (_Lval > 32767) {
                _Err |= ios_base::failbit;
                _Val = 32767;
            } else {
                _Val = static_cast<short>(_Lval);
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    // NOTE:
    // If you are not using native wchar_t, the unsigned short extractor
    // is masked by an explicit specialization that treats an unsigned
    // short as a wide character.

    // To read or write unsigned shorts as integers with wchar_t streams,
    // make wchar_t a native type with the command line option /Zc:wchar_t.

    basic_istream&  operator>>(unsigned short& _Val) { // extract an unsigned short
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(int& _Val) { // extract an int
        static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
        long _Result = _Val;
        _Common_extract_with_num_get(_Result);
        _Val = _Result;
        return *this;
    }

    basic_istream&  operator>>(unsigned int& _Val) { // extract an unsigned int
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long& _Val) { // extract a long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long& _Val) { // extract an unsigned long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long long& _Val) { // extract a long long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long long& _Val) { // extract an unsigned long long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(float& _Val) { // extract a float
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(double& _Val) { // extract a double
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long double& _Val) { // extract a long double
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(void*& _Val) { // extract a void pointer
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(_Mysb* _Strbuf) { // extract until end-of-file into a stream buffer
        _Chcount = 0; // behaves as an unformatted input function
        const sentry _Ok(*this, true);
        ios_base::iostate _State = ios_base::goodbit;
        if (_Ok && _Strbuf) { // state okay, extract characters
            try {
            for (int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                }
                // got a character, insert it into buffer
                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta)))) {
                    break;
                }

                } catch (...) {
                break;
                }

                ++_Chcount;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) { // If the function inserts no characters, it calls setstate(failbit)
            _State |= ios_base::failbit;
        }

        _Myios::setstate(_State);
        return *this;
    }

    int_type  get() { // extract a metacharacter
        int_type _Meta           = 0;
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); // state not okay, return EOF
        } else { // state okay, extract a character
            try {
            _Meta = _Myios::rdbuf()->sgetc();

            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _State |= ios_base::eofbit | ios_base::failbit; // end of file
            } else { // got a character, count it
                _Myios::rdbuf()->sbumpc();
                ++_Chcount;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  get(_Elem* _Str, streamsize _Count) { // get up to _Count characters into NTCS
        return get(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  get(
        _Elem* _Str, streamsize _Count, _Elem _Delim) { // get up to _Count characters into NTCS, stop before _Delim
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, extract characters
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Traits::to_char_type(_Meta) == _Delim) {
                    break; // got a delimiter, quit
                } else { // got a character, add it to string
                    *_Str++ = _Traits::to_char_type(_Meta);
                    ++_Chcount;
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        *_Str = _Elem(); // add terminating null character
        return *this;
    }

    basic_istream&  get(_Elem& _Ch) { // get a character
        int_type _Meta = get();
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _Ch = _Traits::to_char_type(_Meta);
        }

        return *this;
    }

    basic_istream&  get(_Mysb& _Strbuf) { // extract up to newline and insert into stream buffer
        return get(_Strbuf, _Myios::widen('\n'));
    }

    basic_istream&  get(
        _Mysb& _Strbuf, _Elem _Delim) { // extract up to delimiter and insert into stream buffer
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok) { // state okay, use facet to extract
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                } else { // got a character, insert it into stream buffer
                    try {
                    _Elem _Ch = _Traits::to_char_type(_Meta);
                    if (_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch))) {
                        break;
                    }
                    } catch (...) {
                    break;
                    }
                    ++_Chcount;
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) {
            _State |= ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  getline(
        _Elem* _Str, streamsize _Count) { // get up to _Count characters into NTCS, discard newline
        return getline(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  getline(
        _Elem* _Str, streamsize _Count, _Elem _Delim) { // get up to _Count characters into NTCS, discard _Delim
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, use facet to extract
            int_type _Metadelim = _Traits::to_int_type(_Delim);

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Meta == _Metadelim) { // got a delimiter, discard it and quit
                    ++_Chcount;
                    _Myios::rdbuf()->sbumpc();
                    break;
                } else if (--_Count <= 0) { // buffer full, quit
                    _State |= ios_base::failbit;
                    break;
                } else { // got a character, add it to string
                    *_Str++ = _Traits::to_char_type(_Meta);
                    ++_Chcount;
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        *_Str = _Elem(); // add terminating null character
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        return *this;
    }

    basic_istream&  ignore(streamsize _Count = 1,
        int_type _Metadelim = _Traits::eof()) { // ignore up to _Count characters, discarding delimiter
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, use facet to extract
            try {
            for (;;) { // get a metacharacter if more room in buffer
                int_type _Meta;
                if (_Count != (numeric_limits<streamsize>::max)() && --_Count < 0) {
                    break; // buffer full, quit
                } else if (_Traits::eq_int_type(_Traits::eof(),
                               _Meta = _Myios::rdbuf()->sbumpc())) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                } else { // got a character, count it
                    ++_Chcount;
                    if (_Meta == _Metadelim) {
                        break; // got a delimiter, quit
                    }
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  read(_Elem* _Str, streamsize _Count) { // read up to _Count characters into buffer
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, use facet to extract
            try {
            const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
            _Chcount += _Num;
            if (_Num != _Count) {
                _State |= ios_base::eofbit | ios_base::failbit; // short read
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    streamsize  readsome(_Elem* _Str,
        streamsize _Count) { // read up to _Count characters into buffer, without blocking
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        streamsize _Num;

        if (!_Ok) {
            _State |= ios_base::failbit; // no buffer, fail
        } else if ((_Num = _Myios::rdbuf()->in_avail()) < 0) {
            _State |= ios_base::eofbit; // no characters available
        } else if (0 < _Count && 0 < _Num) { // read available
            read(_Str, _Num < _Count ? _Num : _Count);
        }

        _Myios::setstate(_State);
        return gcount();
    }

    int_type  peek() { // return next character, unconsumed
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        int_type _Meta           = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); // state not okay, return EOF
        } else { // state okay, read a character
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc())) {
                _State |= ios_base::eofbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  putback(_Elem _Ch) { // put back a character
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { // state okay, put character back
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch))) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  unget() { // put back last read character
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { // state okay, put character back
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc())) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

     streamsize  gcount() const { // get count from last extraction
        return _Chcount;
    }

    int  sync() { // synchronize with input source
        const sentry _Ok(*this, true);

        const auto _Rdbuf = _Myios::rdbuf();
        if (!_Rdbuf) {
            return -1;
        }

        bool _Sync_failed = true; // sync fails if an exception is thrown
        try {
        _Sync_failed = _Rdbuf->pubsync() == -1;
        } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        if (_Sync_failed) {
            _Myios::setstate(ios_base::badbit);
            return -1;
        }

        return 0;
    }

    basic_istream&  seekg(pos_type _Pos) { // set input stream position to _Pos
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)) == -1) {
            _Myios::setstate(_State | ios_base::failbit);
        }

        return *this;
    }

    basic_istream&  seekg(
        off_type _Off, ios_base::seekdir _Way) { // change input stream position by _Off, according to _Way
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1) {
            _Myios::setstate(_State | ios_base::failbit);
        }

        return *this;
    }

    pos_type  tellg() { // return input stream position
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
        } else {
            return pos_type(-1);
        }
    }

private:
    streamsize _Chcount; // the character count
};

#pragma vtordisp(pop) 























template class __declspec(dllimport) basic_istream<char, char_traits<char>>;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t>>;
#line 693 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"




#line 698 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"

// CLASS TEMPLATE basic_iostream
template <class _Elem, class _Traits>
class basic_iostream : public basic_istream<_Elem, _Traits>,
                       public basic_ostream<_Elem, _Traits> { // control insertions and extractions from a stream buffer
public:
    using _Myis       = basic_istream<_Elem, _Traits>;
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Myios      = basic_ios<_Elem, _Traits>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf)
        : _Myis(_Strbuf, false), _Myos(_Noinit, false) { // construct from stream buffer pointer
    }

protected:
     basic_iostream(basic_iostream&& _Right)
        : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false) { // construct by moving _Right
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_iostream&  operator=(basic_iostream&& _Right) { // move from _Right
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_iostream& _Right) { // swap with _Right
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_iostream(const basic_iostream&) = delete;
    basic_iostream&  operator=(const basic_iostream&) = delete;

    virtual  ~basic_iostream() noexcept {}
};




template class __declspec(dllimport) basic_iostream<char, char_traits<char>>;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t>>;
#line 748 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"




#line 753 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"

// EXTRACTORS

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& _Istream_extract_into_buffer(
    basic_istream<_Elem, _Traits>& _Istr, size_t _Size, _Elem* _Str) {
    using _Myis              = basic_istream<_Elem, _Traits>;
    using _Ctype             = ctype<_Elem>;
    ios_base::iostate _State = ios_base::goodbit;
    size_t _Current          = 0;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { // state okay, extract characters
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());

        try {
        size_t _Count       = _Size;
        const size_t _Width = static_cast<size_t>(_Istr.width());
        if (_Width > 0 && _Width < _Size) {
            _Count = _Width;
        }

        typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr.rdbuf()->snextc(), (void) ++_Current) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                _State |= ios_base::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem()) {
                break; // whitespace or nul, quit
            } else {
                _Str[_Current] = _Traits::to_char_type(_Meta); // add it to string
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }
    ; // TRANSITION, VSO#860375
    _Str[_Current] = _Elem(); // add terminating null character
    _Istr.width(0);
    if (_Current == 0) {
        _State |= ios_base::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}






















#line 822 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"
template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem* _Str) {
    return _Istream_extract_into_buffer(_Istr, 0xffffffff, _Str);
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char* _Str) {
    return _Istream_extract_into_buffer(_Istr, 0xffffffff, reinterpret_cast<char*>(_Str));
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char* _Str) {
    return _Istream_extract_into_buffer(_Istr, 0xffffffff, reinterpret_cast<char*>(_Str));
}
#line 837 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch) { // extract a character
    using _Myis = basic_istream<_Elem, _Traits>;

    typename _Myis::int_type _Meta;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { // state okay, extract characters
        try {
        _Meta = _Istr.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _State |= ios_base::eofbit | ios_base::failbit; // end of file
        } else {
            _Ch = _Traits::to_char_type(_Meta); // got a character
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }

    _Istr.setstate(_State);
    return _Istr;
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, signed char& _Ch) { // extract a signed char
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, unsigned char& _Ch) { // extract an unsigned char
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Istr, class _Ty, class = void>
struct _Can_stream_in : false_type {};

template <class _Istr, class _Ty>
struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std:: declval<_Istr&>() >> ::std:: declval<_Ty>())>> : true_type {};

template <class _Istr, class _Ty,
    enable_if_t<conjunction_v< // avoid infinite recursion
                    negation<is_lvalue_reference<_Istr>>, is_base_of<ios_base, _Istr>, _Can_stream_in<_Istr, _Ty>>,
        int> = 0>
_Istr&& operator>>(_Istr&& _Is, _Ty&& _Val) { // extract from rvalue stream
    _Is >> ::std:: forward<_Ty>(_Val);
    return ::std:: move(_Is);
}

// MANIPULATORS
template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& __cdecl ws(basic_istream<_Elem, _Traits>& _Istr) { // consume whitespace
    const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

    if (_Ok) { // state okay, extract characters
        ios_base::iostate _State = ios_base::goodbit;
        const auto& _Ctype_fac   = ::std:: use_facet<ctype<_Elem>>(_Istr.getloc());

        try {
        for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                _State |= ios_base::eofbit;
                break;
            } else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta))) {
                break; // not whitespace, quit
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        _Istr.setstate(_State);
    }

    return _Istr;
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"
#line 920 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\istream"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iostream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045  4984 )



namespace std {












      // OBJECTS
 extern __declspec(dllimport) istream cin, *_Ptr_cin;
 extern __declspec(dllimport) ostream cout, *_Ptr_cout;
 extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
 extern __declspec(dllimport) ostream clog, *_Ptr_clog;

 extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
 extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
 extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
 extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

// CLASS _Winit
class __declspec(dllimport) _Winit {
public:
    __thiscall _Winit();
    __thiscall ~_Winit() noexcept;

private:
     static int _Init_cnt;
};
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iostream"
}


#pragma warning(pop)
#pragma pack(pop)
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iostream"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\VC\\Tools\\MSVC\\14.23.28019\\include\\iostream"

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
#line 2 "C:\\Users\\a1547\\source\\repos\\编译原理\\编译原理\\源.cpp"
using namespace std;
void main()
{
	//娉ㄩ
	int i, n, f;

	cin >> n;
	i = 2;
	f = 1;
	while (i <= n)
	{
		f = f * i;
		i = i + 1;
	}
	cout << f << endl;
}
